/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-table";
exports.ids = ["vendor-chunks/react-table"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-table/dist/react-table.development.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-table/dist/react-table.development.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\")) :\n  0;\n}(this, (function (exports, React) { 'use strict';\n\n  React = React && Object.prototype.hasOwnProperty.call(React, 'default') ? React['default'] : React;\n\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  function _asyncToGenerator(fn) {\n    return function () {\n      var self = this,\n          args = arguments;\n      return new Promise(function (resolve, reject) {\n        var gen = fn.apply(self, args);\n\n        function _next(value) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n        }\n\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n\n    return (hint === \"string\" ? String : Number)(input);\n  }\n\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n\n    return typeof key === \"symbol\" ? key : String(key);\n  }\n\n  var renderErr = 'Renderer Error ☝️';\n  var actions = {\n    init: 'init'\n  };\n  var defaultRenderer = function defaultRenderer(_ref) {\n    var _ref$value = _ref.value,\n        value = _ref$value === void 0 ? '' : _ref$value;\n    return value;\n  };\n  var emptyRenderer = function emptyRenderer() {\n    return React.createElement(React.Fragment, null, \"\\xA0\");\n  };\n  var defaultColumn = {\n    Cell: defaultRenderer,\n    width: 150,\n    minWidth: 0,\n    maxWidth: Number.MAX_SAFE_INTEGER\n  };\n\n  function mergeProps() {\n    for (var _len = arguments.length, propList = new Array(_len), _key = 0; _key < _len; _key++) {\n      propList[_key] = arguments[_key];\n    }\n\n    return propList.reduce(function (props, next) {\n      var style = next.style,\n          className = next.className,\n          rest = _objectWithoutPropertiesLoose(next, [\"style\", \"className\"]);\n\n      props = _extends({}, props, {}, rest);\n\n      if (style) {\n        props.style = props.style ? _extends({}, props.style || {}, {}, style || {}) : style;\n      }\n\n      if (className) {\n        props.className = props.className ? props.className + ' ' + className : className;\n      }\n\n      if (props.className === '') {\n        delete props.className;\n      }\n\n      return props;\n    }, {});\n  }\n\n  function handlePropGetter(prevProps, userProps, meta) {\n    // Handle a lambda, pass it the previous props\n    if (typeof userProps === 'function') {\n      return handlePropGetter({}, userProps(prevProps, meta));\n    } // Handle an array, merge each item as separate props\n\n\n    if (Array.isArray(userProps)) {\n      return mergeProps.apply(void 0, [prevProps].concat(userProps));\n    } // Handle an object by default, merge the two objects\n\n\n    return mergeProps(prevProps, userProps);\n  }\n\n  var makePropGetter = function makePropGetter(hooks, meta) {\n    if (meta === void 0) {\n      meta = {};\n    }\n\n    return function (userProps) {\n      if (userProps === void 0) {\n        userProps = {};\n      }\n\n      return [].concat(hooks, [userProps]).reduce(function (prev, next) {\n        return handlePropGetter(prev, next, _extends({}, meta, {\n          userProps: userProps\n        }));\n      }, {});\n    };\n  };\n  var reduceHooks = function reduceHooks(hooks, initial, meta, allowUndefined) {\n    if (meta === void 0) {\n      meta = {};\n    }\n\n    return hooks.reduce(function (prev, next) {\n      var nextValue = next(prev, meta);\n\n      {\n        if (!allowUndefined && typeof nextValue === 'undefined') {\n          console.info(next);\n          throw new Error('React Table: A reducer hook ☝️ just returned undefined! This is not allowed.');\n        }\n      }\n\n      return nextValue;\n    }, initial);\n  };\n  var loopHooks = function loopHooks(hooks, context, meta) {\n    if (meta === void 0) {\n      meta = {};\n    }\n\n    return hooks.forEach(function (hook) {\n      var nextValue = hook(context, meta);\n\n      {\n        if (typeof nextValue !== 'undefined') {\n          console.info(hook, nextValue);\n          throw new Error('React Table: A loop-type hook ☝️ just returned a value! This is not allowed.');\n        }\n      }\n    });\n  };\n  function ensurePluginOrder(plugins, befores, pluginName, afters) {\n    if ( afters) {\n      throw new Error(\"Defining plugins in the \\\"after\\\" section of ensurePluginOrder is no longer supported (see plugin \" + pluginName + \")\");\n    }\n\n    var pluginIndex = plugins.findIndex(function (plugin) {\n      return plugin.pluginName === pluginName;\n    });\n\n    if (pluginIndex === -1) {\n      {\n        throw new Error(\"The plugin \\\"\" + pluginName + \"\\\" was not found in the plugin list!\\nThis usually means you need to need to name your plugin hook by setting the 'pluginName' property of the hook function, eg:\\n\\n  \" + pluginName + \".pluginName = '\" + pluginName + \"'\\n\");\n      }\n    }\n\n    befores.forEach(function (before) {\n      var beforeIndex = plugins.findIndex(function (plugin) {\n        return plugin.pluginName === before;\n      });\n\n      if (beforeIndex > -1 && beforeIndex > pluginIndex) {\n        {\n          throw new Error(\"React Table: The \" + pluginName + \" plugin hook must be placed after the \" + before + \" plugin hook!\");\n        }\n      }\n    });\n  }\n  function functionalUpdate(updater, old) {\n    return typeof updater === 'function' ? updater(old) : updater;\n  }\n  function useGetLatest(obj) {\n    var ref = React.useRef();\n    ref.current = obj;\n    return React.useCallback(function () {\n      return ref.current;\n    }, []);\n  } // SSR has issues with useLayoutEffect still, so use useEffect during SSR\n\n  var safeUseLayoutEffect = typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n  function useMountedLayoutEffect(fn, deps) {\n    var mountedRef = React.useRef(false);\n    safeUseLayoutEffect(function () {\n      if (mountedRef.current) {\n        fn();\n      }\n\n      mountedRef.current = true; // eslint-disable-next-line\n    }, deps);\n  }\n  function useAsyncDebounce(defaultFn, defaultWait) {\n    if (defaultWait === void 0) {\n      defaultWait = 0;\n    }\n\n    var debounceRef = React.useRef({});\n    var getDefaultFn = useGetLatest(defaultFn);\n    var getDefaultWait = useGetLatest(defaultWait);\n    return React.useCallback(\n    /*#__PURE__*/\n    function () {\n      var _ref2 = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee2() {\n        var _len2,\n            args,\n            _key2,\n            _args2 = arguments;\n\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                for (_len2 = _args2.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = _args2[_key2];\n                }\n\n                if (!debounceRef.current.promise) {\n                  debounceRef.current.promise = new Promise(function (resolve, reject) {\n                    debounceRef.current.resolve = resolve;\n                    debounceRef.current.reject = reject;\n                  });\n                }\n\n                if (debounceRef.current.timeout) {\n                  clearTimeout(debounceRef.current.timeout);\n                }\n\n                debounceRef.current.timeout = setTimeout(\n                /*#__PURE__*/\n                _asyncToGenerator(\n                /*#__PURE__*/\n                regeneratorRuntime.mark(function _callee() {\n                  return regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          delete debounceRef.current.timeout;\n                          _context.prev = 1;\n                          _context.t0 = debounceRef.current;\n                          _context.next = 5;\n                          return getDefaultFn().apply(void 0, args);\n\n                        case 5:\n                          _context.t1 = _context.sent;\n\n                          _context.t0.resolve.call(_context.t0, _context.t1);\n\n                          _context.next = 12;\n                          break;\n\n                        case 9:\n                          _context.prev = 9;\n                          _context.t2 = _context[\"catch\"](1);\n                          debounceRef.current.reject(_context.t2);\n\n                        case 12:\n                          _context.prev = 12;\n                          delete debounceRef.current.promise;\n                          return _context.finish(12);\n\n                        case 15:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee, null, [[1, 9, 12, 15]]);\n                })), getDefaultWait());\n                return _context2.abrupt(\"return\", debounceRef.current.promise);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function () {\n        return _ref2.apply(this, arguments);\n      };\n    }(), [getDefaultFn, getDefaultWait]);\n  }\n  function makeRenderer(instance, column, meta) {\n    if (meta === void 0) {\n      meta = {};\n    }\n\n    return function (type, userProps) {\n      if (userProps === void 0) {\n        userProps = {};\n      }\n\n      var Comp = typeof type === 'string' ? column[type] : type;\n\n      if (typeof Comp === 'undefined') {\n        console.info(column);\n        throw new Error(renderErr);\n      }\n\n      return flexRender(Comp, _extends({}, instance, {\n        column: column\n      }, meta, {}, userProps));\n    };\n  }\n  function flexRender(Comp, props) {\n    return isReactComponent(Comp) ? React.createElement(Comp, props) : Comp;\n  }\n\n  function isReactComponent(component) {\n    return isClassComponent(component) || typeof component === 'function' || isExoticComponent(component);\n  }\n\n  function isClassComponent(component) {\n    return typeof component === 'function' && function () {\n      var proto = Object.getPrototypeOf(component);\n      return proto.prototype && proto.prototype.isReactComponent;\n    }();\n  }\n\n  function isExoticComponent(component) {\n    return typeof component === 'object' && typeof component.$$typeof === 'symbol' && ['react.memo', 'react.forward_ref'].includes(component.$$typeof.description);\n  }\n\n  function linkColumnStructure(columns, parent, depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n\n    return columns.map(function (column) {\n      column = _extends({}, column, {\n        parent: parent,\n        depth: depth\n      });\n      assignColumnAccessor(column);\n\n      if (column.columns) {\n        column.columns = linkColumnStructure(column.columns, column, depth + 1);\n      }\n\n      return column;\n    });\n  }\n  function flattenColumns(columns) {\n    return flattenBy(columns, 'columns');\n  }\n  function assignColumnAccessor(column) {\n    // First check for string accessor\n    var id = column.id,\n        accessor = column.accessor,\n        Header = column.Header;\n\n    if (typeof accessor === 'string') {\n      id = id || accessor;\n      var accessorPath = accessor.split('.');\n\n      accessor = function accessor(row) {\n        return getBy(row, accessorPath);\n      };\n    }\n\n    if (!id && typeof Header === 'string' && Header) {\n      id = Header;\n    }\n\n    if (!id && column.columns) {\n      console.error(column);\n      throw new Error('A column ID (or unique \"Header\" value) is required!');\n    }\n\n    if (!id) {\n      console.error(column);\n      throw new Error('A column ID (or string accessor) is required!');\n    }\n\n    Object.assign(column, {\n      id: id,\n      accessor: accessor\n    });\n    return column;\n  }\n  function decorateColumn(column, userDefaultColumn) {\n    if (!userDefaultColumn) {\n      throw new Error();\n    }\n\n    Object.assign(column, _extends({\n      // Make sure there is a fallback header, just in case\n      Header: emptyRenderer,\n      Footer: emptyRenderer\n    }, defaultColumn, {}, userDefaultColumn, {}, column));\n    Object.assign(column, {\n      originalWidth: column.width\n    });\n    return column;\n  } // Build the header groups from the bottom up\n\n  function makeHeaderGroups(allColumns, defaultColumn, additionalHeaderProperties) {\n    if (additionalHeaderProperties === void 0) {\n      additionalHeaderProperties = function additionalHeaderProperties() {\n        return {};\n      };\n    }\n\n    var headerGroups = [];\n    var scanColumns = allColumns;\n    var uid = 0;\n\n    var getUID = function getUID() {\n      return uid++;\n    };\n\n    var _loop = function _loop() {\n      // The header group we are creating\n      var headerGroup = {\n        headers: []\n      }; // The parent columns we're going to scan next\n\n      var parentColumns = [];\n      var hasParents = scanColumns.some(function (d) {\n        return d.parent;\n      }); // Scan each column for parents\n\n      scanColumns.forEach(function (column) {\n        // What is the latest (last) parent column?\n        var latestParentColumn = [].concat(parentColumns).reverse()[0];\n        var newParent;\n\n        if (hasParents) {\n          // If the column has a parent, add it if necessary\n          if (column.parent) {\n            newParent = _extends({}, column.parent, {\n              originalId: column.parent.id,\n              id: column.parent.id + \"_\" + getUID(),\n              headers: [column]\n            }, additionalHeaderProperties(column));\n          } else {\n            // If other columns have parents, we'll need to add a place holder if necessary\n            var originalId = column.id + \"_placeholder\";\n            newParent = decorateColumn(_extends({\n              originalId: originalId,\n              id: column.id + \"_placeholder_\" + getUID(),\n              placeholderOf: column,\n              headers: [column]\n            }, additionalHeaderProperties(column)), defaultColumn);\n          } // If the resulting parent columns are the same, just add\n          // the column and increment the header span\n\n\n          if (latestParentColumn && latestParentColumn.originalId === newParent.originalId) {\n            latestParentColumn.headers.push(column);\n          } else {\n            parentColumns.push(newParent);\n          }\n        }\n\n        headerGroup.headers.push(column);\n      });\n      headerGroups.push(headerGroup); // Start scanning the parent columns\n\n      scanColumns = parentColumns;\n    };\n\n    while (scanColumns.length) {\n      _loop();\n    }\n\n    return headerGroups.reverse();\n  }\n  var pathObjCache = new Map();\n  function getBy(obj, path, def) {\n    if (!path) {\n      return obj;\n    }\n\n    var cacheKey = typeof path === 'function' ? path : JSON.stringify(path);\n\n    var pathObj = pathObjCache.get(cacheKey) || function () {\n      var pathObj = makePathArray(path);\n      pathObjCache.set(cacheKey, pathObj);\n      return pathObj;\n    }();\n\n    var val;\n\n    try {\n      val = pathObj.reduce(function (cursor, pathPart) {\n        return cursor[pathPart];\n      }, obj);\n    } catch (e) {// continue regardless of error\n    }\n\n    return typeof val !== 'undefined' ? val : def;\n  }\n  function getFirstDefined() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    for (var i = 0; i < args.length; i += 1) {\n      if (typeof args[i] !== 'undefined') {\n        return args[i];\n      }\n    }\n  }\n  function isFunction(a) {\n    if (typeof a === 'function') {\n      return a;\n    }\n  }\n  function flattenBy(arr, key) {\n    var flat = [];\n\n    var recurse = function recurse(arr) {\n      arr.forEach(function (d) {\n        if (!d[key]) {\n          flat.push(d);\n        } else {\n          recurse(d[key]);\n        }\n      });\n    };\n\n    recurse(arr);\n    return flat;\n  }\n  function expandRows(rows, _ref) {\n    var manualExpandedKey = _ref.manualExpandedKey,\n        expanded = _ref.expanded,\n        _ref$expandSubRows = _ref.expandSubRows,\n        expandSubRows = _ref$expandSubRows === void 0 ? true : _ref$expandSubRows;\n    var expandedRows = [];\n\n    var handleRow = function handleRow(row, addToExpandedRows) {\n      if (addToExpandedRows === void 0) {\n        addToExpandedRows = true;\n      }\n\n      row.isExpanded = row.original && row.original[manualExpandedKey] || expanded[row.id];\n      row.canExpand = row.subRows && !!row.subRows.length;\n\n      if (addToExpandedRows) {\n        expandedRows.push(row);\n      }\n\n      if (row.subRows && row.subRows.length && row.isExpanded) {\n        row.subRows.forEach(function (row) {\n          return handleRow(row, expandSubRows);\n        });\n      }\n    };\n\n    rows.forEach(function (row) {\n      return handleRow(row);\n    });\n    return expandedRows;\n  }\n  function getFilterMethod(filter, userFilterTypes, filterTypes) {\n    return isFunction(filter) || userFilterTypes[filter] || filterTypes[filter] || filterTypes.text;\n  }\n  function shouldAutoRemoveFilter(autoRemove, value, column) {\n    return autoRemove ? autoRemove(value, column) : typeof value === 'undefined';\n  }\n  function unpreparedAccessWarning() {\n    throw new Error('React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.');\n  }\n  var passiveSupported = null;\n  function passiveEventSupported() {\n    // memoize support to avoid adding multiple test events\n    if (typeof passiveSupported === 'boolean') return passiveSupported;\n    var supported = false;\n\n    try {\n      var options = {\n        get passive() {\n          supported = true;\n          return false;\n        }\n\n      };\n      window.addEventListener('test', null, options);\n      window.removeEventListener('test', null, options);\n    } catch (err) {\n      supported = false;\n    }\n\n    passiveSupported = supported;\n    return passiveSupported;\n  } //\n\n  var reOpenBracket = /\\[/g;\n  var reCloseBracket = /\\]/g;\n\n  function makePathArray(obj) {\n    return flattenDeep(obj) // remove all periods in parts\n    .map(function (d) {\n      return String(d).replace('.', '_');\n    }) // join parts using period\n    .join('.') // replace brackets with periods\n    .replace(reOpenBracket, '.').replace(reCloseBracket, '') // split it back out on periods\n    .split('.');\n  }\n\n  function flattenDeep(arr, newArr) {\n    if (newArr === void 0) {\n      newArr = [];\n    }\n\n    if (!Array.isArray(arr)) {\n      newArr.push(arr);\n    } else {\n      for (var i = 0; i < arr.length; i += 1) {\n        flattenDeep(arr[i], newArr);\n      }\n    }\n\n    return newArr;\n  }\n\n  var defaultGetTableProps = function defaultGetTableProps(props) {\n    return _extends({\n      role: 'table'\n    }, props);\n  };\n\n  var defaultGetTableBodyProps = function defaultGetTableBodyProps(props) {\n    return _extends({\n      role: 'rowgroup'\n    }, props);\n  };\n\n  var defaultGetHeaderProps = function defaultGetHeaderProps(props, _ref) {\n    var column = _ref.column;\n    return _extends({\n      key: \"header_\" + column.id,\n      colSpan: column.totalVisibleHeaderCount,\n      role: 'columnheader'\n    }, props);\n  };\n\n  var defaultGetFooterProps = function defaultGetFooterProps(props, _ref2) {\n    var column = _ref2.column;\n    return _extends({\n      key: \"footer_\" + column.id,\n      colSpan: column.totalVisibleHeaderCount\n    }, props);\n  };\n\n  var defaultGetHeaderGroupProps = function defaultGetHeaderGroupProps(props, _ref3) {\n    var index = _ref3.index;\n    return _extends({\n      key: \"headerGroup_\" + index,\n      role: 'row'\n    }, props);\n  };\n\n  var defaultGetFooterGroupProps = function defaultGetFooterGroupProps(props, _ref4) {\n    var index = _ref4.index;\n    return _extends({\n      key: \"footerGroup_\" + index\n    }, props);\n  };\n\n  var defaultGetRowProps = function defaultGetRowProps(props, _ref5) {\n    var row = _ref5.row;\n    return _extends({\n      key: \"row_\" + row.id,\n      role: 'row'\n    }, props);\n  };\n\n  var defaultGetCellProps = function defaultGetCellProps(props, _ref6) {\n    var cell = _ref6.cell;\n    return _extends({\n      key: \"cell_\" + cell.row.id + \"_\" + cell.column.id,\n      role: 'cell'\n    }, props);\n  };\n\n  function makeDefaultPluginHooks() {\n    return {\n      useOptions: [],\n      stateReducers: [],\n      useControlledState: [],\n      columns: [],\n      columnsDeps: [],\n      allColumns: [],\n      allColumnsDeps: [],\n      accessValue: [],\n      materializedColumns: [],\n      materializedColumnsDeps: [],\n      useInstanceAfterData: [],\n      visibleColumns: [],\n      visibleColumnsDeps: [],\n      headerGroups: [],\n      headerGroupsDeps: [],\n      useInstanceBeforeDimensions: [],\n      useInstance: [],\n      prepareRow: [],\n      getTableProps: [defaultGetTableProps],\n      getTableBodyProps: [defaultGetTableBodyProps],\n      getHeaderGroupProps: [defaultGetHeaderGroupProps],\n      getFooterGroupProps: [defaultGetFooterGroupProps],\n      getHeaderProps: [defaultGetHeaderProps],\n      getFooterProps: [defaultGetFooterProps],\n      getRowProps: [defaultGetRowProps],\n      getCellProps: [defaultGetCellProps],\n      useFinalInstance: []\n    };\n  }\n\n  actions.resetHiddenColumns = 'resetHiddenColumns';\n  actions.toggleHideColumn = 'toggleHideColumn';\n  actions.setHiddenColumns = 'setHiddenColumns';\n  actions.toggleHideAllColumns = 'toggleHideAllColumns';\n  var useColumnVisibility = function useColumnVisibility(hooks) {\n    hooks.getToggleHiddenProps = [defaultGetToggleHiddenProps];\n    hooks.getToggleHideAllColumnsProps = [defaultGetToggleHideAllColumnsProps];\n    hooks.stateReducers.push(reducer);\n    hooks.useInstanceBeforeDimensions.push(useInstanceBeforeDimensions);\n    hooks.headerGroupsDeps.push(function (deps, _ref) {\n      var instance = _ref.instance;\n      return [].concat(deps, [instance.state.hiddenColumns]);\n    });\n    hooks.useInstance.push(useInstance);\n  };\n  useColumnVisibility.pluginName = 'useColumnVisibility';\n\n  var defaultGetToggleHiddenProps = function defaultGetToggleHiddenProps(props, _ref2) {\n    var column = _ref2.column;\n    return [props, {\n      onChange: function onChange(e) {\n        column.toggleHidden(!e.target.checked);\n      },\n      style: {\n        cursor: 'pointer'\n      },\n      checked: column.isVisible,\n      title: 'Toggle Column Visible'\n    }];\n  };\n\n  var defaultGetToggleHideAllColumnsProps = function defaultGetToggleHideAllColumnsProps(props, _ref3) {\n    var instance = _ref3.instance;\n    return [props, {\n      onChange: function onChange(e) {\n        instance.toggleHideAllColumns(!e.target.checked);\n      },\n      style: {\n        cursor: 'pointer'\n      },\n      checked: !instance.allColumnsHidden && !instance.state.hiddenColumns.length,\n      title: 'Toggle All Columns Hidden',\n      indeterminate: !instance.allColumnsHidden && instance.state.hiddenColumns.length\n    }];\n  };\n\n  function reducer(state, action, previousState, instance) {\n    if (action.type === actions.init) {\n      return _extends({\n        hiddenColumns: []\n      }, state);\n    }\n\n    if (action.type === actions.resetHiddenColumns) {\n      return _extends({}, state, {\n        hiddenColumns: instance.initialState.hiddenColumns || []\n      });\n    }\n\n    if (action.type === actions.toggleHideColumn) {\n      var should = typeof action.value !== 'undefined' ? action.value : !state.hiddenColumns.includes(action.columnId);\n      var hiddenColumns = should ? [].concat(state.hiddenColumns, [action.columnId]) : state.hiddenColumns.filter(function (d) {\n        return d !== action.columnId;\n      });\n      return _extends({}, state, {\n        hiddenColumns: hiddenColumns\n      });\n    }\n\n    if (action.type === actions.setHiddenColumns) {\n      return _extends({}, state, {\n        hiddenColumns: functionalUpdate(action.value, state.hiddenColumns)\n      });\n    }\n\n    if (action.type === actions.toggleHideAllColumns) {\n      var shouldAll = typeof action.value !== 'undefined' ? action.value : !state.hiddenColumns.length;\n      return _extends({}, state, {\n        hiddenColumns: shouldAll ? instance.allColumns.map(function (d) {\n          return d.id;\n        }) : []\n      });\n    }\n  }\n\n  function useInstanceBeforeDimensions(instance) {\n    var headers = instance.headers,\n        hiddenColumns = instance.state.hiddenColumns;\n    var isMountedRef = React.useRef(false);\n\n    if (!isMountedRef.current) ;\n\n    var handleColumn = function handleColumn(column, parentVisible) {\n      column.isVisible = parentVisible && !hiddenColumns.includes(column.id);\n      var totalVisibleHeaderCount = 0;\n\n      if (column.headers && column.headers.length) {\n        column.headers.forEach(function (subColumn) {\n          return totalVisibleHeaderCount += handleColumn(subColumn, column.isVisible);\n        });\n      } else {\n        totalVisibleHeaderCount = column.isVisible ? 1 : 0;\n      }\n\n      column.totalVisibleHeaderCount = totalVisibleHeaderCount;\n      return totalVisibleHeaderCount;\n    };\n\n    var totalVisibleHeaderCount = 0;\n    headers.forEach(function (subHeader) {\n      return totalVisibleHeaderCount += handleColumn(subHeader, true);\n    });\n  }\n\n  function useInstance(instance) {\n    var columns = instance.columns,\n        flatHeaders = instance.flatHeaders,\n        dispatch = instance.dispatch,\n        allColumns = instance.allColumns,\n        getHooks = instance.getHooks,\n        hiddenColumns = instance.state.hiddenColumns,\n        _instance$autoResetHi = instance.autoResetHiddenColumns,\n        autoResetHiddenColumns = _instance$autoResetHi === void 0 ? true : _instance$autoResetHi;\n    var getInstance = useGetLatest(instance);\n    var allColumnsHidden = allColumns.length === hiddenColumns.length;\n    var toggleHideColumn = React.useCallback(function (columnId, value) {\n      return dispatch({\n        type: actions.toggleHideColumn,\n        columnId: columnId,\n        value: value\n      });\n    }, [dispatch]);\n    var setHiddenColumns = React.useCallback(function (value) {\n      return dispatch({\n        type: actions.setHiddenColumns,\n        value: value\n      });\n    }, [dispatch]);\n    var toggleHideAllColumns = React.useCallback(function (value) {\n      return dispatch({\n        type: actions.toggleHideAllColumns,\n        value: value\n      });\n    }, [dispatch]);\n    var getToggleHideAllColumnsProps = makePropGetter(getHooks().getToggleHideAllColumnsProps, {\n      instance: getInstance()\n    });\n    flatHeaders.forEach(function (column) {\n      column.toggleHidden = function (value) {\n        dispatch({\n          type: actions.toggleHideColumn,\n          columnId: column.id,\n          value: value\n        });\n      };\n\n      column.getToggleHiddenProps = makePropGetter(getHooks().getToggleHiddenProps, {\n        instance: getInstance(),\n        column: column\n      });\n    });\n    var getAutoResetHiddenColumns = useGetLatest(autoResetHiddenColumns);\n    useMountedLayoutEffect(function () {\n      if (getAutoResetHiddenColumns()) {\n        dispatch({\n          type: actions.resetHiddenColumns\n        });\n      }\n    }, [dispatch, columns]);\n    Object.assign(instance, {\n      allColumnsHidden: allColumnsHidden,\n      toggleHideColumn: toggleHideColumn,\n      setHiddenColumns: setHiddenColumns,\n      toggleHideAllColumns: toggleHideAllColumns,\n      getToggleHideAllColumnsProps: getToggleHideAllColumnsProps\n    });\n  }\n\n  var defaultInitialState = {};\n  var defaultColumnInstance = {};\n\n  var defaultReducer = function defaultReducer(state, action, prevState) {\n    return state;\n  };\n\n  var defaultGetSubRows = function defaultGetSubRows(row, index) {\n    return row.subRows || [];\n  };\n\n  var defaultGetRowId = function defaultGetRowId(row, index, parent) {\n    return \"\" + (parent ? [parent.id, index].join('.') : index);\n  };\n\n  var defaultUseControlledState = function defaultUseControlledState(d) {\n    return d;\n  };\n\n  function applyDefaults(props) {\n    var _props$initialState = props.initialState,\n        initialState = _props$initialState === void 0 ? defaultInitialState : _props$initialState,\n        _props$defaultColumn = props.defaultColumn,\n        defaultColumn = _props$defaultColumn === void 0 ? defaultColumnInstance : _props$defaultColumn,\n        _props$getSubRows = props.getSubRows,\n        getSubRows = _props$getSubRows === void 0 ? defaultGetSubRows : _props$getSubRows,\n        _props$getRowId = props.getRowId,\n        getRowId = _props$getRowId === void 0 ? defaultGetRowId : _props$getRowId,\n        _props$stateReducer = props.stateReducer,\n        stateReducer = _props$stateReducer === void 0 ? defaultReducer : _props$stateReducer,\n        _props$useControlledS = props.useControlledState,\n        useControlledState = _props$useControlledS === void 0 ? defaultUseControlledState : _props$useControlledS,\n        rest = _objectWithoutPropertiesLoose(props, [\"initialState\", \"defaultColumn\", \"getSubRows\", \"getRowId\", \"stateReducer\", \"useControlledState\"]);\n\n    return _extends({}, rest, {\n      initialState: initialState,\n      defaultColumn: defaultColumn,\n      getSubRows: getSubRows,\n      getRowId: getRowId,\n      stateReducer: stateReducer,\n      useControlledState: useControlledState\n    });\n  }\n\n  var useTable = function useTable(props) {\n    for (var _len = arguments.length, plugins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      plugins[_key - 1] = arguments[_key];\n    }\n\n    // Apply default props\n    props = applyDefaults(props); // Add core plugins\n\n    plugins = [useColumnVisibility].concat(plugins); // Create the table instance\n\n    var instanceRef = React.useRef({}); // Create a getter for the instance (helps avoid a lot of potential memory leaks)\n\n    var getInstance = useGetLatest(instanceRef.current); // Assign the props, plugins and hooks to the instance\n\n    Object.assign(getInstance(), _extends({}, props, {\n      plugins: plugins,\n      hooks: makeDefaultPluginHooks()\n    })); // Allow plugins to register hooks as early as possible\n\n    plugins.filter(Boolean).forEach(function (plugin) {\n      plugin(getInstance().hooks);\n    }); // Consume all hooks and make a getter for them\n\n    var getHooks = useGetLatest(getInstance().hooks);\n    getInstance().getHooks = getHooks;\n    delete getInstance().hooks; // Allow useOptions hooks to modify the options coming into the table\n\n    Object.assign(getInstance(), reduceHooks(getHooks().useOptions, applyDefaults(props)));\n\n    var _getInstance = getInstance(),\n        data = _getInstance.data,\n        userColumns = _getInstance.columns,\n        initialState = _getInstance.initialState,\n        defaultColumn = _getInstance.defaultColumn,\n        getSubRows = _getInstance.getSubRows,\n        getRowId = _getInstance.getRowId,\n        stateReducer = _getInstance.stateReducer,\n        useControlledState = _getInstance.useControlledState; // Setup user reducer ref\n\n\n    var getStateReducer = useGetLatest(stateReducer); // Build the reducer\n\n    var reducer = React.useCallback(function (state, action) {\n      // Detect invalid actions\n      if (!action.type) {\n        console.info({\n          action: action\n        });\n        throw new Error('Unknown Action 👆');\n      } // Reduce the state from all plugin reducers\n\n\n      return [].concat(getHooks().stateReducers, Array.isArray(getStateReducer()) ? getStateReducer() : [getStateReducer()]).reduce(function (s, handler) {\n        return handler(s, action, state, getInstance()) || s;\n      }, state);\n    }, [getHooks, getStateReducer, getInstance]); // Start the reducer\n\n    var _React$useReducer = React.useReducer(reducer, undefined, function () {\n      return reducer(initialState, {\n        type: actions.init\n      });\n    }),\n        reducerState = _React$useReducer[0],\n        dispatch = _React$useReducer[1]; // Allow the user to control the final state with hooks\n\n\n    var state = reduceHooks([].concat(getHooks().useControlledState, [useControlledState]), reducerState, {\n      instance: getInstance()\n    });\n    Object.assign(getInstance(), {\n      state: state,\n      dispatch: dispatch\n    }); // Decorate All the columns\n\n    var columns = React.useMemo(function () {\n      return linkColumnStructure(reduceHooks(getHooks().columns, userColumns, {\n        instance: getInstance()\n      }));\n    }, [getHooks, getInstance, userColumns].concat(reduceHooks(getHooks().columnsDeps, [], {\n      instance: getInstance()\n    })));\n    getInstance().columns = columns; // Get the flat list of all columns and allow hooks to decorate\n    // those columns (and trigger this memoization via deps)\n\n    var allColumns = React.useMemo(function () {\n      return reduceHooks(getHooks().allColumns, flattenColumns(columns), {\n        instance: getInstance()\n      }).map(assignColumnAccessor);\n    }, [columns, getHooks, getInstance].concat(reduceHooks(getHooks().allColumnsDeps, [], {\n      instance: getInstance()\n    })));\n    getInstance().allColumns = allColumns; // Access the row model using initial columns\n\n    var _React$useMemo = React.useMemo(function () {\n      var rows = [];\n      var flatRows = [];\n      var rowsById = {};\n      var allColumnsQueue = [].concat(allColumns);\n\n      while (allColumnsQueue.length) {\n        var column = allColumnsQueue.shift();\n        accessRowsForColumn({\n          data: data,\n          rows: rows,\n          flatRows: flatRows,\n          rowsById: rowsById,\n          column: column,\n          getRowId: getRowId,\n          getSubRows: getSubRows,\n          accessValueHooks: getHooks().accessValue,\n          getInstance: getInstance\n        });\n      }\n\n      return [rows, flatRows, rowsById];\n    }, [allColumns, data, getRowId, getSubRows, getHooks, getInstance]),\n        rows = _React$useMemo[0],\n        flatRows = _React$useMemo[1],\n        rowsById = _React$useMemo[2];\n\n    Object.assign(getInstance(), {\n      rows: rows,\n      initialRows: [].concat(rows),\n      flatRows: flatRows,\n      rowsById: rowsById // materializedColumns,\n\n    });\n    loopHooks(getHooks().useInstanceAfterData, getInstance()); // Get the flat list of all columns AFTER the rows\n    // have been access, and allow hooks to decorate\n    // those columns (and trigger this memoization via deps)\n\n    var visibleColumns = React.useMemo(function () {\n      return reduceHooks(getHooks().visibleColumns, allColumns, {\n        instance: getInstance()\n      }).map(function (d) {\n        return decorateColumn(d, defaultColumn);\n      });\n    }, [getHooks, allColumns, getInstance, defaultColumn].concat(reduceHooks(getHooks().visibleColumnsDeps, [], {\n      instance: getInstance()\n    }))); // Combine new visible columns with all columns\n\n    allColumns = React.useMemo(function () {\n      var columns = [].concat(visibleColumns);\n      allColumns.forEach(function (column) {\n        if (!columns.find(function (d) {\n          return d.id === column.id;\n        })) {\n          columns.push(column);\n        }\n      });\n      return columns;\n    }, [allColumns, visibleColumns]);\n    getInstance().allColumns = allColumns;\n\n    {\n      var duplicateColumns = allColumns.filter(function (column, i) {\n        return allColumns.findIndex(function (d) {\n          return d.id === column.id;\n        }) !== i;\n      });\n\n      if (duplicateColumns.length) {\n        console.info(allColumns);\n        throw new Error(\"Duplicate columns were found with ids: \\\"\" + duplicateColumns.map(function (d) {\n          return d.id;\n        }).join(', ') + \"\\\" in the columns array above\");\n      }\n    } // Make the headerGroups\n\n\n    var headerGroups = React.useMemo(function () {\n      return reduceHooks(getHooks().headerGroups, makeHeaderGroups(visibleColumns, defaultColumn), getInstance());\n    }, [getHooks, visibleColumns, defaultColumn, getInstance].concat(reduceHooks(getHooks().headerGroupsDeps, [], {\n      instance: getInstance()\n    })));\n    getInstance().headerGroups = headerGroups; // Get the first level of headers\n\n    var headers = React.useMemo(function () {\n      return headerGroups.length ? headerGroups[0].headers : [];\n    }, [headerGroups]);\n    getInstance().headers = headers; // Provide a flat header list for utilities\n\n    getInstance().flatHeaders = headerGroups.reduce(function (all, headerGroup) {\n      return [].concat(all, headerGroup.headers);\n    }, []);\n    loopHooks(getHooks().useInstanceBeforeDimensions, getInstance()); // Filter columns down to visible ones\n\n    var visibleColumnsDep = visibleColumns.filter(function (d) {\n      return d.isVisible;\n    }).map(function (d) {\n      return d.id;\n    }).sort().join('_');\n    visibleColumns = React.useMemo(function () {\n      return visibleColumns.filter(function (d) {\n        return d.isVisible;\n      });\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [visibleColumns, visibleColumnsDep]);\n    getInstance().visibleColumns = visibleColumns; // Header Visibility is needed by this point\n\n    var _calculateHeaderWidth = calculateHeaderWidths(headers),\n        totalColumnsMinWidth = _calculateHeaderWidth[0],\n        totalColumnsWidth = _calculateHeaderWidth[1],\n        totalColumnsMaxWidth = _calculateHeaderWidth[2];\n\n    getInstance().totalColumnsMinWidth = totalColumnsMinWidth;\n    getInstance().totalColumnsWidth = totalColumnsWidth;\n    getInstance().totalColumnsMaxWidth = totalColumnsMaxWidth;\n    loopHooks(getHooks().useInstance, getInstance()) // Each materialized header needs to be assigned a render function and other\n    // prop getter properties here.\n    ;\n    [].concat(getInstance().flatHeaders, getInstance().allColumns).forEach(function (column) {\n      // Give columns/headers rendering power\n      column.render = makeRenderer(getInstance(), column); // Give columns/headers a default getHeaderProps\n\n      column.getHeaderProps = makePropGetter(getHooks().getHeaderProps, {\n        instance: getInstance(),\n        column: column\n      }); // Give columns/headers a default getFooterProps\n\n      column.getFooterProps = makePropGetter(getHooks().getFooterProps, {\n        instance: getInstance(),\n        column: column\n      });\n    });\n    getInstance().headerGroups = React.useMemo(function () {\n      return headerGroups.filter(function (headerGroup, i) {\n        // Filter out any headers and headerGroups that don't have visible columns\n        headerGroup.headers = headerGroup.headers.filter(function (column) {\n          var recurse = function recurse(headers) {\n            return headers.filter(function (column) {\n              if (column.headers) {\n                return recurse(column.headers);\n              }\n\n              return column.isVisible;\n            }).length;\n          };\n\n          if (column.headers) {\n            return recurse(column.headers);\n          }\n\n          return column.isVisible;\n        }); // Give headerGroups getRowProps\n\n        if (headerGroup.headers.length) {\n          headerGroup.getHeaderGroupProps = makePropGetter(getHooks().getHeaderGroupProps, {\n            instance: getInstance(),\n            headerGroup: headerGroup,\n            index: i\n          });\n          headerGroup.getFooterGroupProps = makePropGetter(getHooks().getFooterGroupProps, {\n            instance: getInstance(),\n            headerGroup: headerGroup,\n            index: i\n          });\n          return true;\n        }\n\n        return false;\n      });\n    }, [headerGroups, getInstance, getHooks]);\n    getInstance().footerGroups = [].concat(getInstance().headerGroups).reverse(); // The prepareRow function is absolutely necessary and MUST be called on\n    // any rows the user wishes to be displayed.\n\n    getInstance().prepareRow = React.useCallback(function (row) {\n      row.getRowProps = makePropGetter(getHooks().getRowProps, {\n        instance: getInstance(),\n        row: row\n      }); // Build the visible cells for each row\n\n      row.allCells = allColumns.map(function (column) {\n        var value = row.values[column.id];\n        var cell = {\n          column: column,\n          row: row,\n          value: value\n        }; // Give each cell a getCellProps base\n\n        cell.getCellProps = makePropGetter(getHooks().getCellProps, {\n          instance: getInstance(),\n          cell: cell\n        }); // Give each cell a renderer function (supports multiple renderers)\n\n        cell.render = makeRenderer(getInstance(), column, {\n          row: row,\n          cell: cell,\n          value: value\n        });\n        return cell;\n      });\n      row.cells = visibleColumns.map(function (column) {\n        return row.allCells.find(function (cell) {\n          return cell.column.id === column.id;\n        });\n      }); // need to apply any row specific hooks (useExpanded requires this)\n\n      loopHooks(getHooks().prepareRow, row, {\n        instance: getInstance()\n      });\n    }, [getHooks, getInstance, allColumns, visibleColumns]);\n    getInstance().getTableProps = makePropGetter(getHooks().getTableProps, {\n      instance: getInstance()\n    });\n    getInstance().getTableBodyProps = makePropGetter(getHooks().getTableBodyProps, {\n      instance: getInstance()\n    });\n    loopHooks(getHooks().useFinalInstance, getInstance());\n    return getInstance();\n  };\n\n  function calculateHeaderWidths(headers, left) {\n    if (left === void 0) {\n      left = 0;\n    }\n\n    var sumTotalMinWidth = 0;\n    var sumTotalWidth = 0;\n    var sumTotalMaxWidth = 0;\n    var sumTotalFlexWidth = 0;\n    headers.forEach(function (header) {\n      var subHeaders = header.headers;\n      header.totalLeft = left;\n\n      if (subHeaders && subHeaders.length) {\n        var _calculateHeaderWidth2 = calculateHeaderWidths(subHeaders, left),\n            totalMinWidth = _calculateHeaderWidth2[0],\n            totalWidth = _calculateHeaderWidth2[1],\n            totalMaxWidth = _calculateHeaderWidth2[2],\n            totalFlexWidth = _calculateHeaderWidth2[3];\n\n        header.totalMinWidth = totalMinWidth;\n        header.totalWidth = totalWidth;\n        header.totalMaxWidth = totalMaxWidth;\n        header.totalFlexWidth = totalFlexWidth;\n      } else {\n        header.totalMinWidth = header.minWidth;\n        header.totalWidth = Math.min(Math.max(header.minWidth, header.width), header.maxWidth);\n        header.totalMaxWidth = header.maxWidth;\n        header.totalFlexWidth = header.canResize ? header.totalWidth : 0;\n      }\n\n      if (header.isVisible) {\n        left += header.totalWidth;\n        sumTotalMinWidth += header.totalMinWidth;\n        sumTotalWidth += header.totalWidth;\n        sumTotalMaxWidth += header.totalMaxWidth;\n        sumTotalFlexWidth += header.totalFlexWidth;\n      }\n    });\n    return [sumTotalMinWidth, sumTotalWidth, sumTotalMaxWidth, sumTotalFlexWidth];\n  }\n\n  function accessRowsForColumn(_ref) {\n    var data = _ref.data,\n        rows = _ref.rows,\n        flatRows = _ref.flatRows,\n        rowsById = _ref.rowsById,\n        column = _ref.column,\n        getRowId = _ref.getRowId,\n        getSubRows = _ref.getSubRows,\n        accessValueHooks = _ref.accessValueHooks,\n        getInstance = _ref.getInstance;\n\n    // Access the row's data column-by-column\n    // We do it this way so we can incrementally add materialized\n    // columns after the first pass and avoid excessive looping\n    var accessRow = function accessRow(originalRow, rowIndex, depth, parent, parentRows) {\n      if (depth === void 0) {\n        depth = 0;\n      }\n\n      // Keep the original reference around\n      var original = originalRow;\n      var id = getRowId(originalRow, rowIndex, parent);\n      var row = rowsById[id]; // If the row hasn't been created, let's make it\n\n      if (!row) {\n        row = {\n          id: id,\n          original: original,\n          index: rowIndex,\n          depth: depth,\n          cells: [{}] // This is a dummy cell\n\n        }; // Override common array functions (and the dummy cell's getCellProps function)\n        // to show an error if it is accessed without calling prepareRow\n\n        row.cells.map = unpreparedAccessWarning;\n        row.cells.filter = unpreparedAccessWarning;\n        row.cells.forEach = unpreparedAccessWarning;\n        row.cells[0].getCellProps = unpreparedAccessWarning; // Create the cells and values\n\n        row.values = {}; // Push this row into the parentRows array\n\n        parentRows.push(row); // Keep track of every row in a flat array\n\n        flatRows.push(row); // Also keep track of every row by its ID\n\n        rowsById[id] = row; // Get the original subrows\n\n        row.originalSubRows = getSubRows(originalRow, rowIndex); // Then recursively access them\n\n        if (row.originalSubRows) {\n          var subRows = [];\n          row.originalSubRows.forEach(function (d, i) {\n            return accessRow(d, i, depth + 1, row, subRows);\n          }); // Keep the new subRows array on the row\n\n          row.subRows = subRows;\n        }\n      } else if (row.subRows) {\n        // If the row exists, then it's already been accessed\n        // Keep recursing, but don't worry about passing the\n        // accumlator array (those rows already exist)\n        row.originalSubRows.forEach(function (d, i) {\n          return accessRow(d, i, depth + 1, row);\n        });\n      } // If the column has an accessor, use it to get a value\n\n\n      if (column.accessor) {\n        row.values[column.id] = column.accessor(originalRow, rowIndex, row, parentRows, data);\n      } // Allow plugins to manipulate the column value\n\n\n      row.values[column.id] = reduceHooks(accessValueHooks, row.values[column.id], {\n        row: row,\n        column: column,\n        instance: getInstance()\n      }, true);\n    };\n\n    data.forEach(function (originalRow, rowIndex) {\n      return accessRow(originalRow, rowIndex, 0, undefined, rows);\n    });\n  }\n\n  actions.resetExpanded = 'resetExpanded';\n  actions.toggleRowExpanded = 'toggleRowExpanded';\n  actions.toggleAllRowsExpanded = 'toggleAllRowsExpanded';\n  var useExpanded = function useExpanded(hooks) {\n    hooks.getToggleAllRowsExpandedProps = [defaultGetToggleAllRowsExpandedProps];\n    hooks.getToggleRowExpandedProps = [defaultGetToggleRowExpandedProps];\n    hooks.stateReducers.push(reducer$1);\n    hooks.useInstance.push(useInstance$1);\n    hooks.prepareRow.push(prepareRow);\n  };\n  useExpanded.pluginName = 'useExpanded';\n\n  var defaultGetToggleAllRowsExpandedProps = function defaultGetToggleAllRowsExpandedProps(props, _ref) {\n    var instance = _ref.instance;\n    return [props, {\n      onClick: function onClick(e) {\n        instance.toggleAllRowsExpanded();\n      },\n      style: {\n        cursor: 'pointer'\n      },\n      title: 'Toggle All Rows Expanded'\n    }];\n  };\n\n  var defaultGetToggleRowExpandedProps = function defaultGetToggleRowExpandedProps(props, _ref2) {\n    var row = _ref2.row;\n    return [props, {\n      onClick: function onClick() {\n        row.toggleRowExpanded();\n      },\n      style: {\n        cursor: 'pointer'\n      },\n      title: 'Toggle Row Expanded'\n    }];\n  }; // Reducer\n\n\n  function reducer$1(state, action, previousState, instance) {\n    if (action.type === actions.init) {\n      return _extends({\n        expanded: {}\n      }, state);\n    }\n\n    if (action.type === actions.resetExpanded) {\n      return _extends({}, state, {\n        expanded: instance.initialState.expanded || {}\n      });\n    }\n\n    if (action.type === actions.toggleAllRowsExpanded) {\n      var value = action.value;\n      var rowsById = instance.rowsById;\n      var isAllRowsExpanded = Object.keys(rowsById).length === Object.keys(state.expanded).length;\n      var expandAll = typeof value !== 'undefined' ? value : !isAllRowsExpanded;\n\n      if (expandAll) {\n        var expanded = {};\n        Object.keys(rowsById).forEach(function (rowId) {\n          expanded[rowId] = true;\n        });\n        return _extends({}, state, {\n          expanded: expanded\n        });\n      }\n\n      return _extends({}, state, {\n        expanded: {}\n      });\n    }\n\n    if (action.type === actions.toggleRowExpanded) {\n      var id = action.id,\n          setExpanded = action.value;\n      var exists = state.expanded[id];\n      var shouldExist = typeof setExpanded !== 'undefined' ? setExpanded : !exists;\n\n      if (!exists && shouldExist) {\n        var _extends2;\n\n        return _extends({}, state, {\n          expanded: _extends({}, state.expanded, (_extends2 = {}, _extends2[id] = true, _extends2))\n        });\n      } else if (exists && !shouldExist) {\n        var _state$expanded = state.expanded,\n            _ = _state$expanded[id],\n            rest = _objectWithoutPropertiesLoose(_state$expanded, [id].map(_toPropertyKey));\n\n        return _extends({}, state, {\n          expanded: rest\n        });\n      } else {\n        return state;\n      }\n    }\n  }\n\n  function useInstance$1(instance) {\n    var data = instance.data,\n        rows = instance.rows,\n        rowsById = instance.rowsById,\n        _instance$manualExpan = instance.manualExpandedKey,\n        manualExpandedKey = _instance$manualExpan === void 0 ? 'expanded' : _instance$manualExpan,\n        _instance$paginateExp = instance.paginateExpandedRows,\n        paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp,\n        _instance$expandSubRo = instance.expandSubRows,\n        expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo,\n        _instance$autoResetEx = instance.autoResetExpanded,\n        autoResetExpanded = _instance$autoResetEx === void 0 ? true : _instance$autoResetEx,\n        getHooks = instance.getHooks,\n        plugins = instance.plugins,\n        expanded = instance.state.expanded,\n        dispatch = instance.dispatch;\n    ensurePluginOrder(plugins, ['useSortBy', 'useGroupBy', 'usePivotColumns', 'useGlobalFilter'], 'useExpanded');\n    var getAutoResetExpanded = useGetLatest(autoResetExpanded);\n    var isAllRowsExpanded = Boolean(Object.keys(rowsById).length && Object.keys(expanded).length);\n\n    if (isAllRowsExpanded) {\n      if (Object.keys(rowsById).some(function (id) {\n        return !expanded[id];\n      })) {\n        isAllRowsExpanded = false;\n      }\n    } // Bypass any effects from firing when this changes\n\n\n    useMountedLayoutEffect(function () {\n      if (getAutoResetExpanded()) {\n        dispatch({\n          type: actions.resetExpanded\n        });\n      }\n    }, [dispatch, data]);\n    var toggleRowExpanded = React.useCallback(function (id, value) {\n      dispatch({\n        type: actions.toggleRowExpanded,\n        id: id,\n        value: value\n      });\n    }, [dispatch]);\n    var toggleAllRowsExpanded = React.useCallback(function (value) {\n      return dispatch({\n        type: actions.toggleAllRowsExpanded,\n        value: value\n      });\n    }, [dispatch]);\n    var expandedRows = React.useMemo(function () {\n      if (paginateExpandedRows) {\n        return expandRows(rows, {\n          manualExpandedKey: manualExpandedKey,\n          expanded: expanded,\n          expandSubRows: expandSubRows\n        });\n      }\n\n      return rows;\n    }, [paginateExpandedRows, rows, manualExpandedKey, expanded, expandSubRows]);\n    var expandedDepth = React.useMemo(function () {\n      return findExpandedDepth(expanded);\n    }, [expanded]);\n    var getInstance = useGetLatest(instance);\n    var getToggleAllRowsExpandedProps = makePropGetter(getHooks().getToggleAllRowsExpandedProps, {\n      instance: getInstance()\n    });\n    Object.assign(instance, {\n      preExpandedRows: rows,\n      expandedRows: expandedRows,\n      rows: expandedRows,\n      expandedDepth: expandedDepth,\n      isAllRowsExpanded: isAllRowsExpanded,\n      toggleRowExpanded: toggleRowExpanded,\n      toggleAllRowsExpanded: toggleAllRowsExpanded,\n      getToggleAllRowsExpandedProps: getToggleAllRowsExpandedProps\n    });\n  }\n\n  function prepareRow(row, _ref3) {\n    var getHooks = _ref3.instance.getHooks,\n        instance = _ref3.instance;\n\n    row.toggleRowExpanded = function (set) {\n      return instance.toggleRowExpanded(row.id, set);\n    };\n\n    row.getToggleRowExpandedProps = makePropGetter(getHooks().getToggleRowExpandedProps, {\n      instance: instance,\n      row: row\n    });\n  }\n\n  function findExpandedDepth(expanded) {\n    var maxDepth = 0;\n    Object.keys(expanded).forEach(function (id) {\n      var splitId = id.split('.');\n      maxDepth = Math.max(maxDepth, splitId.length);\n    });\n    return maxDepth;\n  }\n\n  var text = function text(rows, ids, filterValue) {\n    rows = rows.filter(function (row) {\n      return ids.some(function (id) {\n        var rowValue = row.values[id];\n        return String(rowValue).toLowerCase().includes(String(filterValue).toLowerCase());\n      });\n    });\n    return rows;\n  };\n\n  text.autoRemove = function (val) {\n    return !val;\n  };\n\n  var exactText = function exactText(rows, ids, filterValue) {\n    return rows.filter(function (row) {\n      return ids.some(function (id) {\n        var rowValue = row.values[id];\n        return rowValue !== undefined ? String(rowValue).toLowerCase() === String(filterValue).toLowerCase() : true;\n      });\n    });\n  };\n\n  exactText.autoRemove = function (val) {\n    return !val;\n  };\n\n  var exactTextCase = function exactTextCase(rows, ids, filterValue) {\n    return rows.filter(function (row) {\n      return ids.some(function (id) {\n        var rowValue = row.values[id];\n        return rowValue !== undefined ? String(rowValue) === String(filterValue) : true;\n      });\n    });\n  };\n\n  exactTextCase.autoRemove = function (val) {\n    return !val;\n  };\n\n  var includes = function includes(rows, ids, filterValue) {\n    return rows.filter(function (row) {\n      return ids.some(function (id) {\n        var rowValue = row.values[id];\n        return rowValue.includes(filterValue);\n      });\n    });\n  };\n\n  includes.autoRemove = function (val) {\n    return !val || !val.length;\n  };\n\n  var includesAll = function includesAll(rows, ids, filterValue) {\n    return rows.filter(function (row) {\n      return ids.some(function (id) {\n        var rowValue = row.values[id];\n        return rowValue && rowValue.length && filterValue.every(function (val) {\n          return rowValue.includes(val);\n        });\n      });\n    });\n  };\n\n  includesAll.autoRemove = function (val) {\n    return !val || !val.length;\n  };\n\n  var includesSome = function includesSome(rows, ids, filterValue) {\n    return rows.filter(function (row) {\n      return ids.some(function (id) {\n        var rowValue = row.values[id];\n        return rowValue && rowValue.length && filterValue.some(function (val) {\n          return rowValue.includes(val);\n        });\n      });\n    });\n  };\n\n  includesSome.autoRemove = function (val) {\n    return !val || !val.length;\n  };\n\n  var includesValue = function includesValue(rows, ids, filterValue) {\n    return rows.filter(function (row) {\n      return ids.some(function (id) {\n        var rowValue = row.values[id];\n        return filterValue.includes(rowValue);\n      });\n    });\n  };\n\n  includesValue.autoRemove = function (val) {\n    return !val || !val.length;\n  };\n\n  var exact = function exact(rows, ids, filterValue) {\n    return rows.filter(function (row) {\n      return ids.some(function (id) {\n        var rowValue = row.values[id];\n        return rowValue === filterValue;\n      });\n    });\n  };\n\n  exact.autoRemove = function (val) {\n    return typeof val === 'undefined';\n  };\n\n  var equals = function equals(rows, ids, filterValue) {\n    return rows.filter(function (row) {\n      return ids.some(function (id) {\n        var rowValue = row.values[id]; // eslint-disable-next-line eqeqeq\n\n        return rowValue == filterValue;\n      });\n    });\n  };\n\n  equals.autoRemove = function (val) {\n    return val == null;\n  };\n\n  var between = function between(rows, ids, filterValue) {\n    var _ref = filterValue || [],\n        min = _ref[0],\n        max = _ref[1];\n\n    min = typeof min === 'number' ? min : -Infinity;\n    max = typeof max === 'number' ? max : Infinity;\n\n    if (min > max) {\n      var temp = min;\n      min = max;\n      max = temp;\n    }\n\n    return rows.filter(function (row) {\n      return ids.some(function (id) {\n        var rowValue = row.values[id];\n        return rowValue >= min && rowValue <= max;\n      });\n    });\n  };\n\n  between.autoRemove = function (val) {\n    return !val || typeof val[0] !== 'number' && typeof val[1] !== 'number';\n  };\n\n  var filterTypes = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    text: text,\n    exactText: exactText,\n    exactTextCase: exactTextCase,\n    includes: includes,\n    includesAll: includesAll,\n    includesSome: includesSome,\n    includesValue: includesValue,\n    exact: exact,\n    equals: equals,\n    between: between\n  });\n\n  actions.resetFilters = 'resetFilters';\n  actions.setFilter = 'setFilter';\n  actions.setAllFilters = 'setAllFilters';\n  var useFilters = function useFilters(hooks) {\n    hooks.stateReducers.push(reducer$2);\n    hooks.useInstance.push(useInstance$2);\n  };\n  useFilters.pluginName = 'useFilters';\n\n  function reducer$2(state, action, previousState, instance) {\n    if (action.type === actions.init) {\n      return _extends({\n        filters: []\n      }, state);\n    }\n\n    if (action.type === actions.resetFilters) {\n      return _extends({}, state, {\n        filters: instance.initialState.filters || []\n      });\n    }\n\n    if (action.type === actions.setFilter) {\n      var columnId = action.columnId,\n          filterValue = action.filterValue;\n      var allColumns = instance.allColumns,\n          userFilterTypes = instance.filterTypes;\n      var column = allColumns.find(function (d) {\n        return d.id === columnId;\n      });\n\n      if (!column) {\n        throw new Error(\"React-Table: Could not find a column with id: \" + columnId);\n      }\n\n      var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n      var previousfilter = state.filters.find(function (d) {\n        return d.id === columnId;\n      });\n      var newFilter = functionalUpdate(filterValue, previousfilter && previousfilter.value); //\n\n      if (shouldAutoRemoveFilter(filterMethod.autoRemove, newFilter, column)) {\n        return _extends({}, state, {\n          filters: state.filters.filter(function (d) {\n            return d.id !== columnId;\n          })\n        });\n      }\n\n      if (previousfilter) {\n        return _extends({}, state, {\n          filters: state.filters.map(function (d) {\n            if (d.id === columnId) {\n              return {\n                id: columnId,\n                value: newFilter\n              };\n            }\n\n            return d;\n          })\n        });\n      }\n\n      return _extends({}, state, {\n        filters: [].concat(state.filters, [{\n          id: columnId,\n          value: newFilter\n        }])\n      });\n    }\n\n    if (action.type === actions.setAllFilters) {\n      var filters = action.filters;\n      var _allColumns = instance.allColumns,\n          _userFilterTypes = instance.filterTypes;\n      return _extends({}, state, {\n        // Filter out undefined values\n        filters: functionalUpdate(filters, state.filters).filter(function (filter) {\n          var column = _allColumns.find(function (d) {\n            return d.id === filter.id;\n          });\n\n          var filterMethod = getFilterMethod(column.filter, _userFilterTypes || {}, filterTypes);\n\n          if (shouldAutoRemoveFilter(filterMethod.autoRemove, filter.value, column)) {\n            return false;\n          }\n\n          return true;\n        })\n      });\n    }\n  }\n\n  function useInstance$2(instance) {\n    var data = instance.data,\n        rows = instance.rows,\n        flatRows = instance.flatRows,\n        rowsById = instance.rowsById,\n        allColumns = instance.allColumns,\n        userFilterTypes = instance.filterTypes,\n        manualFilters = instance.manualFilters,\n        _instance$defaultCanF = instance.defaultCanFilter,\n        defaultCanFilter = _instance$defaultCanF === void 0 ? false : _instance$defaultCanF,\n        disableFilters = instance.disableFilters,\n        filters = instance.state.filters,\n        dispatch = instance.dispatch,\n        _instance$autoResetFi = instance.autoResetFilters,\n        autoResetFilters = _instance$autoResetFi === void 0 ? true : _instance$autoResetFi;\n    var setFilter = React.useCallback(function (columnId, filterValue) {\n      dispatch({\n        type: actions.setFilter,\n        columnId: columnId,\n        filterValue: filterValue\n      });\n    }, [dispatch]);\n    var setAllFilters = React.useCallback(function (filters) {\n      dispatch({\n        type: actions.setAllFilters,\n        filters: filters\n      });\n    }, [dispatch]);\n    allColumns.forEach(function (column) {\n      var id = column.id,\n          accessor = column.accessor,\n          columnDefaultCanFilter = column.defaultCanFilter,\n          columnDisableFilters = column.disableFilters; // Determine if a column is filterable\n\n      column.canFilter = accessor ? getFirstDefined(columnDisableFilters === true ? false : undefined, disableFilters === true ? false : undefined, true) : getFirstDefined(columnDefaultCanFilter, defaultCanFilter, false); // Provide the column a way of updating the filter value\n\n      column.setFilter = function (val) {\n        return setFilter(column.id, val);\n      }; // Provide the current filter value to the column for\n      // convenience\n\n\n      var found = filters.find(function (d) {\n        return d.id === id;\n      });\n      column.filterValue = found && found.value;\n    });\n\n    var _React$useMemo = React.useMemo(function () {\n      if (manualFilters || !filters.length) {\n        return [rows, flatRows, rowsById];\n      }\n\n      var filteredFlatRows = [];\n      var filteredRowsById = {}; // Filters top level and nested rows\n\n      var filterRows = function filterRows(rows, depth) {\n        if (depth === void 0) {\n          depth = 0;\n        }\n\n        var filteredRows = rows;\n        filteredRows = filters.reduce(function (filteredSoFar, _ref) {\n          var columnId = _ref.id,\n              filterValue = _ref.value;\n          // Find the filters column\n          var column = allColumns.find(function (d) {\n            return d.id === columnId;\n          });\n\n          if (!column) {\n            return filteredSoFar;\n          }\n\n          if (depth === 0) {\n            column.preFilteredRows = filteredSoFar;\n          }\n\n          var filterMethod = getFilterMethod(column.filter, userFilterTypes || {}, filterTypes);\n\n          if (!filterMethod) {\n            console.warn(\"Could not find a valid 'column.filter' for column with the ID: \" + column.id + \".\");\n            return filteredSoFar;\n          } // Pass the rows, id, filterValue and column to the filterMethod\n          // to get the filtered rows back\n\n\n          column.filteredRows = filterMethod(filteredSoFar, [columnId], filterValue);\n          return column.filteredRows;\n        }, rows); // Apply the filter to any subRows\n        // We technically could do this recursively in the above loop,\n        // but that would severely hinder the API for the user, since they\n        // would be required to do that recursion in some scenarios\n\n        filteredRows.forEach(function (row) {\n          filteredFlatRows.push(row);\n          filteredRowsById[row.id] = row;\n\n          if (!row.subRows) {\n            return;\n          }\n\n          row.subRows = row.subRows && row.subRows.length > 0 ? filterRows(row.subRows, depth + 1) : row.subRows;\n        });\n        return filteredRows;\n      };\n\n      return [filterRows(rows), filteredFlatRows, filteredRowsById];\n    }, [manualFilters, filters, rows, flatRows, rowsById, allColumns, userFilterTypes]),\n        filteredRows = _React$useMemo[0],\n        filteredFlatRows = _React$useMemo[1],\n        filteredRowsById = _React$useMemo[2];\n\n    React.useMemo(function () {\n      // Now that each filtered column has it's partially filtered rows,\n      // lets assign the final filtered rows to all of the other columns\n      var nonFilteredColumns = allColumns.filter(function (column) {\n        return !filters.find(function (d) {\n          return d.id === column.id;\n        });\n      }); // This essentially enables faceted filter options to be built easily\n      // using every column's preFilteredRows value\n\n      nonFilteredColumns.forEach(function (column) {\n        column.preFilteredRows = filteredRows;\n        column.filteredRows = filteredRows;\n      });\n    }, [filteredRows, filters, allColumns]);\n    var getAutoResetFilters = useGetLatest(autoResetFilters);\n    useMountedLayoutEffect(function () {\n      if (getAutoResetFilters()) {\n        dispatch({\n          type: actions.resetFilters\n        });\n      }\n    }, [dispatch, manualFilters ? null : data]);\n    Object.assign(instance, {\n      preFilteredRows: rows,\n      preFilteredFlatRows: flatRows,\n      preFilteredRowsById: rowsById,\n      filteredRows: filteredRows,\n      filteredFlatRows: filteredFlatRows,\n      filteredRowsById: filteredRowsById,\n      rows: filteredRows,\n      flatRows: filteredFlatRows,\n      rowsById: filteredRowsById,\n      setFilter: setFilter,\n      setAllFilters: setAllFilters\n    });\n  }\n\n  actions.resetGlobalFilter = 'resetGlobalFilter';\n  actions.setGlobalFilter = 'setGlobalFilter';\n  var useGlobalFilter = function useGlobalFilter(hooks) {\n    hooks.stateReducers.push(reducer$3);\n    hooks.useInstance.push(useInstance$3);\n  };\n  useGlobalFilter.pluginName = 'useGlobalFilter';\n\n  function reducer$3(state, action, previousState, instance) {\n    if (action.type === actions.resetGlobalFilter) {\n      return _extends({}, state, {\n        globalFilter: instance.initialState.globalFilter || undefined\n      });\n    }\n\n    if (action.type === actions.setGlobalFilter) {\n      var filterValue = action.filterValue;\n      var userFilterTypes = instance.userFilterTypes;\n      var filterMethod = getFilterMethod(instance.globalFilter, userFilterTypes || {}, filterTypes);\n      var newFilter = functionalUpdate(filterValue, state.globalFilter); //\n\n      if (shouldAutoRemoveFilter(filterMethod.autoRemove, newFilter)) {\n        var globalFilter = state.globalFilter,\n            stateWithoutGlobalFilter = _objectWithoutPropertiesLoose(state, [\"globalFilter\"]);\n\n        return stateWithoutGlobalFilter;\n      }\n\n      return _extends({}, state, {\n        globalFilter: newFilter\n      });\n    }\n  }\n\n  function useInstance$3(instance) {\n    var data = instance.data,\n        rows = instance.rows,\n        flatRows = instance.flatRows,\n        rowsById = instance.rowsById,\n        allColumns = instance.allColumns,\n        userFilterTypes = instance.filterTypes,\n        globalFilter = instance.globalFilter,\n        manualGlobalFilter = instance.manualGlobalFilter,\n        globalFilterValue = instance.state.globalFilter,\n        dispatch = instance.dispatch,\n        _instance$autoResetGl = instance.autoResetGlobalFilter,\n        autoResetGlobalFilter = _instance$autoResetGl === void 0 ? true : _instance$autoResetGl,\n        disableGlobalFilter = instance.disableGlobalFilter;\n    var setGlobalFilter = React.useCallback(function (filterValue) {\n      dispatch({\n        type: actions.setGlobalFilter,\n        filterValue: filterValue\n      });\n    }, [dispatch]); // TODO: Create a filter cache for incremental high speed multi-filtering\n    // This gets pretty complicated pretty fast, since you have to maintain a\n    // cache for each row group (top-level rows, and each row's recursive subrows)\n    // This would make multi-filtering a lot faster though. Too far?\n\n    var _React$useMemo = React.useMemo(function () {\n      if (manualGlobalFilter || typeof globalFilterValue === 'undefined') {\n        return [rows, flatRows, rowsById];\n      }\n\n      var filteredFlatRows = [];\n      var filteredRowsById = {};\n      var filterMethod = getFilterMethod(globalFilter, userFilterTypes || {}, filterTypes);\n\n      if (!filterMethod) {\n        console.warn(\"Could not find a valid 'globalFilter' option.\");\n        return rows;\n      }\n\n      allColumns.forEach(function (column) {\n        var columnDisableGlobalFilter = column.disableGlobalFilter;\n        column.canFilter = getFirstDefined(columnDisableGlobalFilter === true ? false : undefined, disableGlobalFilter === true ? false : undefined, true);\n      });\n      var filterableColumns = allColumns.filter(function (c) {\n        return c.canFilter === true;\n      }); // Filters top level and nested rows\n\n      var filterRows = function filterRows(filteredRows) {\n        filteredRows = filterMethod(filteredRows, filterableColumns.map(function (d) {\n          return d.id;\n        }), globalFilterValue);\n        filteredRows.forEach(function (row) {\n          filteredFlatRows.push(row);\n          filteredRowsById[row.id] = row;\n          row.subRows = row.subRows && row.subRows.length ? filterRows(row.subRows) : row.subRows;\n        });\n        return filteredRows;\n      };\n\n      return [filterRows(rows), filteredFlatRows, filteredRowsById];\n    }, [manualGlobalFilter, globalFilterValue, globalFilter, userFilterTypes, allColumns, rows, flatRows, rowsById, disableGlobalFilter]),\n        globalFilteredRows = _React$useMemo[0],\n        globalFilteredFlatRows = _React$useMemo[1],\n        globalFilteredRowsById = _React$useMemo[2];\n\n    var getAutoResetGlobalFilter = useGetLatest(autoResetGlobalFilter);\n    useMountedLayoutEffect(function () {\n      if (getAutoResetGlobalFilter()) {\n        dispatch({\n          type: actions.resetGlobalFilter\n        });\n      }\n    }, [dispatch, manualGlobalFilter ? null : data]);\n    Object.assign(instance, {\n      preGlobalFilteredRows: rows,\n      preGlobalFilteredFlatRows: flatRows,\n      preGlobalFilteredRowsById: rowsById,\n      globalFilteredRows: globalFilteredRows,\n      globalFilteredFlatRows: globalFilteredFlatRows,\n      globalFilteredRowsById: globalFilteredRowsById,\n      rows: globalFilteredRows,\n      flatRows: globalFilteredFlatRows,\n      rowsById: globalFilteredRowsById,\n      setGlobalFilter: setGlobalFilter,\n      disableGlobalFilter: disableGlobalFilter\n    });\n  }\n\n  function sum(values, aggregatedValues) {\n    // It's faster to just add the aggregations together instead of\n    // process leaf nodes individually\n    return aggregatedValues.reduce(function (sum, next) {\n      return sum + (typeof next === 'number' ? next : 0);\n    }, 0);\n  }\n  function min(values) {\n    var min = values[0] || 0;\n    values.forEach(function (value) {\n      if (typeof value === 'number') {\n        min = Math.min(min, value);\n      }\n    });\n    return min;\n  }\n  function max(values) {\n    var max = values[0] || 0;\n    values.forEach(function (value) {\n      if (typeof value === 'number') {\n        max = Math.max(max, value);\n      }\n    });\n    return max;\n  }\n  function minMax(values) {\n    var min = values[0] || 0;\n    var max = values[0] || 0;\n    values.forEach(function (value) {\n      if (typeof value === 'number') {\n        min = Math.min(min, value);\n        max = Math.max(max, value);\n      }\n    });\n    return min + \"..\" + max;\n  }\n  function average(values) {\n    return sum(null, values) / values.length;\n  }\n  function median(values) {\n    if (!values.length) {\n      return null;\n    }\n\n    var mid = Math.floor(values.length / 2);\n    var nums = [].concat(values).sort(function (a, b) {\n      return a - b;\n    });\n    return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n  }\n  function unique(values) {\n    return Array.from(new Set(values).values());\n  }\n  function uniqueCount(values) {\n    return new Set(values).size;\n  }\n  function count(values) {\n    return values.length;\n  }\n\n  var aggregations = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    sum: sum,\n    min: min,\n    max: max,\n    minMax: minMax,\n    average: average,\n    median: median,\n    unique: unique,\n    uniqueCount: uniqueCount,\n    count: count\n  });\n\n  var emptyArray = [];\n  var emptyObject = {}; // Actions\n\n  actions.resetGroupBy = 'resetGroupBy';\n  actions.setGroupBy = 'setGroupBy';\n  actions.toggleGroupBy = 'toggleGroupBy';\n  var useGroupBy = function useGroupBy(hooks) {\n    hooks.getGroupByToggleProps = [defaultGetGroupByToggleProps];\n    hooks.stateReducers.push(reducer$4);\n    hooks.visibleColumnsDeps.push(function (deps, _ref) {\n      var instance = _ref.instance;\n      return [].concat(deps, [instance.state.groupBy]);\n    });\n    hooks.visibleColumns.push(visibleColumns);\n    hooks.useInstance.push(useInstance$4);\n    hooks.prepareRow.push(prepareRow$1);\n  };\n  useGroupBy.pluginName = 'useGroupBy';\n\n  var defaultGetGroupByToggleProps = function defaultGetGroupByToggleProps(props, _ref2) {\n    var header = _ref2.header;\n    return [props, {\n      onClick: header.canGroupBy ? function (e) {\n        e.persist();\n        header.toggleGroupBy();\n      } : undefined,\n      style: {\n        cursor: header.canGroupBy ? 'pointer' : undefined\n      },\n      title: 'Toggle GroupBy'\n    }];\n  }; // Reducer\n\n\n  function reducer$4(state, action, previousState, instance) {\n    if (action.type === actions.init) {\n      return _extends({\n        groupBy: []\n      }, state);\n    }\n\n    if (action.type === actions.resetGroupBy) {\n      return _extends({}, state, {\n        groupBy: instance.initialState.groupBy || []\n      });\n    }\n\n    if (action.type === actions.setGroupBy) {\n      var value = action.value;\n      return _extends({}, state, {\n        groupBy: value\n      });\n    }\n\n    if (action.type === actions.toggleGroupBy) {\n      var columnId = action.columnId,\n          setGroupBy = action.value;\n      var resolvedGroupBy = typeof setGroupBy !== 'undefined' ? setGroupBy : !state.groupBy.includes(columnId);\n\n      if (resolvedGroupBy) {\n        return _extends({}, state, {\n          groupBy: [].concat(state.groupBy, [columnId])\n        });\n      }\n\n      return _extends({}, state, {\n        groupBy: state.groupBy.filter(function (d) {\n          return d !== columnId;\n        })\n      });\n    }\n  }\n\n  function visibleColumns(columns, _ref3) {\n    var groupBy = _ref3.instance.state.groupBy;\n    // Sort grouped columns to the start of the column list\n    // before the headers are built\n    var groupByColumns = groupBy.map(function (g) {\n      return columns.find(function (col) {\n        return col.id === g;\n      });\n    }).filter(Boolean);\n    var nonGroupByColumns = columns.filter(function (col) {\n      return !groupBy.includes(col.id);\n    });\n    columns = [].concat(groupByColumns, nonGroupByColumns);\n    columns.forEach(function (column) {\n      column.isGrouped = groupBy.includes(column.id);\n      column.groupedIndex = groupBy.indexOf(column.id);\n    });\n    return columns;\n  }\n\n  var defaultUserAggregations = {};\n\n  function useInstance$4(instance) {\n    var data = instance.data,\n        rows = instance.rows,\n        flatRows = instance.flatRows,\n        rowsById = instance.rowsById,\n        allColumns = instance.allColumns,\n        flatHeaders = instance.flatHeaders,\n        _instance$groupByFn = instance.groupByFn,\n        groupByFn = _instance$groupByFn === void 0 ? defaultGroupByFn : _instance$groupByFn,\n        manualGroupBy = instance.manualGroupBy,\n        _instance$aggregation = instance.aggregations,\n        userAggregations = _instance$aggregation === void 0 ? defaultUserAggregations : _instance$aggregation,\n        plugins = instance.plugins,\n        groupBy = instance.state.groupBy,\n        dispatch = instance.dispatch,\n        _instance$autoResetGr = instance.autoResetGroupBy,\n        autoResetGroupBy = _instance$autoResetGr === void 0 ? true : _instance$autoResetGr,\n        disableGroupBy = instance.disableGroupBy,\n        defaultCanGroupBy = instance.defaultCanGroupBy,\n        getHooks = instance.getHooks;\n    ensurePluginOrder(plugins, ['useColumnOrder', 'useFilters'], 'useGroupBy');\n    var getInstance = useGetLatest(instance);\n    allColumns.forEach(function (column) {\n      var accessor = column.accessor,\n          defaultColumnGroupBy = column.defaultGroupBy,\n          columnDisableGroupBy = column.disableGroupBy;\n      column.canGroupBy = accessor ? getFirstDefined(column.canGroupBy, columnDisableGroupBy === true ? false : undefined, disableGroupBy === true ? false : undefined, true) : getFirstDefined(column.canGroupBy, defaultColumnGroupBy, defaultCanGroupBy, false);\n\n      if (column.canGroupBy) {\n        column.toggleGroupBy = function () {\n          return instance.toggleGroupBy(column.id);\n        };\n      }\n\n      column.Aggregated = column.Aggregated || column.Cell;\n    });\n    var toggleGroupBy = React.useCallback(function (columnId, value) {\n      dispatch({\n        type: actions.toggleGroupBy,\n        columnId: columnId,\n        value: value\n      });\n    }, [dispatch]);\n    var setGroupBy = React.useCallback(function (value) {\n      dispatch({\n        type: actions.setGroupBy,\n        value: value\n      });\n    }, [dispatch]);\n    flatHeaders.forEach(function (header) {\n      header.getGroupByToggleProps = makePropGetter(getHooks().getGroupByToggleProps, {\n        instance: getInstance(),\n        header: header\n      });\n    });\n\n    var _React$useMemo = React.useMemo(function () {\n      if (manualGroupBy || !groupBy.length) {\n        return [rows, flatRows, rowsById, emptyArray, emptyObject, flatRows, rowsById];\n      } // Ensure that the list of filtered columns exist\n\n\n      var existingGroupBy = groupBy.filter(function (g) {\n        return allColumns.find(function (col) {\n          return col.id === g;\n        });\n      }); // Find the columns that can or are aggregating\n      // Uses each column to aggregate rows into a single value\n\n      var aggregateRowsToValues = function aggregateRowsToValues(leafRows, groupedRows, depth) {\n        var values = {};\n        allColumns.forEach(function (column) {\n          // Don't aggregate columns that are in the groupBy\n          if (existingGroupBy.includes(column.id)) {\n            values[column.id] = groupedRows[0] ? groupedRows[0].values[column.id] : null;\n            return;\n          } // Aggregate the values\n\n\n          var aggregateFn = typeof column.aggregate === 'function' ? column.aggregate : userAggregations[column.aggregate] || aggregations[column.aggregate];\n\n          if (aggregateFn) {\n            // Get the columnValues to aggregate\n            var groupedValues = groupedRows.map(function (row) {\n              return row.values[column.id];\n            }); // Get the columnValues to aggregate\n\n            var leafValues = leafRows.map(function (row) {\n              var columnValue = row.values[column.id];\n\n              if (!depth && column.aggregateValue) {\n                var aggregateValueFn = typeof column.aggregateValue === 'function' ? column.aggregateValue : userAggregations[column.aggregateValue] || aggregations[column.aggregateValue];\n\n                if (!aggregateValueFn) {\n                  console.info({\n                    column: column\n                  });\n                  throw new Error(\"React Table: Invalid column.aggregateValue option for column listed above\");\n                }\n\n                columnValue = aggregateValueFn(columnValue, row, column);\n              }\n\n              return columnValue;\n            });\n            values[column.id] = aggregateFn(leafValues, groupedValues);\n          } else if (column.aggregate) {\n            console.info({\n              column: column\n            });\n            throw new Error(\"React Table: Invalid column.aggregate option for column listed above\");\n          } else {\n            values[column.id] = null;\n          }\n        });\n        return values;\n      };\n\n      var groupedFlatRows = [];\n      var groupedRowsById = {};\n      var onlyGroupedFlatRows = [];\n      var onlyGroupedRowsById = {};\n      var nonGroupedFlatRows = [];\n      var nonGroupedRowsById = {}; // Recursively group the data\n\n      var groupUpRecursively = function groupUpRecursively(rows, depth, parentId) {\n        if (depth === void 0) {\n          depth = 0;\n        }\n\n        // This is the last level, just return the rows\n        if (depth === existingGroupBy.length) {\n          return rows.map(function (row) {\n            return _extends({}, row, {\n              depth: depth\n            });\n          });\n        }\n\n        var columnId = existingGroupBy[depth]; // Group the rows together for this level\n\n        var rowGroupsMap = groupByFn(rows, columnId); // Peform aggregations for each group\n\n        var aggregatedGroupedRows = Object.entries(rowGroupsMap).map(function (_ref4, index) {\n          var groupByVal = _ref4[0],\n              groupedRows = _ref4[1];\n          var id = columnId + \":\" + groupByVal;\n          id = parentId ? parentId + \">\" + id : id; // First, Recurse to group sub rows before aggregation\n\n          var subRows = groupUpRecursively(groupedRows, depth + 1, id); // Flatten the leaf rows of the rows in this group\n\n          var leafRows = depth ? flattenBy(groupedRows, 'leafRows') : groupedRows;\n          var values = aggregateRowsToValues(leafRows, groupedRows, depth);\n          var row = {\n            id: id,\n            isGrouped: true,\n            groupByID: columnId,\n            groupByVal: groupByVal,\n            values: values,\n            subRows: subRows,\n            leafRows: leafRows,\n            depth: depth,\n            index: index\n          };\n          subRows.forEach(function (subRow) {\n            groupedFlatRows.push(subRow);\n            groupedRowsById[subRow.id] = subRow;\n\n            if (subRow.isGrouped) {\n              onlyGroupedFlatRows.push(subRow);\n              onlyGroupedRowsById[subRow.id] = subRow;\n            } else {\n              nonGroupedFlatRows.push(subRow);\n              nonGroupedRowsById[subRow.id] = subRow;\n            }\n          });\n          return row;\n        });\n        return aggregatedGroupedRows;\n      };\n\n      var groupedRows = groupUpRecursively(rows);\n      groupedRows.forEach(function (subRow) {\n        groupedFlatRows.push(subRow);\n        groupedRowsById[subRow.id] = subRow;\n\n        if (subRow.isGrouped) {\n          onlyGroupedFlatRows.push(subRow);\n          onlyGroupedRowsById[subRow.id] = subRow;\n        } else {\n          nonGroupedFlatRows.push(subRow);\n          nonGroupedRowsById[subRow.id] = subRow;\n        }\n      }); // Assign the new data\n\n      return [groupedRows, groupedFlatRows, groupedRowsById, onlyGroupedFlatRows, onlyGroupedRowsById, nonGroupedFlatRows, nonGroupedRowsById];\n    }, [manualGroupBy, groupBy, rows, flatRows, rowsById, allColumns, userAggregations, groupByFn]),\n        groupedRows = _React$useMemo[0],\n        groupedFlatRows = _React$useMemo[1],\n        groupedRowsById = _React$useMemo[2],\n        onlyGroupedFlatRows = _React$useMemo[3],\n        onlyGroupedRowsById = _React$useMemo[4],\n        nonGroupedFlatRows = _React$useMemo[5],\n        nonGroupedRowsById = _React$useMemo[6];\n\n    var getAutoResetGroupBy = useGetLatest(autoResetGroupBy);\n    useMountedLayoutEffect(function () {\n      if (getAutoResetGroupBy()) {\n        dispatch({\n          type: actions.resetGroupBy\n        });\n      }\n    }, [dispatch, manualGroupBy ? null : data]);\n    Object.assign(instance, {\n      preGroupedRows: rows,\n      preGroupedFlatRow: flatRows,\n      preGroupedRowsById: rowsById,\n      groupedRows: groupedRows,\n      groupedFlatRows: groupedFlatRows,\n      groupedRowsById: groupedRowsById,\n      onlyGroupedFlatRows: onlyGroupedFlatRows,\n      onlyGroupedRowsById: onlyGroupedRowsById,\n      nonGroupedFlatRows: nonGroupedFlatRows,\n      nonGroupedRowsById: nonGroupedRowsById,\n      rows: groupedRows,\n      flatRows: groupedFlatRows,\n      rowsById: groupedRowsById,\n      toggleGroupBy: toggleGroupBy,\n      setGroupBy: setGroupBy\n    });\n  }\n\n  function prepareRow$1(row) {\n    row.allCells.forEach(function (cell) {\n      var _row$subRows;\n\n      // Grouped cells are in the groupBy and the pivot cell for the row\n      cell.isGrouped = cell.column.isGrouped && cell.column.id === row.groupByID; // Placeholder cells are any columns in the groupBy that are not grouped\n\n      cell.isPlaceholder = !cell.isGrouped && cell.column.isGrouped; // Aggregated cells are not grouped, not repeated, but still have subRows\n\n      cell.isAggregated = !cell.isGrouped && !cell.isPlaceholder && ((_row$subRows = row.subRows) == null ? void 0 : _row$subRows.length);\n    });\n  }\n\n  function defaultGroupByFn(rows, columnId) {\n    return rows.reduce(function (prev, row, i) {\n      // TODO: Might want to implement a key serializer here so\n      // irregular column values can still be grouped if needed?\n      var resKey = \"\" + row.values[columnId];\n      prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : [];\n      prev[resKey].push(row);\n      return prev;\n    }, {});\n  }\n\n  var reSplitAlphaNumeric = /([0-9]+)/gm; // Mixed sorting is slow, but very inclusive of many edge cases.\n  // It handles numbers, mixed alphanumeric combinations, and even\n  // null, undefined, and Infinity\n\n  var alphanumeric = function alphanumeric(rowA, rowB, columnId) {\n    var _getRowValuesByColumn = getRowValuesByColumnID(rowA, rowB, columnId),\n        a = _getRowValuesByColumn[0],\n        b = _getRowValuesByColumn[1]; // Force to strings (or \"\" for unsupported types)\n\n\n    a = toString(a);\n    b = toString(b); // Split on number groups, but keep the delimiter\n    // Then remove falsey split values\n\n    a = a.split(reSplitAlphaNumeric).filter(Boolean);\n    b = b.split(reSplitAlphaNumeric).filter(Boolean); // While\n\n    while (a.length && b.length) {\n      var aa = a.shift();\n      var bb = b.shift();\n      var an = parseInt(aa, 10);\n      var bn = parseInt(bb, 10);\n      var combo = [an, bn].sort(); // Both are string\n\n      if (isNaN(combo[0])) {\n        if (aa > bb) {\n          return 1;\n        }\n\n        if (bb > aa) {\n          return -1;\n        }\n\n        continue;\n      } // One is a string, one is a number\n\n\n      if (isNaN(combo[1])) {\n        return isNaN(an) ? -1 : 1;\n      } // Both are numbers\n\n\n      if (an > bn) {\n        return 1;\n      }\n\n      if (bn > an) {\n        return -1;\n      }\n    }\n\n    return a.length - b.length;\n  };\n  function datetime(rowA, rowB, columnId) {\n    var _getRowValuesByColumn2 = getRowValuesByColumnID(rowA, rowB, columnId),\n        a = _getRowValuesByColumn2[0],\n        b = _getRowValuesByColumn2[1];\n\n    a = a.getTime();\n    b = b.getTime();\n    return compareBasic(a, b);\n  }\n  function basic(rowA, rowB, columnId) {\n    var _getRowValuesByColumn3 = getRowValuesByColumnID(rowA, rowB, columnId),\n        a = _getRowValuesByColumn3[0],\n        b = _getRowValuesByColumn3[1];\n\n    return compareBasic(a, b);\n  }\n  function string(rowA, rowB, columnId) {\n    var _getRowValuesByColumn4 = getRowValuesByColumnID(rowA, rowB, columnId),\n        a = _getRowValuesByColumn4[0],\n        b = _getRowValuesByColumn4[1];\n\n    a = a.split('').filter(Boolean);\n    b = b.split('').filter(Boolean);\n\n    while (a.length && b.length) {\n      var aa = a.shift();\n      var bb = b.shift();\n      var alower = aa.toLowerCase();\n      var blower = bb.toLowerCase(); // Case insensitive comparison until characters match\n\n      if (alower > blower) {\n        return 1;\n      }\n\n      if (blower > alower) {\n        return -1;\n      } // If lowercase characters are identical\n\n\n      if (aa > bb) {\n        return 1;\n      }\n\n      if (bb > aa) {\n        return -1;\n      }\n\n      continue;\n    }\n\n    return a.length - b.length;\n  }\n  function number(rowA, rowB, columnId) {\n    var _getRowValuesByColumn5 = getRowValuesByColumnID(rowA, rowB, columnId),\n        a = _getRowValuesByColumn5[0],\n        b = _getRowValuesByColumn5[1];\n\n    var replaceNonNumeric = /[^0-9.]/gi;\n    a = Number(String(a).replace(replaceNonNumeric, ''));\n    b = Number(String(b).replace(replaceNonNumeric, ''));\n    return compareBasic(a, b);\n  } // Utils\n\n  function compareBasic(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n  }\n\n  function getRowValuesByColumnID(row1, row2, columnId) {\n    return [row1.values[columnId], row2.values[columnId]];\n  }\n\n  function toString(a) {\n    if (typeof a === 'number') {\n      if (isNaN(a) || a === Infinity || a === -Infinity) {\n        return '';\n      }\n\n      return String(a);\n    }\n\n    if (typeof a === 'string') {\n      return a;\n    }\n\n    return '';\n  }\n\n  var sortTypes = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    alphanumeric: alphanumeric,\n    datetime: datetime,\n    basic: basic,\n    string: string,\n    number: number\n  });\n\n  actions.resetSortBy = 'resetSortBy';\n  actions.setSortBy = 'setSortBy';\n  actions.toggleSortBy = 'toggleSortBy';\n  actions.clearSortBy = 'clearSortBy';\n  defaultColumn.sortType = 'alphanumeric';\n  defaultColumn.sortDescFirst = false;\n  var useSortBy = function useSortBy(hooks) {\n    hooks.getSortByToggleProps = [defaultGetSortByToggleProps];\n    hooks.stateReducers.push(reducer$5);\n    hooks.useInstance.push(useInstance$5);\n  };\n  useSortBy.pluginName = 'useSortBy';\n\n  var defaultGetSortByToggleProps = function defaultGetSortByToggleProps(props, _ref) {\n    var instance = _ref.instance,\n        column = _ref.column;\n    var _instance$isMultiSort = instance.isMultiSortEvent,\n        isMultiSortEvent = _instance$isMultiSort === void 0 ? function (e) {\n      return e.shiftKey;\n    } : _instance$isMultiSort;\n    return [props, {\n      onClick: column.canSort ? function (e) {\n        e.persist();\n        column.toggleSortBy(undefined, !instance.disableMultiSort && isMultiSortEvent(e));\n      } : undefined,\n      style: {\n        cursor: column.canSort ? 'pointer' : undefined\n      },\n      title: column.canSort ? 'Toggle SortBy' : undefined\n    }];\n  }; // Reducer\n\n\n  function reducer$5(state, action, previousState, instance) {\n    if (action.type === actions.init) {\n      return _extends({\n        sortBy: []\n      }, state);\n    }\n\n    if (action.type === actions.resetSortBy) {\n      return _extends({}, state, {\n        sortBy: instance.initialState.sortBy || []\n      });\n    }\n\n    if (action.type === actions.clearSortBy) {\n      var sortBy = state.sortBy;\n      var newSortBy = sortBy.filter(function (d) {\n        return d.id !== action.columnId;\n      });\n      return _extends({}, state, {\n        sortBy: newSortBy\n      });\n    }\n\n    if (action.type === actions.setSortBy) {\n      var _sortBy = action.sortBy;\n      return _extends({}, state, {\n        sortBy: _sortBy\n      });\n    }\n\n    if (action.type === actions.toggleSortBy) {\n      var columnId = action.columnId,\n          desc = action.desc,\n          multi = action.multi;\n      var allColumns = instance.allColumns,\n          disableMultiSort = instance.disableMultiSort,\n          disableSortRemove = instance.disableSortRemove,\n          disableMultiRemove = instance.disableMultiRemove,\n          _instance$maxMultiSor = instance.maxMultiSortColCount,\n          maxMultiSortColCount = _instance$maxMultiSor === void 0 ? Number.MAX_SAFE_INTEGER : _instance$maxMultiSor;\n      var _sortBy2 = state.sortBy; // Find the column for this columnId\n\n      var column = allColumns.find(function (d) {\n        return d.id === columnId;\n      });\n      var sortDescFirst = column.sortDescFirst; // Find any existing sortBy for this column\n\n      var existingSortBy = _sortBy2.find(function (d) {\n        return d.id === columnId;\n      });\n\n      var existingIndex = _sortBy2.findIndex(function (d) {\n        return d.id === columnId;\n      });\n\n      var hasDescDefined = typeof desc !== 'undefined' && desc !== null;\n      var _newSortBy = []; // What should we do with this sort action?\n\n      var sortAction;\n\n      if (!disableMultiSort && multi) {\n        if (existingSortBy) {\n          sortAction = 'toggle';\n        } else {\n          sortAction = 'add';\n        }\n      } else {\n        // Normal mode\n        if (existingIndex !== _sortBy2.length - 1 || _sortBy2.length !== 1) {\n          sortAction = 'replace';\n        } else if (existingSortBy) {\n          sortAction = 'toggle';\n        } else {\n          sortAction = 'replace';\n        }\n      } // Handle toggle states that will remove the sortBy\n\n\n      if (sortAction === 'toggle' && // Must be toggling\n      !disableSortRemove && // If disableSortRemove, disable in general\n      !hasDescDefined && ( // Must not be setting desc\n      multi ? !disableMultiRemove : true) && ( // If multi, don't allow if disableMultiRemove\n      existingSortBy && // Finally, detect if it should indeed be removed\n      existingSortBy.desc && !sortDescFirst || !existingSortBy.desc && sortDescFirst)) {\n        sortAction = 'remove';\n      }\n\n      if (sortAction === 'replace') {\n        _newSortBy = [{\n          id: columnId,\n          desc: hasDescDefined ? desc : sortDescFirst\n        }];\n      } else if (sortAction === 'add') {\n        _newSortBy = [].concat(_sortBy2, [{\n          id: columnId,\n          desc: hasDescDefined ? desc : sortDescFirst\n        }]); // Take latest n columns\n\n        _newSortBy.splice(0, _newSortBy.length - maxMultiSortColCount);\n      } else if (sortAction === 'toggle') {\n        // This flips (or sets) the\n        _newSortBy = _sortBy2.map(function (d) {\n          if (d.id === columnId) {\n            return _extends({}, d, {\n              desc: hasDescDefined ? desc : !existingSortBy.desc\n            });\n          }\n\n          return d;\n        });\n      } else if (sortAction === 'remove') {\n        _newSortBy = _sortBy2.filter(function (d) {\n          return d.id !== columnId;\n        });\n      }\n\n      return _extends({}, state, {\n        sortBy: _newSortBy\n      });\n    }\n  }\n\n  function useInstance$5(instance) {\n    var data = instance.data,\n        rows = instance.rows,\n        flatRows = instance.flatRows,\n        allColumns = instance.allColumns,\n        _instance$orderByFn = instance.orderByFn,\n        orderByFn = _instance$orderByFn === void 0 ? defaultOrderByFn : _instance$orderByFn,\n        userSortTypes = instance.sortTypes,\n        manualSortBy = instance.manualSortBy,\n        defaultCanSort = instance.defaultCanSort,\n        disableSortBy = instance.disableSortBy,\n        flatHeaders = instance.flatHeaders,\n        sortBy = instance.state.sortBy,\n        dispatch = instance.dispatch,\n        plugins = instance.plugins,\n        getHooks = instance.getHooks,\n        _instance$autoResetSo = instance.autoResetSortBy,\n        autoResetSortBy = _instance$autoResetSo === void 0 ? true : _instance$autoResetSo;\n    ensurePluginOrder(plugins, ['useFilters', 'useGlobalFilter', 'useGroupBy', 'usePivotColumns'], 'useSortBy');\n    var setSortBy = React.useCallback(function (sortBy) {\n      dispatch({\n        type: actions.setSortBy,\n        sortBy: sortBy\n      });\n    }, [dispatch]); // Updates sorting based on a columnId, desc flag and multi flag\n\n    var toggleSortBy = React.useCallback(function (columnId, desc, multi) {\n      dispatch({\n        type: actions.toggleSortBy,\n        columnId: columnId,\n        desc: desc,\n        multi: multi\n      });\n    }, [dispatch]); // use reference to avoid memory leak in #1608\n\n    var getInstance = useGetLatest(instance); // Add the getSortByToggleProps method to columns and headers\n\n    flatHeaders.forEach(function (column) {\n      var accessor = column.accessor,\n          defaultColumnCanSort = column.canSort,\n          columnDisableSortBy = column.disableSortBy,\n          id = column.id;\n      var canSort = accessor ? getFirstDefined(columnDisableSortBy === true ? false : undefined, disableSortBy === true ? false : undefined, true) : getFirstDefined(defaultCanSort, defaultColumnCanSort, false);\n      column.canSort = canSort;\n\n      if (column.canSort) {\n        column.toggleSortBy = function (desc, multi) {\n          return toggleSortBy(column.id, desc, multi);\n        };\n\n        column.clearSortBy = function () {\n          dispatch({\n            type: actions.clearSortBy,\n            columnId: column.id\n          });\n        };\n      }\n\n      column.getSortByToggleProps = makePropGetter(getHooks().getSortByToggleProps, {\n        instance: getInstance(),\n        column: column\n      });\n      var columnSort = sortBy.find(function (d) {\n        return d.id === id;\n      });\n      column.isSorted = !!columnSort;\n      column.sortedIndex = sortBy.findIndex(function (d) {\n        return d.id === id;\n      });\n      column.isSortedDesc = column.isSorted ? columnSort.desc : undefined;\n    });\n\n    var _React$useMemo = React.useMemo(function () {\n      if (manualSortBy || !sortBy.length) {\n        return [rows, flatRows];\n      }\n\n      var sortedFlatRows = []; // Filter out sortBys that correspond to non existing columns\n\n      var availableSortBy = sortBy.filter(function (sort) {\n        return allColumns.find(function (col) {\n          return col.id === sort.id;\n        });\n      });\n\n      var sortData = function sortData(rows) {\n        // Use the orderByFn to compose multiple sortBy's together.\n        // This will also perform a stable sorting using the row index\n        // if needed.\n        var sortedData = orderByFn(rows, availableSortBy.map(function (sort) {\n          // Support custom sorting methods for each column\n          var column = allColumns.find(function (d) {\n            return d.id === sort.id;\n          });\n\n          if (!column) {\n            throw new Error(\"React-Table: Could not find a column with id: \" + sort.id + \" while sorting\");\n          }\n\n          var sortType = column.sortType; // Look up sortBy functions in this order:\n          // column function\n          // column string lookup on user sortType\n          // column string lookup on built-in sortType\n          // default function\n          // default string lookup on user sortType\n          // default string lookup on built-in sortType\n\n          var sortMethod = isFunction(sortType) || (userSortTypes || {})[sortType] || sortTypes[sortType];\n\n          if (!sortMethod) {\n            throw new Error(\"React-Table: Could not find a valid sortType of '\" + sortType + \"' for column '\" + sort.id + \"'.\");\n          } // Return the correct sortFn.\n          // This function should always return in ascending order\n\n\n          return function (a, b) {\n            return sortMethod(a, b, sort.id, sort.desc);\n          };\n        }), // Map the directions\n        availableSortBy.map(function (sort) {\n          // Detect and use the sortInverted option\n          var column = allColumns.find(function (d) {\n            return d.id === sort.id;\n          });\n\n          if (column && column.sortInverted) {\n            return sort.desc;\n          }\n\n          return !sort.desc;\n        })); // If there are sub-rows, sort them\n\n        sortedData.forEach(function (row) {\n          sortedFlatRows.push(row);\n\n          if (!row.subRows || row.subRows.length === 0) {\n            return;\n          }\n\n          row.subRows = sortData(row.subRows);\n        });\n        return sortedData;\n      };\n\n      return [sortData(rows), sortedFlatRows];\n    }, [manualSortBy, sortBy, rows, flatRows, allColumns, orderByFn, userSortTypes]),\n        sortedRows = _React$useMemo[0],\n        sortedFlatRows = _React$useMemo[1];\n\n    var getAutoResetSortBy = useGetLatest(autoResetSortBy);\n    useMountedLayoutEffect(function () {\n      if (getAutoResetSortBy()) {\n        dispatch({\n          type: actions.resetSortBy\n        });\n      }\n    }, [manualSortBy ? null : data]);\n    Object.assign(instance, {\n      preSortedRows: rows,\n      preSortedFlatRows: flatRows,\n      sortedRows: sortedRows,\n      sortedFlatRows: sortedFlatRows,\n      rows: sortedRows,\n      flatRows: sortedFlatRows,\n      setSortBy: setSortBy,\n      toggleSortBy: toggleSortBy\n    });\n  }\n\n  function defaultOrderByFn(arr, funcs, dirs) {\n    return [].concat(arr).sort(function (rowA, rowB) {\n      for (var i = 0; i < funcs.length; i += 1) {\n        var sortFn = funcs[i];\n        var desc = dirs[i] === false || dirs[i] === 'desc';\n        var sortInt = sortFn(rowA, rowB);\n\n        if (sortInt !== 0) {\n          return desc ? -sortInt : sortInt;\n        }\n      }\n\n      return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index;\n    });\n  }\n\n  var pluginName = 'usePagination'; // Actions\n\n  actions.resetPage = 'resetPage';\n  actions.gotoPage = 'gotoPage';\n  actions.setPageSize = 'setPageSize';\n  var usePagination = function usePagination(hooks) {\n    hooks.stateReducers.push(reducer$6);\n    hooks.useInstance.push(useInstance$6);\n  };\n  usePagination.pluginName = pluginName;\n\n  function reducer$6(state, action, previousState, instance) {\n    if (action.type === actions.init) {\n      return _extends({\n        pageSize: 10,\n        pageIndex: 0\n      }, state);\n    }\n\n    if (action.type === actions.resetPage) {\n      return _extends({}, state, {\n        pageIndex: instance.initialState.pageIndex || 0\n      });\n    }\n\n    if (action.type === actions.gotoPage) {\n      var pageCount = instance.pageCount,\n          page = instance.page;\n      var newPageIndex = functionalUpdate(action.pageIndex, state.pageIndex);\n      var canNavigate = false;\n\n      if (newPageIndex > state.pageIndex) {\n        // next page\n        canNavigate = pageCount === -1 ? page.length >= state.pageSize : newPageIndex < pageCount;\n      } else if (newPageIndex < state.pageIndex) {\n        // prev page\n        canNavigate = newPageIndex > -1;\n      }\n\n      if (!canNavigate) {\n        return state;\n      }\n\n      return _extends({}, state, {\n        pageIndex: newPageIndex\n      });\n    }\n\n    if (action.type === actions.setPageSize) {\n      var pageSize = action.pageSize;\n      var topRowIndex = state.pageSize * state.pageIndex;\n      var pageIndex = Math.floor(topRowIndex / pageSize);\n      return _extends({}, state, {\n        pageIndex: pageIndex,\n        pageSize: pageSize\n      });\n    }\n  }\n\n  function useInstance$6(instance) {\n    var rows = instance.rows,\n        _instance$autoResetPa = instance.autoResetPage,\n        autoResetPage = _instance$autoResetPa === void 0 ? true : _instance$autoResetPa,\n        _instance$manualExpan = instance.manualExpandedKey,\n        manualExpandedKey = _instance$manualExpan === void 0 ? 'expanded' : _instance$manualExpan,\n        plugins = instance.plugins,\n        userPageCount = instance.pageCount,\n        _instance$paginateExp = instance.paginateExpandedRows,\n        paginateExpandedRows = _instance$paginateExp === void 0 ? true : _instance$paginateExp,\n        _instance$expandSubRo = instance.expandSubRows,\n        expandSubRows = _instance$expandSubRo === void 0 ? true : _instance$expandSubRo,\n        _instance$state = instance.state,\n        pageSize = _instance$state.pageSize,\n        pageIndex = _instance$state.pageIndex,\n        expanded = _instance$state.expanded,\n        globalFilter = _instance$state.globalFilter,\n        filters = _instance$state.filters,\n        groupBy = _instance$state.groupBy,\n        sortBy = _instance$state.sortBy,\n        dispatch = instance.dispatch,\n        data = instance.data,\n        manualPagination = instance.manualPagination;\n    ensurePluginOrder(plugins, ['useGlobalFilter', 'useFilters', 'useGroupBy', 'useSortBy', 'useExpanded'], 'usePagination');\n    var getAutoResetPage = useGetLatest(autoResetPage);\n    useMountedLayoutEffect(function () {\n      if (getAutoResetPage()) {\n        dispatch({\n          type: actions.resetPage\n        });\n      }\n    }, [dispatch, manualPagination ? null : data, globalFilter, filters, groupBy, sortBy]);\n    var pageCount = manualPagination ? userPageCount : Math.ceil(rows.length / pageSize);\n    var pageOptions = React.useMemo(function () {\n      return pageCount > 0 ? [].concat(new Array(pageCount)).fill(null).map(function (d, i) {\n        return i;\n      }) : [];\n    }, [pageCount]);\n    var page = React.useMemo(function () {\n      var page;\n\n      if (manualPagination) {\n        page = rows;\n      } else {\n        var pageStart = pageSize * pageIndex;\n        var pageEnd = pageStart + pageSize;\n        page = rows.slice(pageStart, pageEnd);\n      }\n\n      if (paginateExpandedRows) {\n        return page;\n      }\n\n      return expandRows(page, {\n        manualExpandedKey: manualExpandedKey,\n        expanded: expanded,\n        expandSubRows: expandSubRows\n      });\n    }, [expandSubRows, expanded, manualExpandedKey, manualPagination, pageIndex, pageSize, paginateExpandedRows, rows]);\n    var canPreviousPage = pageIndex > 0;\n    var canNextPage = pageCount === -1 ? page.length >= pageSize : pageIndex < pageCount - 1;\n    var gotoPage = React.useCallback(function (pageIndex) {\n      dispatch({\n        type: actions.gotoPage,\n        pageIndex: pageIndex\n      });\n    }, [dispatch]);\n    var previousPage = React.useCallback(function () {\n      return gotoPage(function (old) {\n        return old - 1;\n      });\n    }, [gotoPage]);\n    var nextPage = React.useCallback(function () {\n      return gotoPage(function (old) {\n        return old + 1;\n      });\n    }, [gotoPage]);\n    var setPageSize = React.useCallback(function (pageSize) {\n      dispatch({\n        type: actions.setPageSize,\n        pageSize: pageSize\n      });\n    }, [dispatch]);\n    Object.assign(instance, {\n      pageOptions: pageOptions,\n      pageCount: pageCount,\n      page: page,\n      canPreviousPage: canPreviousPage,\n      canNextPage: canNextPage,\n      gotoPage: gotoPage,\n      previousPage: previousPage,\n      nextPage: nextPage,\n      setPageSize: setPageSize\n    });\n  }\n\n  actions.resetPivot = 'resetPivot';\n  actions.togglePivot = 'togglePivot';\n  var _UNSTABLE_usePivotColumns = function _UNSTABLE_usePivotColumns(hooks) {\n    hooks.getPivotToggleProps = [defaultGetPivotToggleProps];\n    hooks.stateReducers.push(reducer$7);\n    hooks.useInstanceAfterData.push(useInstanceAfterData);\n    hooks.allColumns.push(allColumns);\n    hooks.accessValue.push(accessValue);\n    hooks.materializedColumns.push(materializedColumns);\n    hooks.materializedColumnsDeps.push(materializedColumnsDeps);\n    hooks.visibleColumns.push(visibleColumns$1);\n    hooks.visibleColumnsDeps.push(visibleColumnsDeps);\n    hooks.useInstance.push(useInstance$7);\n    hooks.prepareRow.push(prepareRow$2);\n  };\n  _UNSTABLE_usePivotColumns.pluginName = 'usePivotColumns';\n  var defaultPivotColumns = [];\n\n  var defaultGetPivotToggleProps = function defaultGetPivotToggleProps(props, _ref) {\n    var header = _ref.header;\n    return [props, {\n      onClick: header.canPivot ? function (e) {\n        e.persist();\n        header.togglePivot();\n      } : undefined,\n      style: {\n        cursor: header.canPivot ? 'pointer' : undefined\n      },\n      title: 'Toggle Pivot'\n    }];\n  }; // Reducer\n\n\n  function reducer$7(state, action, previousState, instance) {\n    if (action.type === actions.init) {\n      return _extends({\n        pivotColumns: defaultPivotColumns\n      }, state);\n    }\n\n    if (action.type === actions.resetPivot) {\n      return _extends({}, state, {\n        pivotColumns: instance.initialState.pivotColumns || defaultPivotColumns\n      });\n    }\n\n    if (action.type === actions.togglePivot) {\n      var columnId = action.columnId,\n          setPivot = action.value;\n      var resolvedPivot = typeof setPivot !== 'undefined' ? setPivot : !state.pivotColumns.includes(columnId);\n\n      if (resolvedPivot) {\n        return _extends({}, state, {\n          pivotColumns: [].concat(state.pivotColumns, [columnId])\n        });\n      }\n\n      return _extends({}, state, {\n        pivotColumns: state.pivotColumns.filter(function (d) {\n          return d !== columnId;\n        })\n      });\n    }\n  }\n\n  function useInstanceAfterData(instance) {\n    instance.allColumns.forEach(function (column) {\n      column.isPivotSource = instance.state.pivotColumns.includes(column.id);\n    });\n  }\n\n  function allColumns(columns, _ref2) {\n    var instance = _ref2.instance;\n    columns.forEach(function (column) {\n      column.isPivotSource = instance.state.pivotColumns.includes(column.id);\n      column.uniqueValues = new Set();\n    });\n    return columns;\n  }\n\n  function accessValue(value, _ref3) {\n    var column = _ref3.column;\n\n    if (column.uniqueValues && typeof value !== 'undefined') {\n      column.uniqueValues.add(value);\n    }\n\n    return value;\n  }\n\n  function materializedColumns(materialized, _ref4) {\n    var instance = _ref4.instance;\n    var allColumns = instance.allColumns,\n        state = instance.state;\n\n    if (!state.pivotColumns.length || !state.groupBy || !state.groupBy.length) {\n      return materialized;\n    }\n\n    var pivotColumns = state.pivotColumns.map(function (id) {\n      return allColumns.find(function (d) {\n        return d.id === id;\n      });\n    }).filter(Boolean);\n    var sourceColumns = allColumns.filter(function (d) {\n      return !d.isPivotSource && !state.groupBy.includes(d.id) && !state.pivotColumns.includes(d.id);\n    });\n\n    var buildPivotColumns = function buildPivotColumns(depth, parent, pivotFilters) {\n      if (depth === void 0) {\n        depth = 0;\n      }\n\n      if (pivotFilters === void 0) {\n        pivotFilters = [];\n      }\n\n      var pivotColumn = pivotColumns[depth];\n\n      if (!pivotColumn) {\n        return sourceColumns.map(function (sourceColumn) {\n          // TODO: We could offer support here for renesting pivoted\n          // columns inside copies of their header groups. For now,\n          // that seems like it would be (1) overkill on nesting, considering\n          // you already get nesting for every pivot level and (2)\n          // really hard. :)\n          return _extends({}, sourceColumn, {\n            canPivot: false,\n            isPivoted: true,\n            parent: parent,\n            depth: depth,\n            id: \"\" + (parent ? parent.id + \".\" + sourceColumn.id : sourceColumn.id),\n            accessor: function accessor(originalRow, i, row) {\n              if (pivotFilters.every(function (filter) {\n                return filter(row);\n              })) {\n                return row.values[sourceColumn.id];\n              }\n            }\n          });\n        });\n      }\n\n      var uniqueValues = Array.from(pivotColumn.uniqueValues).sort();\n      return uniqueValues.map(function (uniqueValue) {\n        var columnGroup = _extends({}, pivotColumn, {\n          Header: pivotColumn.PivotHeader || typeof pivotColumn.header === 'string' ? pivotColumn.Header + \": \" + uniqueValue : uniqueValue,\n          isPivotGroup: true,\n          parent: parent,\n          depth: depth,\n          id: parent ? parent.id + \".\" + pivotColumn.id + \".\" + uniqueValue : pivotColumn.id + \".\" + uniqueValue,\n          pivotValue: uniqueValue\n        });\n\n        columnGroup.columns = buildPivotColumns(depth + 1, columnGroup, [].concat(pivotFilters, [function (row) {\n          return row.values[pivotColumn.id] === uniqueValue;\n        }]));\n        return columnGroup;\n      });\n    };\n\n    var newMaterialized = flattenColumns(buildPivotColumns());\n    return [].concat(materialized, newMaterialized);\n  }\n\n  function materializedColumnsDeps(deps, _ref5) {\n    var _ref5$instance$state = _ref5.instance.state,\n        pivotColumns = _ref5$instance$state.pivotColumns,\n        groupBy = _ref5$instance$state.groupBy;\n    return [].concat(deps, [pivotColumns, groupBy]);\n  }\n\n  function visibleColumns$1(visibleColumns, _ref6) {\n    var state = _ref6.instance.state;\n    visibleColumns = visibleColumns.filter(function (d) {\n      return !d.isPivotSource;\n    });\n\n    if (state.pivotColumns.length && state.groupBy && state.groupBy.length) {\n      visibleColumns = visibleColumns.filter(function (column) {\n        return column.isGrouped || column.isPivoted;\n      });\n    }\n\n    return visibleColumns;\n  }\n\n  function visibleColumnsDeps(deps, _ref7) {\n    var instance = _ref7.instance;\n    return [].concat(deps, [instance.state.pivotColumns, instance.state.groupBy]);\n  }\n\n  function useInstance$7(instance) {\n    var columns = instance.columns,\n        allColumns = instance.allColumns,\n        flatHeaders = instance.flatHeaders,\n        getHooks = instance.getHooks,\n        plugins = instance.plugins,\n        dispatch = instance.dispatch,\n        _instance$autoResetPi = instance.autoResetPivot,\n        autoResetPivot = _instance$autoResetPi === void 0 ? true : _instance$autoResetPi,\n        manaulPivot = instance.manaulPivot,\n        disablePivot = instance.disablePivot,\n        defaultCanPivot = instance.defaultCanPivot;\n    ensurePluginOrder(plugins, ['useGroupBy'], 'usePivotColumns');\n    var getInstance = useGetLatest(instance);\n    allColumns.forEach(function (column) {\n      var accessor = column.accessor,\n          defaultColumnPivot = column.defaultPivot,\n          columnDisablePivot = column.disablePivot;\n      column.canPivot = accessor ? getFirstDefined(column.canPivot, columnDisablePivot === true ? false : undefined, disablePivot === true ? false : undefined, true) : getFirstDefined(column.canPivot, defaultColumnPivot, defaultCanPivot, false);\n\n      if (column.canPivot) {\n        column.togglePivot = function () {\n          return instance.togglePivot(column.id);\n        };\n      }\n\n      column.Aggregated = column.Aggregated || column.Cell;\n    });\n\n    var togglePivot = function togglePivot(columnId, value) {\n      dispatch({\n        type: actions.togglePivot,\n        columnId: columnId,\n        value: value\n      });\n    };\n\n    flatHeaders.forEach(function (header) {\n      header.getPivotToggleProps = makePropGetter(getHooks().getPivotToggleProps, {\n        instance: getInstance(),\n        header: header\n      });\n    });\n    var getAutoResetPivot = useGetLatest(autoResetPivot);\n    useMountedLayoutEffect(function () {\n      if (getAutoResetPivot()) {\n        dispatch({\n          type: actions.resetPivot\n        });\n      }\n    }, [dispatch, manaulPivot ? null : columns]);\n    Object.assign(instance, {\n      togglePivot: togglePivot\n    });\n  }\n\n  function prepareRow$2(row) {\n    row.allCells.forEach(function (cell) {\n      // Grouped cells are in the pivotColumns and the pivot cell for the row\n      cell.isPivoted = cell.column.isPivoted;\n    });\n  }\n\n  var pluginName$1 = 'useRowSelect'; // Actions\n\n  actions.resetSelectedRows = 'resetSelectedRows';\n  actions.toggleAllRowsSelected = 'toggleAllRowsSelected';\n  actions.toggleRowSelected = 'toggleRowSelected';\n  actions.toggleAllPageRowsSelected = 'toggleAllPageRowsSelected';\n  var useRowSelect = function useRowSelect(hooks) {\n    hooks.getToggleRowSelectedProps = [defaultGetToggleRowSelectedProps];\n    hooks.getToggleAllRowsSelectedProps = [defaultGetToggleAllRowsSelectedProps];\n    hooks.getToggleAllPageRowsSelectedProps = [defaultGetToggleAllPageRowsSelectedProps];\n    hooks.stateReducers.push(reducer$8);\n    hooks.useInstance.push(useInstance$8);\n    hooks.prepareRow.push(prepareRow$3);\n  };\n  useRowSelect.pluginName = pluginName$1;\n\n  var defaultGetToggleRowSelectedProps = function defaultGetToggleRowSelectedProps(props, _ref) {\n    var instance = _ref.instance,\n        row = _ref.row;\n    var _instance$manualRowSe = instance.manualRowSelectedKey,\n        manualRowSelectedKey = _instance$manualRowSe === void 0 ? 'isSelected' : _instance$manualRowSe;\n    var checked = false;\n\n    if (row.original && row.original[manualRowSelectedKey]) {\n      checked = true;\n    } else {\n      checked = row.isSelected;\n    }\n\n    return [props, {\n      onChange: function onChange(e) {\n        row.toggleRowSelected(e.target.checked);\n      },\n      style: {\n        cursor: 'pointer'\n      },\n      checked: checked,\n      title: 'Toggle Row Selected',\n      indeterminate: row.isSomeSelected\n    }];\n  };\n\n  var defaultGetToggleAllRowsSelectedProps = function defaultGetToggleAllRowsSelectedProps(props, _ref2) {\n    var instance = _ref2.instance;\n    return [props, {\n      onChange: function onChange(e) {\n        instance.toggleAllRowsSelected(e.target.checked);\n      },\n      style: {\n        cursor: 'pointer'\n      },\n      checked: instance.isAllRowsSelected,\n      title: 'Toggle All Rows Selected',\n      indeterminate: Boolean(!instance.isAllRowsSelected && Object.keys(instance.state.selectedRowIds).length)\n    }];\n  };\n\n  var defaultGetToggleAllPageRowsSelectedProps = function defaultGetToggleAllPageRowsSelectedProps(props, _ref3) {\n    var instance = _ref3.instance;\n    return [props, {\n      onChange: function onChange(e) {\n        instance.toggleAllPageRowsSelected(e.target.checked);\n      },\n      style: {\n        cursor: 'pointer'\n      },\n      checked: instance.isAllPageRowsSelected,\n      title: 'Toggle All Current Page Rows Selected',\n      indeterminate: Boolean(!instance.isAllPageRowsSelected && instance.page.some(function (_ref4) {\n        var id = _ref4.id;\n        return instance.state.selectedRowIds[id];\n      }))\n    }];\n  }; // eslint-disable-next-line max-params\n\n\n  function reducer$8(state, action, previousState, instance) {\n    if (action.type === actions.init) {\n      return _extends({\n        selectedRowIds: {}\n      }, state);\n    }\n\n    if (action.type === actions.resetSelectedRows) {\n      return _extends({}, state, {\n        selectedRowIds: instance.initialState.selectedRowIds || {}\n      });\n    }\n\n    if (action.type === actions.toggleAllRowsSelected) {\n      var setSelected = action.value;\n      var isAllRowsSelected = instance.isAllRowsSelected,\n          rowsById = instance.rowsById,\n          _instance$nonGroupedR = instance.nonGroupedRowsById,\n          nonGroupedRowsById = _instance$nonGroupedR === void 0 ? rowsById : _instance$nonGroupedR;\n      var selectAll = typeof setSelected !== 'undefined' ? setSelected : !isAllRowsSelected; // Only remove/add the rows that are visible on the screen\n      //  Leave all the other rows that are selected alone.\n\n      var selectedRowIds = Object.assign({}, state.selectedRowIds);\n\n      if (selectAll) {\n        Object.keys(nonGroupedRowsById).forEach(function (rowId) {\n          selectedRowIds[rowId] = true;\n        });\n      } else {\n        Object.keys(nonGroupedRowsById).forEach(function (rowId) {\n          delete selectedRowIds[rowId];\n        });\n      }\n\n      return _extends({}, state, {\n        selectedRowIds: selectedRowIds\n      });\n    }\n\n    if (action.type === actions.toggleRowSelected) {\n      var id = action.id,\n          _setSelected = action.value;\n      var _rowsById = instance.rowsById,\n          _instance$selectSubRo = instance.selectSubRows,\n          selectSubRows = _instance$selectSubRo === void 0 ? true : _instance$selectSubRo,\n          getSubRows = instance.getSubRows;\n      var isSelected = state.selectedRowIds[id];\n      var shouldExist = typeof _setSelected !== 'undefined' ? _setSelected : !isSelected;\n\n      if (isSelected === shouldExist) {\n        return state;\n      }\n\n      var newSelectedRowIds = _extends({}, state.selectedRowIds);\n\n      var handleRowById = function handleRowById(id) {\n        var row = _rowsById[id];\n\n        if (row) {\n          if (!row.isGrouped) {\n            if (shouldExist) {\n              newSelectedRowIds[id] = true;\n            } else {\n              delete newSelectedRowIds[id];\n            }\n          }\n\n          if (selectSubRows && getSubRows(row)) {\n            return getSubRows(row).forEach(function (row) {\n              return handleRowById(row.id);\n            });\n          }\n        }\n      };\n\n      handleRowById(id);\n      return _extends({}, state, {\n        selectedRowIds: newSelectedRowIds\n      });\n    }\n\n    if (action.type === actions.toggleAllPageRowsSelected) {\n      var _setSelected2 = action.value;\n\n      var page = instance.page,\n          _rowsById2 = instance.rowsById,\n          _instance$selectSubRo2 = instance.selectSubRows,\n          _selectSubRows = _instance$selectSubRo2 === void 0 ? true : _instance$selectSubRo2,\n          isAllPageRowsSelected = instance.isAllPageRowsSelected,\n          _getSubRows = instance.getSubRows;\n\n      var _selectAll = typeof _setSelected2 !== 'undefined' ? _setSelected2 : !isAllPageRowsSelected;\n\n      var _newSelectedRowIds = _extends({}, state.selectedRowIds);\n\n      var _handleRowById = function _handleRowById(id) {\n        var row = _rowsById2[id];\n\n        if (!row.isGrouped) {\n          if (_selectAll) {\n            _newSelectedRowIds[id] = true;\n          } else {\n            delete _newSelectedRowIds[id];\n          }\n        }\n\n        if (_selectSubRows && _getSubRows(row)) {\n          return _getSubRows(row).forEach(function (row) {\n            return _handleRowById(row.id);\n          });\n        }\n      };\n\n      page.forEach(function (row) {\n        return _handleRowById(row.id);\n      });\n      return _extends({}, state, {\n        selectedRowIds: _newSelectedRowIds\n      });\n    }\n\n    return state;\n  }\n\n  function useInstance$8(instance) {\n    var data = instance.data,\n        rows = instance.rows,\n        getHooks = instance.getHooks,\n        plugins = instance.plugins,\n        rowsById = instance.rowsById,\n        _instance$nonGroupedR2 = instance.nonGroupedRowsById,\n        nonGroupedRowsById = _instance$nonGroupedR2 === void 0 ? rowsById : _instance$nonGroupedR2,\n        _instance$autoResetSe = instance.autoResetSelectedRows,\n        autoResetSelectedRows = _instance$autoResetSe === void 0 ? true : _instance$autoResetSe,\n        selectedRowIds = instance.state.selectedRowIds,\n        _instance$selectSubRo3 = instance.selectSubRows,\n        selectSubRows = _instance$selectSubRo3 === void 0 ? true : _instance$selectSubRo3,\n        dispatch = instance.dispatch,\n        page = instance.page,\n        getSubRows = instance.getSubRows;\n    ensurePluginOrder(plugins, ['useFilters', 'useGroupBy', 'useSortBy', 'useExpanded', 'usePagination'], 'useRowSelect');\n    var selectedFlatRows = React.useMemo(function () {\n      var selectedFlatRows = [];\n      rows.forEach(function (row) {\n        var isSelected = selectSubRows ? getRowIsSelected(row, selectedRowIds, getSubRows) : !!selectedRowIds[row.id];\n        row.isSelected = !!isSelected;\n        row.isSomeSelected = isSelected === null;\n\n        if (isSelected) {\n          selectedFlatRows.push(row);\n        }\n      });\n      return selectedFlatRows;\n    }, [rows, selectSubRows, selectedRowIds, getSubRows]);\n    var isAllRowsSelected = Boolean(Object.keys(nonGroupedRowsById).length && Object.keys(selectedRowIds).length);\n    var isAllPageRowsSelected = isAllRowsSelected;\n\n    if (isAllRowsSelected) {\n      if (Object.keys(nonGroupedRowsById).some(function (id) {\n        return !selectedRowIds[id];\n      })) {\n        isAllRowsSelected = false;\n      }\n    }\n\n    if (!isAllRowsSelected) {\n      if (page && page.length && page.some(function (_ref5) {\n        var id = _ref5.id;\n        return !selectedRowIds[id];\n      })) {\n        isAllPageRowsSelected = false;\n      }\n    }\n\n    var getAutoResetSelectedRows = useGetLatest(autoResetSelectedRows);\n    useMountedLayoutEffect(function () {\n      if (getAutoResetSelectedRows()) {\n        dispatch({\n          type: actions.resetSelectedRows\n        });\n      }\n    }, [dispatch, data]);\n    var toggleAllRowsSelected = React.useCallback(function (value) {\n      return dispatch({\n        type: actions.toggleAllRowsSelected,\n        value: value\n      });\n    }, [dispatch]);\n    var toggleAllPageRowsSelected = React.useCallback(function (value) {\n      return dispatch({\n        type: actions.toggleAllPageRowsSelected,\n        value: value\n      });\n    }, [dispatch]);\n    var toggleRowSelected = React.useCallback(function (id, value) {\n      return dispatch({\n        type: actions.toggleRowSelected,\n        id: id,\n        value: value\n      });\n    }, [dispatch]);\n    var getInstance = useGetLatest(instance);\n    var getToggleAllRowsSelectedProps = makePropGetter(getHooks().getToggleAllRowsSelectedProps, {\n      instance: getInstance()\n    });\n    var getToggleAllPageRowsSelectedProps = makePropGetter(getHooks().getToggleAllPageRowsSelectedProps, {\n      instance: getInstance()\n    });\n    Object.assign(instance, {\n      selectedFlatRows: selectedFlatRows,\n      isAllRowsSelected: isAllRowsSelected,\n      isAllPageRowsSelected: isAllPageRowsSelected,\n      toggleRowSelected: toggleRowSelected,\n      toggleAllRowsSelected: toggleAllRowsSelected,\n      getToggleAllRowsSelectedProps: getToggleAllRowsSelectedProps,\n      getToggleAllPageRowsSelectedProps: getToggleAllPageRowsSelectedProps,\n      toggleAllPageRowsSelected: toggleAllPageRowsSelected\n    });\n  }\n\n  function prepareRow$3(row, _ref6) {\n    var instance = _ref6.instance;\n\n    row.toggleRowSelected = function (set) {\n      return instance.toggleRowSelected(row.id, set);\n    };\n\n    row.getToggleRowSelectedProps = makePropGetter(instance.getHooks().getToggleRowSelectedProps, {\n      instance: instance,\n      row: row\n    });\n  }\n\n  function getRowIsSelected(row, selectedRowIds, getSubRows) {\n    if (selectedRowIds[row.id]) {\n      return true;\n    }\n\n    var subRows = getSubRows(row);\n\n    if (subRows && subRows.length) {\n      var allChildrenSelected = true;\n      var someSelected = false;\n      subRows.forEach(function (subRow) {\n        // Bail out early if we know both of these\n        if (someSelected && !allChildrenSelected) {\n          return;\n        }\n\n        if (getRowIsSelected(subRow, selectedRowIds, getSubRows)) {\n          someSelected = true;\n        } else {\n          allChildrenSelected = false;\n        }\n      });\n      return allChildrenSelected ? true : someSelected ? null : false;\n    }\n\n    return false;\n  }\n\n  var defaultInitialRowStateAccessor = function defaultInitialRowStateAccessor(row) {\n    return {};\n  };\n\n  var defaultInitialCellStateAccessor = function defaultInitialCellStateAccessor(cell) {\n    return {};\n  }; // Actions\n\n\n  actions.setRowState = 'setRowState';\n  actions.setCellState = 'setCellState';\n  actions.resetRowState = 'resetRowState';\n  var useRowState = function useRowState(hooks) {\n    hooks.stateReducers.push(reducer$9);\n    hooks.useInstance.push(useInstance$9);\n    hooks.prepareRow.push(prepareRow$4);\n  };\n  useRowState.pluginName = 'useRowState';\n\n  function reducer$9(state, action, previousState, instance) {\n    var _instance$initialRowS = instance.initialRowStateAccessor,\n        initialRowStateAccessor = _instance$initialRowS === void 0 ? defaultInitialRowStateAccessor : _instance$initialRowS,\n        _instance$initialCell = instance.initialCellStateAccessor,\n        initialCellStateAccessor = _instance$initialCell === void 0 ? defaultInitialCellStateAccessor : _instance$initialCell,\n        rowsById = instance.rowsById;\n\n    if (action.type === actions.init) {\n      return _extends({\n        rowState: {}\n      }, state);\n    }\n\n    if (action.type === actions.resetRowState) {\n      return _extends({}, state, {\n        rowState: instance.initialState.rowState || {}\n      });\n    }\n\n    if (action.type === actions.setRowState) {\n      var _extends2;\n\n      var rowId = action.rowId,\n          value = action.value;\n      var oldRowState = typeof state.rowState[rowId] !== 'undefined' ? state.rowState[rowId] : initialRowStateAccessor(rowsById[rowId]);\n      return _extends({}, state, {\n        rowState: _extends({}, state.rowState, (_extends2 = {}, _extends2[rowId] = functionalUpdate(value, oldRowState), _extends2))\n      });\n    }\n\n    if (action.type === actions.setCellState) {\n      var _oldRowState$cellStat, _rowsById$_rowId, _rowsById$_rowId$cell, _extends3, _extends4;\n\n      var _rowId = action.rowId,\n          columnId = action.columnId,\n          _value = action.value;\n\n      var _oldRowState = typeof state.rowState[_rowId] !== 'undefined' ? state.rowState[_rowId] : initialRowStateAccessor(rowsById[_rowId]);\n\n      var oldCellState = typeof (_oldRowState == null ? void 0 : (_oldRowState$cellStat = _oldRowState.cellState) == null ? void 0 : _oldRowState$cellStat[columnId]) !== 'undefined' ? _oldRowState.cellState[columnId] : initialCellStateAccessor((_rowsById$_rowId = rowsById[_rowId]) == null ? void 0 : (_rowsById$_rowId$cell = _rowsById$_rowId.cells) == null ? void 0 : _rowsById$_rowId$cell.find(function (cell) {\n        return cell.column.id === columnId;\n      }));\n      return _extends({}, state, {\n        rowState: _extends({}, state.rowState, (_extends4 = {}, _extends4[_rowId] = _extends({}, _oldRowState, {\n          cellState: _extends({}, _oldRowState.cellState || {}, (_extends3 = {}, _extends3[columnId] = functionalUpdate(_value, oldCellState), _extends3))\n        }), _extends4))\n      });\n    }\n  }\n\n  function useInstance$9(instance) {\n    var _instance$autoResetRo = instance.autoResetRowState,\n        autoResetRowState = _instance$autoResetRo === void 0 ? true : _instance$autoResetRo,\n        data = instance.data,\n        dispatch = instance.dispatch;\n    var setRowState = React.useCallback(function (rowId, value) {\n      return dispatch({\n        type: actions.setRowState,\n        rowId: rowId,\n        value: value\n      });\n    }, [dispatch]);\n    var setCellState = React.useCallback(function (rowId, columnId, value) {\n      return dispatch({\n        type: actions.setCellState,\n        rowId: rowId,\n        columnId: columnId,\n        value: value\n      });\n    }, [dispatch]);\n    var getAutoResetRowState = useGetLatest(autoResetRowState);\n    useMountedLayoutEffect(function () {\n      if (getAutoResetRowState()) {\n        dispatch({\n          type: actions.resetRowState\n        });\n      }\n    }, [data]);\n    Object.assign(instance, {\n      setRowState: setRowState,\n      setCellState: setCellState\n    });\n  }\n\n  function prepareRow$4(row, _ref) {\n    var instance = _ref.instance;\n    var _instance$initialRowS2 = instance.initialRowStateAccessor,\n        initialRowStateAccessor = _instance$initialRowS2 === void 0 ? defaultInitialRowStateAccessor : _instance$initialRowS2,\n        _instance$initialCell2 = instance.initialCellStateAccessor,\n        initialCellStateAccessor = _instance$initialCell2 === void 0 ? defaultInitialCellStateAccessor : _instance$initialCell2,\n        rowState = instance.state.rowState;\n\n    if (row) {\n      row.state = typeof rowState[row.id] !== 'undefined' ? rowState[row.id] : initialRowStateAccessor(row);\n\n      row.setState = function (updater) {\n        return instance.setRowState(row.id, updater);\n      };\n\n      row.cells.forEach(function (cell) {\n        if (!row.state.cellState) {\n          row.state.cellState = {};\n        }\n\n        cell.state = typeof row.state.cellState[cell.column.id] !== 'undefined' ? row.state.cellState[cell.column.id] : initialCellStateAccessor(cell);\n\n        cell.setState = function (updater) {\n          return instance.setCellState(row.id, cell.column.id, updater);\n        };\n      });\n    }\n  }\n\n  actions.resetColumnOrder = 'resetColumnOrder';\n  actions.setColumnOrder = 'setColumnOrder';\n  var useColumnOrder = function useColumnOrder(hooks) {\n    hooks.stateReducers.push(reducer$a);\n    hooks.visibleColumnsDeps.push(function (deps, _ref) {\n      var instance = _ref.instance;\n      return [].concat(deps, [instance.state.columnOrder]);\n    });\n    hooks.visibleColumns.push(visibleColumns$2);\n    hooks.useInstance.push(useInstance$a);\n  };\n  useColumnOrder.pluginName = 'useColumnOrder';\n\n  function reducer$a(state, action, previousState, instance) {\n    if (action.type === actions.init) {\n      return _extends({\n        columnOrder: []\n      }, state);\n    }\n\n    if (action.type === actions.resetColumnOrder) {\n      return _extends({}, state, {\n        columnOrder: instance.initialState.columnOrder || []\n      });\n    }\n\n    if (action.type === actions.setColumnOrder) {\n      return _extends({}, state, {\n        columnOrder: functionalUpdate(action.columnOrder, state.columnOrder)\n      });\n    }\n  }\n\n  function visibleColumns$2(columns, _ref2) {\n    var columnOrder = _ref2.instance.state.columnOrder;\n\n    // If there is no order, return the normal columns\n    if (!columnOrder || !columnOrder.length) {\n      return columns;\n    }\n\n    var columnOrderCopy = [].concat(columnOrder); // If there is an order, make a copy of the columns\n\n    var columnsCopy = [].concat(columns); // And make a new ordered array of the columns\n\n    var columnsInOrder = []; // Loop over the columns and place them in order into the new array\n\n    var _loop = function _loop() {\n      var targetColumnId = columnOrderCopy.shift();\n      var foundIndex = columnsCopy.findIndex(function (d) {\n        return d.id === targetColumnId;\n      });\n\n      if (foundIndex > -1) {\n        columnsInOrder.push(columnsCopy.splice(foundIndex, 1)[0]);\n      }\n    };\n\n    while (columnsCopy.length && columnOrderCopy.length) {\n      _loop();\n    } // If there are any columns left, add them to the end\n\n\n    return [].concat(columnsInOrder, columnsCopy);\n  }\n\n  function useInstance$a(instance) {\n    var dispatch = instance.dispatch;\n    instance.setColumnOrder = React.useCallback(function (columnOrder) {\n      return dispatch({\n        type: actions.setColumnOrder,\n        columnOrder: columnOrder\n      });\n    }, [dispatch]);\n  }\n\n  defaultColumn.canResize = true; // Actions\n\n  actions.columnStartResizing = 'columnStartResizing';\n  actions.columnResizing = 'columnResizing';\n  actions.columnDoneResizing = 'columnDoneResizing';\n  actions.resetResize = 'resetResize';\n  var useResizeColumns = function useResizeColumns(hooks) {\n    hooks.getResizerProps = [defaultGetResizerProps];\n    hooks.getHeaderProps.push({\n      style: {\n        position: 'relative'\n      }\n    });\n    hooks.stateReducers.push(reducer$b);\n    hooks.useInstance.push(useInstance$b);\n    hooks.useInstanceBeforeDimensions.push(useInstanceBeforeDimensions$1);\n  };\n\n  var defaultGetResizerProps = function defaultGetResizerProps(props, _ref) {\n    var instance = _ref.instance,\n        header = _ref.header;\n    var dispatch = instance.dispatch;\n\n    var onResizeStart = function onResizeStart(e, header) {\n      var isTouchEvent = false;\n\n      if (e.type === 'touchstart') {\n        // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n        if (e.touches && e.touches.length > 1) {\n          return;\n        }\n\n        isTouchEvent = true;\n      }\n\n      var headersToResize = getLeafHeaders(header);\n      var headerIdWidths = headersToResize.map(function (d) {\n        return [d.id, d.totalWidth];\n      });\n      var clientX = isTouchEvent ? Math.round(e.touches[0].clientX) : e.clientX;\n      var raf;\n      var mostRecentClientX;\n\n      var dispatchEnd = function dispatchEnd() {\n        window.cancelAnimationFrame(raf);\n        raf = null;\n        dispatch({\n          type: actions.columnDoneResizing\n        });\n      };\n\n      var dispatchMove = function dispatchMove() {\n        window.cancelAnimationFrame(raf);\n        raf = null;\n        dispatch({\n          type: actions.columnResizing,\n          clientX: mostRecentClientX\n        });\n      };\n\n      var scheduleDispatchMoveOnNextAnimationFrame = function scheduleDispatchMoveOnNextAnimationFrame(clientXPos) {\n        mostRecentClientX = clientXPos;\n\n        if (!raf) {\n          raf = window.requestAnimationFrame(dispatchMove);\n        }\n      };\n\n      var handlersAndEvents = {\n        mouse: {\n          moveEvent: 'mousemove',\n          moveHandler: function moveHandler(e) {\n            return scheduleDispatchMoveOnNextAnimationFrame(e.clientX);\n          },\n          upEvent: 'mouseup',\n          upHandler: function upHandler(e) {\n            document.removeEventListener('mousemove', handlersAndEvents.mouse.moveHandler);\n            document.removeEventListener('mouseup', handlersAndEvents.mouse.upHandler);\n            dispatchEnd();\n          }\n        },\n        touch: {\n          moveEvent: 'touchmove',\n          moveHandler: function moveHandler(e) {\n            if (e.cancelable) {\n              e.preventDefault();\n              e.stopPropagation();\n            }\n\n            scheduleDispatchMoveOnNextAnimationFrame(e.touches[0].clientX);\n            return false;\n          },\n          upEvent: 'touchend',\n          upHandler: function upHandler(e) {\n            document.removeEventListener(handlersAndEvents.touch.moveEvent, handlersAndEvents.touch.moveHandler);\n            document.removeEventListener(handlersAndEvents.touch.upEvent, handlersAndEvents.touch.moveHandler);\n            dispatchEnd();\n          }\n        }\n      };\n      var events = isTouchEvent ? handlersAndEvents.touch : handlersAndEvents.mouse;\n      var passiveIfSupported = passiveEventSupported() ? {\n        passive: false\n      } : false;\n      document.addEventListener(events.moveEvent, events.moveHandler, passiveIfSupported);\n      document.addEventListener(events.upEvent, events.upHandler, passiveIfSupported);\n      dispatch({\n        type: actions.columnStartResizing,\n        columnId: header.id,\n        columnWidth: header.totalWidth,\n        headerIdWidths: headerIdWidths,\n        clientX: clientX\n      });\n    };\n\n    return [props, {\n      onMouseDown: function onMouseDown(e) {\n        return e.persist() || onResizeStart(e, header);\n      },\n      onTouchStart: function onTouchStart(e) {\n        return e.persist() || onResizeStart(e, header);\n      },\n      style: {\n        cursor: 'col-resize'\n      },\n      draggable: false,\n      role: 'separator'\n    }];\n  };\n\n  useResizeColumns.pluginName = 'useResizeColumns';\n\n  function reducer$b(state, action) {\n    if (action.type === actions.init) {\n      return _extends({\n        columnResizing: {\n          columnWidths: {}\n        }\n      }, state);\n    }\n\n    if (action.type === actions.resetResize) {\n      return _extends({}, state, {\n        columnResizing: {\n          columnWidths: {}\n        }\n      });\n    }\n\n    if (action.type === actions.columnStartResizing) {\n      var clientX = action.clientX,\n          columnId = action.columnId,\n          columnWidth = action.columnWidth,\n          headerIdWidths = action.headerIdWidths;\n      return _extends({}, state, {\n        columnResizing: _extends({}, state.columnResizing, {\n          startX: clientX,\n          headerIdWidths: headerIdWidths,\n          columnWidth: columnWidth,\n          isResizingColumn: columnId\n        })\n      });\n    }\n\n    if (action.type === actions.columnResizing) {\n      var _clientX = action.clientX;\n\n      var _state$columnResizing = state.columnResizing,\n          startX = _state$columnResizing.startX,\n          _columnWidth = _state$columnResizing.columnWidth,\n          _state$columnResizing2 = _state$columnResizing.headerIdWidths,\n          _headerIdWidths = _state$columnResizing2 === void 0 ? [] : _state$columnResizing2;\n\n      var deltaX = _clientX - startX;\n      var percentageDeltaX = deltaX / _columnWidth;\n      var newColumnWidths = {};\n\n      _headerIdWidths.forEach(function (_ref2) {\n        var headerId = _ref2[0],\n            headerWidth = _ref2[1];\n        newColumnWidths[headerId] = Math.max(headerWidth + headerWidth * percentageDeltaX, 0);\n      });\n\n      return _extends({}, state, {\n        columnResizing: _extends({}, state.columnResizing, {\n          columnWidths: _extends({}, state.columnResizing.columnWidths, {}, newColumnWidths)\n        })\n      });\n    }\n\n    if (action.type === actions.columnDoneResizing) {\n      return _extends({}, state, {\n        columnResizing: _extends({}, state.columnResizing, {\n          startX: null,\n          isResizingColumn: null\n        })\n      });\n    }\n  }\n\n  var useInstanceBeforeDimensions$1 = function useInstanceBeforeDimensions(instance) {\n    var flatHeaders = instance.flatHeaders,\n        disableResizing = instance.disableResizing,\n        getHooks = instance.getHooks,\n        columnResizing = instance.state.columnResizing;\n    var getInstance = useGetLatest(instance);\n    flatHeaders.forEach(function (header) {\n      var canResize = getFirstDefined(header.disableResizing === true ? false : undefined, disableResizing === true ? false : undefined, true);\n      header.canResize = canResize;\n      header.width = columnResizing.columnWidths[header.id] || header.originalWidth || header.width;\n      header.isResizing = columnResizing.isResizingColumn === header.id;\n\n      if (canResize) {\n        header.getResizerProps = makePropGetter(getHooks().getResizerProps, {\n          instance: getInstance(),\n          header: header\n        });\n      }\n    });\n  };\n\n  function useInstance$b(instance) {\n    var plugins = instance.plugins,\n        dispatch = instance.dispatch,\n        _instance$autoResetRe = instance.autoResetResize,\n        autoResetResize = _instance$autoResetRe === void 0 ? true : _instance$autoResetRe,\n        columns = instance.columns;\n    ensurePluginOrder(plugins, ['useAbsoluteLayout'], 'useResizeColumns');\n    var getAutoResetResize = useGetLatest(autoResetResize);\n    useMountedLayoutEffect(function () {\n      if (getAutoResetResize()) {\n        dispatch({\n          type: actions.resetResize\n        });\n      }\n    }, [columns]);\n    var resetResizing = React.useCallback(function () {\n      return dispatch({\n        type: actions.resetResize\n      });\n    }, [dispatch]);\n    Object.assign(instance, {\n      resetResizing: resetResizing\n    });\n  }\n\n  function getLeafHeaders(header) {\n    var leafHeaders = [];\n\n    var recurseHeader = function recurseHeader(header) {\n      if (header.columns && header.columns.length) {\n        header.columns.map(recurseHeader);\n      }\n\n      leafHeaders.push(header);\n    };\n\n    recurseHeader(header);\n    return leafHeaders;\n  }\n\n  var cellStyles = {\n    position: 'absolute',\n    top: 0\n  };\n  var useAbsoluteLayout = function useAbsoluteLayout(hooks) {\n    hooks.getTableBodyProps.push(getRowStyles);\n    hooks.getRowProps.push(getRowStyles);\n    hooks.getHeaderGroupProps.push(getRowStyles);\n    hooks.getFooterGroupProps.push(getRowStyles);\n    hooks.getHeaderProps.push(function (props, _ref) {\n      var column = _ref.column;\n      return [props, {\n        style: _extends({}, cellStyles, {\n          left: column.totalLeft + \"px\",\n          width: column.totalWidth + \"px\"\n        })\n      }];\n    });\n    hooks.getCellProps.push(function (props, _ref2) {\n      var cell = _ref2.cell;\n      return [props, {\n        style: _extends({}, cellStyles, {\n          left: cell.column.totalLeft + \"px\",\n          width: cell.column.totalWidth + \"px\"\n        })\n      }];\n    });\n    hooks.getFooterProps.push(function (props, _ref3) {\n      var column = _ref3.column;\n      return [props, {\n        style: _extends({}, cellStyles, {\n          left: column.totalLeft + \"px\",\n          width: column.totalWidth + \"px\"\n        })\n      }];\n    });\n  };\n  useAbsoluteLayout.pluginName = 'useAbsoluteLayout';\n\n  var getRowStyles = function getRowStyles(props, _ref4) {\n    var instance = _ref4.instance;\n    return [props, {\n      style: {\n        position: 'relative',\n        width: instance.totalColumnsWidth + \"px\"\n      }\n    }];\n  };\n\n  var cellStyles$1 = {\n    display: 'inline-block',\n    boxSizing: 'border-box'\n  };\n\n  var getRowStyles$1 = function getRowStyles(props, _ref) {\n    var instance = _ref.instance;\n    return [props, {\n      style: {\n        display: 'flex',\n        width: instance.totalColumnsWidth + \"px\"\n      }\n    }];\n  };\n\n  var useBlockLayout = function useBlockLayout(hooks) {\n    hooks.getRowProps.push(getRowStyles$1);\n    hooks.getHeaderGroupProps.push(getRowStyles$1);\n    hooks.getFooterGroupProps.push(getRowStyles$1);\n    hooks.getHeaderProps.push(function (props, _ref2) {\n      var column = _ref2.column;\n      return [props, {\n        style: _extends({}, cellStyles$1, {\n          width: column.totalWidth + \"px\"\n        })\n      }];\n    });\n    hooks.getCellProps.push(function (props, _ref3) {\n      var cell = _ref3.cell;\n      return [props, {\n        style: _extends({}, cellStyles$1, {\n          width: cell.column.totalWidth + \"px\"\n        })\n      }];\n    });\n    hooks.getFooterProps.push(function (props, _ref4) {\n      var column = _ref4.column;\n      return [props, {\n        style: _extends({}, cellStyles$1, {\n          width: column.totalWidth + \"px\"\n        })\n      }];\n    });\n  };\n  useBlockLayout.pluginName = 'useBlockLayout';\n\n  function useFlexLayout(hooks) {\n    hooks.getTableProps.push(getTableProps);\n    hooks.getRowProps.push(getRowStyles$2);\n    hooks.getHeaderGroupProps.push(getRowStyles$2);\n    hooks.getFooterGroupProps.push(getRowStyles$2);\n    hooks.getHeaderProps.push(getHeaderProps);\n    hooks.getCellProps.push(getCellProps);\n    hooks.getFooterProps.push(getFooterProps);\n  }\n  useFlexLayout.pluginName = 'useFlexLayout';\n\n  var getTableProps = function getTableProps(props, _ref) {\n    var instance = _ref.instance;\n    return [props, {\n      style: {\n        minWidth: instance.totalColumnsMinWidth + \"px\"\n      }\n    }];\n  };\n\n  var getRowStyles$2 = function getRowStyles(props, _ref2) {\n    var instance = _ref2.instance;\n    return [props, {\n      style: {\n        display: 'flex',\n        flex: '1 0 auto',\n        minWidth: instance.totalColumnsMinWidth + \"px\"\n      }\n    }];\n  };\n\n  var getHeaderProps = function getHeaderProps(props, _ref3) {\n    var column = _ref3.column;\n    return [props, {\n      style: {\n        boxSizing: 'border-box',\n        flex: column.totalFlexWidth ? column.totalFlexWidth + \" 0 auto\" : undefined,\n        minWidth: column.totalMinWidth + \"px\",\n        width: column.totalWidth + \"px\"\n      }\n    }];\n  };\n\n  var getCellProps = function getCellProps(props, _ref4) {\n    var cell = _ref4.cell;\n    return [props, {\n      style: {\n        boxSizing: 'border-box',\n        flex: cell.column.totalFlexWidth + \" 0 auto\",\n        minWidth: cell.column.totalMinWidth + \"px\",\n        width: cell.column.totalWidth + \"px\"\n      }\n    }];\n  };\n\n  var getFooterProps = function getFooterProps(props, _ref5) {\n    var column = _ref5.column;\n    return [props, {\n      style: {\n        boxSizing: 'border-box',\n        flex: column.totalFlexWidth ? column.totalFlexWidth + \" 0 auto\" : undefined,\n        minWidth: column.totalMinWidth + \"px\",\n        width: column.totalWidth + \"px\"\n      }\n    }];\n  };\n\n  actions.columnStartResizing = 'columnStartResizing';\n  actions.columnResizing = 'columnResizing';\n  actions.columnDoneResizing = 'columnDoneResizing';\n  actions.resetResize = 'resetResize';\n  function useGridLayout(hooks) {\n    hooks.stateReducers.push(reducer$c);\n    hooks.getTableProps.push(getTableProps$1);\n    hooks.getHeaderProps.push(getHeaderProps$1);\n    hooks.getRowProps.push(getRowProps);\n  }\n  useGridLayout.pluginName = 'useGridLayout';\n\n  var getTableProps$1 = function getTableProps(props, _ref) {\n    var instance = _ref.instance;\n    var gridTemplateColumns = instance.visibleColumns.map(function (column) {\n      var _instance$state$colum;\n\n      if (instance.state.gridLayout.columnWidths[column.id]) return instance.state.gridLayout.columnWidths[column.id] + \"px\"; // When resizing, lock the width of all unset columns\n      // instead of using user-provided width or defaultColumn width,\n      // which could potentially be 'auto' or 'fr' units that don't scale linearly\n\n      if ((_instance$state$colum = instance.state.columnResizing) == null ? void 0 : _instance$state$colum.isResizingColumn) return instance.state.gridLayout.startWidths[column.id] + \"px\";\n      if (typeof column.width === 'number') return column.width + \"px\";\n      return column.width;\n    });\n    return [props, {\n      style: {\n        display: \"grid\",\n        gridTemplateColumns: gridTemplateColumns.join(\" \")\n      }\n    }];\n  };\n\n  var getHeaderProps$1 = function getHeaderProps(props, _ref2) {\n    var column = _ref2.column;\n    return [props, {\n      id: \"header-cell-\" + column.id,\n      style: {\n        position: \"sticky\",\n        //enables a scroll wrapper to be placed around the table and have sticky headers\n        gridColumn: \"span \" + column.totalVisibleHeaderCount\n      }\n    }];\n  };\n\n  var getRowProps = function getRowProps(props, _ref3) {\n    var row = _ref3.row;\n\n    if (row.isExpanded) {\n      return [props, {\n        style: {\n          gridColumn: \"1 / \" + (row.cells.length + 1)\n        }\n      }];\n    }\n\n    return [props, {}];\n  };\n\n  function reducer$c(state, action, previousState, instance) {\n    if (action.type === actions.init) {\n      return _extends({\n        gridLayout: {\n          columnWidths: {}\n        }\n      }, state);\n    }\n\n    if (action.type === actions.resetResize) {\n      return _extends({}, state, {\n        gridLayout: {\n          columnWidths: {}\n        }\n      });\n    }\n\n    if (action.type === actions.columnStartResizing) {\n      var columnId = action.columnId,\n          headerIdWidths = action.headerIdWidths;\n      var columnWidth = getElementWidth(columnId);\n\n      if (columnWidth !== undefined) {\n        var startWidths = instance.visibleColumns.reduce(function (acc, column) {\n          var _extends2;\n\n          return _extends({}, acc, (_extends2 = {}, _extends2[column.id] = getElementWidth(column.id), _extends2));\n        }, {});\n        var minWidths = instance.visibleColumns.reduce(function (acc, column) {\n          var _extends3;\n\n          return _extends({}, acc, (_extends3 = {}, _extends3[column.id] = column.minWidth, _extends3));\n        }, {});\n        var maxWidths = instance.visibleColumns.reduce(function (acc, column) {\n          var _extends4;\n\n          return _extends({}, acc, (_extends4 = {}, _extends4[column.id] = column.maxWidth, _extends4));\n        }, {});\n        var headerIdGridWidths = headerIdWidths.map(function (_ref4) {\n          var headerId = _ref4[0];\n          return [headerId, getElementWidth(headerId)];\n        });\n        return _extends({}, state, {\n          gridLayout: _extends({}, state.gridLayout, {\n            startWidths: startWidths,\n            minWidths: minWidths,\n            maxWidths: maxWidths,\n            headerIdGridWidths: headerIdGridWidths,\n            columnWidth: columnWidth\n          })\n        });\n      } else {\n        return state;\n      }\n    }\n\n    if (action.type === actions.columnResizing) {\n      var clientX = action.clientX;\n      var startX = state.columnResizing.startX;\n\n      var _state$gridLayout = state.gridLayout,\n          _columnWidth = _state$gridLayout.columnWidth,\n          _minWidths = _state$gridLayout.minWidths,\n          _maxWidths = _state$gridLayout.maxWidths,\n          _state$gridLayout$hea = _state$gridLayout.headerIdGridWidths,\n          _headerIdGridWidths = _state$gridLayout$hea === void 0 ? [] : _state$gridLayout$hea;\n\n      var deltaX = clientX - startX;\n      var percentageDeltaX = deltaX / _columnWidth;\n      var newColumnWidths = {};\n\n      _headerIdGridWidths.forEach(function (_ref5) {\n        var headerId = _ref5[0],\n            headerWidth = _ref5[1];\n        newColumnWidths[headerId] = Math.min(Math.max(_minWidths[headerId], headerWidth + headerWidth * percentageDeltaX), _maxWidths[headerId]);\n      });\n\n      return _extends({}, state, {\n        gridLayout: _extends({}, state.gridLayout, {\n          columnWidths: _extends({}, state.gridLayout.columnWidths, {}, newColumnWidths)\n        })\n      });\n    }\n\n    if (action.type === actions.columnDoneResizing) {\n      return _extends({}, state, {\n        gridLayout: _extends({}, state.gridLayout, {\n          startWidths: {},\n          minWidths: {},\n          maxWidths: {}\n        })\n      });\n    }\n  }\n\n  function getElementWidth(columnId) {\n    var _document$getElementB;\n\n    var width = (_document$getElementB = document.getElementById(\"header-cell-\" + columnId)) == null ? void 0 : _document$getElementB.offsetWidth;\n\n    if (width !== undefined) {\n      return width;\n    }\n  }\n\n  exports._UNSTABLE_usePivotColumns = _UNSTABLE_usePivotColumns;\n  exports.actions = actions;\n  exports.defaultColumn = defaultColumn;\n  exports.defaultGroupByFn = defaultGroupByFn;\n  exports.defaultOrderByFn = defaultOrderByFn;\n  exports.defaultRenderer = defaultRenderer;\n  exports.emptyRenderer = emptyRenderer;\n  exports.ensurePluginOrder = ensurePluginOrder;\n  exports.flexRender = flexRender;\n  exports.functionalUpdate = functionalUpdate;\n  exports.loopHooks = loopHooks;\n  exports.makePropGetter = makePropGetter;\n  exports.makeRenderer = makeRenderer;\n  exports.reduceHooks = reduceHooks;\n  exports.safeUseLayoutEffect = safeUseLayoutEffect;\n  exports.useAbsoluteLayout = useAbsoluteLayout;\n  exports.useAsyncDebounce = useAsyncDebounce;\n  exports.useBlockLayout = useBlockLayout;\n  exports.useColumnOrder = useColumnOrder;\n  exports.useExpanded = useExpanded;\n  exports.useFilters = useFilters;\n  exports.useFlexLayout = useFlexLayout;\n  exports.useGetLatest = useGetLatest;\n  exports.useGlobalFilter = useGlobalFilter;\n  exports.useGridLayout = useGridLayout;\n  exports.useGroupBy = useGroupBy;\n  exports.useMountedLayoutEffect = useMountedLayoutEffect;\n  exports.usePagination = usePagination;\n  exports.useResizeColumns = useResizeColumns;\n  exports.useRowSelect = useRowSelect;\n  exports.useRowState = useRowState;\n  exports.useSortBy = useSortBy;\n  exports.useTable = useTable;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=react-table.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFibGUvZGlzdC9yZWFjdC10YWJsZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEVBQUUsS0FBNEQsb0JBQW9CLG1CQUFPLENBQUMsd0dBQU87QUFDakcsRUFBRSxDQUN3RTtBQUMxRSxDQUFDLG9DQUFvQzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixXQUFXOztBQUVwQztBQUNBLCtDQUErQyxtQkFBbUIsSUFBSSxhQUFhO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsTUFB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QXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx3QkFBd0I7QUFDeEI7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7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Q0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFNBQVM7QUFDVDs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPLEdBQUc7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7OztBQUdaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYOztBQUVBLCtDQUErQzs7QUFFL0Msc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQsd0VBQXdFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRzs7QUFFVjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtGQUFrRjs7QUFFbEYscUVBQXFFOztBQUVyRTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOzs7QUFHdEM7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx3QkFBd0I7QUFDeEI7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBLE9BQU87QUFDUCxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsMkJBQTJCOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTs7QUFFYjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLGVBQWU7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLGVBQWU7O0FBRXBCLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUVBQXVFOztBQUV2RTtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsSUFBSTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFNBQVM7QUFDVDs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDOztBQUV6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asd0JBQXdCO0FBQ3hCO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztB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QUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhIQUE4SDtBQUM5SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixzQkFBc0I7QUFDbEQsU0FBUyxJQUFJO0FBQ2I7QUFDQTs7QUFFQSw0QkFBNEIsc0JBQXNCO0FBQ2xELFNBQVMsSUFBSTtBQUNiO0FBQ0E7O0FBRUEsNEJBQTRCLHNCQUFzQjtBQUNsRCxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMEJBQTBCO0FBQzFCLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCx3QkFBd0I7QUFDeEIsK0JBQStCO0FBQy9CLG1DQUFtQyxtQ0FBbUM7QUFDdEUsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QiwrQkFBK0I7QUFDL0IseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsYUFBYTs7QUFFOUQsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2VhcmNoLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRhYmxlL2Rpc3QvcmVhY3QtdGFibGUuZGV2ZWxvcG1lbnQuanM/ZWEyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3JlYWN0JykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdyZWFjdCddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuUmVhY3RUYWJsZSA9IHt9LCBnbG9iYWwuUmVhY3QpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCBSZWFjdCkgeyAndXNlIHN0cmljdCc7XG5cbiAgUmVhY3QgPSBSZWFjdCAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoUmVhY3QsICdkZWZhdWx0JykgPyBSZWFjdFsnZGVmYXVsdCddIDogUmVhY3Q7XG5cbiAgZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICAgIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcblxuICAgIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgICAgaWYgKHR5cGVvZiByZXMgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG5cbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xuICB9XG5cbiAgdmFyIHJlbmRlckVyciA9ICdSZW5kZXJlciBFcnJvciDimJ3vuI8nO1xuICB2YXIgYWN0aW9ucyA9IHtcbiAgICBpbml0OiAnaW5pdCdcbiAgfTtcbiAgdmFyIGRlZmF1bHRSZW5kZXJlciA9IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJlcihfcmVmKSB7XG4gICAgdmFyIF9yZWYkdmFsdWUgPSBfcmVmLnZhbHVlLFxuICAgICAgICB2YWx1ZSA9IF9yZWYkdmFsdWUgPT09IHZvaWQgMCA/ICcnIDogX3JlZiR2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIHZhciBlbXB0eVJlbmRlcmVyID0gZnVuY3Rpb24gZW1wdHlSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgXCJcXHhBMFwiKTtcbiAgfTtcbiAgdmFyIGRlZmF1bHRDb2x1bW4gPSB7XG4gICAgQ2VsbDogZGVmYXVsdFJlbmRlcmVyLFxuICAgIHdpZHRoOiAxNTAsXG4gICAgbWluV2lkdGg6IDAsXG4gICAgbWF4V2lkdGg6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIH07XG5cbiAgZnVuY3Rpb24gbWVyZ2VQcm9wcygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcHJvcExpc3QgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBwcm9wTGlzdFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcExpc3QucmVkdWNlKGZ1bmN0aW9uIChwcm9wcywgbmV4dCkge1xuICAgICAgdmFyIHN0eWxlID0gbmV4dC5zdHlsZSxcbiAgICAgICAgICBjbGFzc05hbWUgPSBuZXh0LmNsYXNzTmFtZSxcbiAgICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UobmV4dCwgW1wic3R5bGVcIiwgXCJjbGFzc05hbWVcIl0pO1xuXG4gICAgICBwcm9wcyA9IF9leHRlbmRzKHt9LCBwcm9wcywge30sIHJlc3QpO1xuXG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgcHJvcHMuc3R5bGUgPSBwcm9wcy5zdHlsZSA/IF9leHRlbmRzKHt9LCBwcm9wcy5zdHlsZSB8fCB7fSwge30sIHN0eWxlIHx8IHt9KSA6IHN0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIHByb3BzLmNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSA/IHByb3BzLmNsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZSA6IGNsYXNzTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BzLmNsYXNzTmFtZSA9PT0gJycpIHtcbiAgICAgICAgZGVsZXRlIHByb3BzLmNsYXNzTmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVByb3BHZXR0ZXIocHJldlByb3BzLCB1c2VyUHJvcHMsIG1ldGEpIHtcbiAgICAvLyBIYW5kbGUgYSBsYW1iZGEsIHBhc3MgaXQgdGhlIHByZXZpb3VzIHByb3BzXG4gICAgaWYgKHR5cGVvZiB1c2VyUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBoYW5kbGVQcm9wR2V0dGVyKHt9LCB1c2VyUHJvcHMocHJldlByb3BzLCBtZXRhKSk7XG4gICAgfSAvLyBIYW5kbGUgYW4gYXJyYXksIG1lcmdlIGVhY2ggaXRlbSBhcyBzZXBhcmF0ZSBwcm9wc1xuXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh1c2VyUHJvcHMpKSB7XG4gICAgICByZXR1cm4gbWVyZ2VQcm9wcy5hcHBseSh2b2lkIDAsIFtwcmV2UHJvcHNdLmNvbmNhdCh1c2VyUHJvcHMpKTtcbiAgICB9IC8vIEhhbmRsZSBhbiBvYmplY3QgYnkgZGVmYXVsdCwgbWVyZ2UgdGhlIHR3byBvYmplY3RzXG5cblxuICAgIHJldHVybiBtZXJnZVByb3BzKHByZXZQcm9wcywgdXNlclByb3BzKTtcbiAgfVxuXG4gIHZhciBtYWtlUHJvcEdldHRlciA9IGZ1bmN0aW9uIG1ha2VQcm9wR2V0dGVyKGhvb2tzLCBtZXRhKSB7XG4gICAgaWYgKG1ldGEgPT09IHZvaWQgMCkge1xuICAgICAgbWV0YSA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAodXNlclByb3BzKSB7XG4gICAgICBpZiAodXNlclByb3BzID09PSB2b2lkIDApIHtcbiAgICAgICAgdXNlclByb3BzID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXS5jb25jYXQoaG9va3MsIFt1c2VyUHJvcHNdKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVByb3BHZXR0ZXIocHJldiwgbmV4dCwgX2V4dGVuZHMoe30sIG1ldGEsIHtcbiAgICAgICAgICB1c2VyUHJvcHM6IHVzZXJQcm9wc1xuICAgICAgICB9KSk7XG4gICAgICB9LCB7fSk7XG4gICAgfTtcbiAgfTtcbiAgdmFyIHJlZHVjZUhvb2tzID0gZnVuY3Rpb24gcmVkdWNlSG9va3MoaG9va3MsIGluaXRpYWwsIG1ldGEsIGFsbG93VW5kZWZpbmVkKSB7XG4gICAgaWYgKG1ldGEgPT09IHZvaWQgMCkge1xuICAgICAgbWV0YSA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBob29rcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIG5leHQpIHtcbiAgICAgIHZhciBuZXh0VmFsdWUgPSBuZXh0KHByZXYsIG1ldGEpO1xuXG4gICAgICB7XG4gICAgICAgIGlmICghYWxsb3dVbmRlZmluZWQgJiYgdHlwZW9mIG5leHRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb25zb2xlLmluZm8obmV4dCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBUYWJsZTogQSByZWR1Y2VyIGhvb2sg4pid77iPIGp1c3QgcmV0dXJuZWQgdW5kZWZpbmVkISBUaGlzIGlzIG5vdCBhbGxvd2VkLicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0VmFsdWU7XG4gICAgfSwgaW5pdGlhbCk7XG4gIH07XG4gIHZhciBsb29wSG9va3MgPSBmdW5jdGlvbiBsb29wSG9va3MoaG9va3MsIGNvbnRleHQsIG1ldGEpIHtcbiAgICBpZiAobWV0YSA9PT0gdm9pZCAwKSB7XG4gICAgICBtZXRhID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgIHZhciBuZXh0VmFsdWUgPSBob29rKGNvbnRleHQsIG1ldGEpO1xuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV4dFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbnNvbGUuaW5mbyhob29rLCBuZXh0VmFsdWUpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3QgVGFibGU6IEEgbG9vcC10eXBlIGhvb2sg4pid77iPIGp1c3QgcmV0dXJuZWQgYSB2YWx1ZSEgVGhpcyBpcyBub3QgYWxsb3dlZC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBlbnN1cmVQbHVnaW5PcmRlcihwbHVnaW5zLCBiZWZvcmVzLCBwbHVnaW5OYW1lLCBhZnRlcnMpIHtcbiAgICBpZiAoIGFmdGVycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmaW5pbmcgcGx1Z2lucyBpbiB0aGUgXFxcImFmdGVyXFxcIiBzZWN0aW9uIG9mIGVuc3VyZVBsdWdpbk9yZGVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgKHNlZSBwbHVnaW4gXCIgKyBwbHVnaW5OYW1lICsgXCIpXCIpO1xuICAgIH1cblxuICAgIHZhciBwbHVnaW5JbmRleCA9IHBsdWdpbnMuZmluZEluZGV4KGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHJldHVybiBwbHVnaW4ucGx1Z2luTmFtZSA9PT0gcGx1Z2luTmFtZTtcbiAgICB9KTtcblxuICAgIGlmIChwbHVnaW5JbmRleCA9PT0gLTEpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHBsdWdpbiBcXFwiXCIgKyBwbHVnaW5OYW1lICsgXCJcXFwiIHdhcyBub3QgZm91bmQgaW4gdGhlIHBsdWdpbiBsaXN0IVxcblRoaXMgdXN1YWxseSBtZWFucyB5b3UgbmVlZCB0byBuZWVkIHRvIG5hbWUgeW91ciBwbHVnaW4gaG9vayBieSBzZXR0aW5nIHRoZSAncGx1Z2luTmFtZScgcHJvcGVydHkgb2YgdGhlIGhvb2sgZnVuY3Rpb24sIGVnOlxcblxcbiAgXCIgKyBwbHVnaW5OYW1lICsgXCIucGx1Z2luTmFtZSA9ICdcIiArIHBsdWdpbk5hbWUgKyBcIidcXG5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmVmb3Jlcy5mb3JFYWNoKGZ1bmN0aW9uIChiZWZvcmUpIHtcbiAgICAgIHZhciBiZWZvcmVJbmRleCA9IHBsdWdpbnMuZmluZEluZGV4KGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbi5wbHVnaW5OYW1lID09PSBiZWZvcmU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGJlZm9yZUluZGV4ID4gLTEgJiYgYmVmb3JlSW5kZXggPiBwbHVnaW5JbmRleCkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QgVGFibGU6IFRoZSBcIiArIHBsdWdpbk5hbWUgKyBcIiBwbHVnaW4gaG9vayBtdXN0IGJlIHBsYWNlZCBhZnRlciB0aGUgXCIgKyBiZWZvcmUgKyBcIiBwbHVnaW4gaG9vayFcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZCkge1xuICAgIHJldHVybiB0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IHVwZGF0ZXIob2xkKSA6IHVwZGF0ZXI7XG4gIH1cbiAgZnVuY3Rpb24gdXNlR2V0TGF0ZXN0KG9iaikge1xuICAgIHZhciByZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgICByZWYuY3VycmVudCA9IG9iajtcbiAgICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlZi5jdXJyZW50O1xuICAgIH0sIFtdKTtcbiAgfSAvLyBTU1IgaGFzIGlzc3VlcyB3aXRoIHVzZUxheW91dEVmZmVjdCBzdGlsbCwgc28gdXNlIHVzZUVmZmVjdCBkdXJpbmcgU1NSXG5cbiAgdmFyIHNhZmVVc2VMYXlvdXRFZmZlY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuICBmdW5jdGlvbiB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZuLCBkZXBzKSB7XG4gICAgdmFyIG1vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIHNhZmVVc2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICBmbigpO1xuICAgICAgfVxuXG4gICAgICBtb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICB9LCBkZXBzKTtcbiAgfVxuICBmdW5jdGlvbiB1c2VBc3luY0RlYm91bmNlKGRlZmF1bHRGbiwgZGVmYXVsdFdhaXQpIHtcbiAgICBpZiAoZGVmYXVsdFdhaXQgPT09IHZvaWQgMCkge1xuICAgICAgZGVmYXVsdFdhaXQgPSAwO1xuICAgIH1cblxuICAgIHZhciBkZWJvdW5jZVJlZiA9IFJlYWN0LnVzZVJlZih7fSk7XG4gICAgdmFyIGdldERlZmF1bHRGbiA9IHVzZUdldExhdGVzdChkZWZhdWx0Rm4pO1xuICAgIHZhciBnZXREZWZhdWx0V2FpdCA9IHVzZUdldExhdGVzdChkZWZhdWx0V2FpdCk7XG4gICAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvcihcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICB2YXIgX2xlbjIsXG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgX2tleTIsXG4gICAgICAgICAgICBfYXJnczIgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBmb3IgKF9sZW4yID0gX2FyZ3MyLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBfYXJnczJbX2tleTJdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZGVib3VuY2VSZWYuY3VycmVudC5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICBkZWJvdW5jZVJlZi5jdXJyZW50LnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYm91bmNlUmVmLmN1cnJlbnQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgIGRlYm91bmNlUmVmLmN1cnJlbnQucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRlYm91bmNlUmVmLmN1cnJlbnQudGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlUmVmLmN1cnJlbnQudGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVib3VuY2VSZWYuY3VycmVudC50aW1lb3V0ID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAgICAgICAgICAgX2FzeW5jVG9HZW5lcmF0b3IoXG4gICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xuICAgICAgICAgICAgICAgIHJlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkZWJvdW5jZVJlZi5jdXJyZW50LnRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IGRlYm91bmNlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdEZuKCkuYXBwbHkodm9pZCAwLCBhcmdzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50MSA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDAucmVzb2x2ZS5jYWxsKF9jb250ZXh0LnQwLCBfY29udGV4dC50MSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDIgPSBfY29udGV4dFtcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJvdW5jZVJlZi5jdXJyZW50LnJlamVjdChfY29udGV4dC50Mik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRlYm91bmNlUmVmLmN1cnJlbnQucHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmZpbmlzaCgxMik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzEsIDksIDEyLCAxNV1dKTtcbiAgICAgICAgICAgICAgICB9KSksIGdldERlZmF1bHRXYWl0KCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIGRlYm91bmNlUmVmLmN1cnJlbnQucHJvbWlzZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMik7XG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9KCksIFtnZXREZWZhdWx0Rm4sIGdldERlZmF1bHRXYWl0XSk7XG4gIH1cbiAgZnVuY3Rpb24gbWFrZVJlbmRlcmVyKGluc3RhbmNlLCBjb2x1bW4sIG1ldGEpIHtcbiAgICBpZiAobWV0YSA9PT0gdm9pZCAwKSB7XG4gICAgICBtZXRhID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0eXBlLCB1c2VyUHJvcHMpIHtcbiAgICAgIGlmICh1c2VyUHJvcHMgPT09IHZvaWQgMCkge1xuICAgICAgICB1c2VyUHJvcHMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIENvbXAgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyBjb2x1bW5bdHlwZV0gOiB0eXBlO1xuXG4gICAgICBpZiAodHlwZW9mIENvbXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhjb2x1bW4pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVuZGVyRXJyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZsZXhSZW5kZXIoQ29tcCwgX2V4dGVuZHMoe30sIGluc3RhbmNlLCB7XG4gICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICB9LCBtZXRhLCB7fSwgdXNlclByb3BzKSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmbGV4UmVuZGVyKENvbXAsIHByb3BzKSB7XG4gICAgcmV0dXJuIGlzUmVhY3RDb21wb25lbnQoQ29tcCkgPyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXAsIHByb3BzKSA6IENvbXA7XG4gIH1cblxuICBmdW5jdGlvbiBpc1JlYWN0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgfHwgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyB8fCBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29tcG9uZW50KTtcbiAgICAgIHJldHVybiBwcm90by5wcm90b3R5cGUgJiYgcHJvdG8ucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG4gICAgfSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFeG90aWNDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb21wb25lbnQuJCR0eXBlb2YgPT09ICdzeW1ib2wnICYmIFsncmVhY3QubWVtbycsICdyZWFjdC5mb3J3YXJkX3JlZiddLmluY2x1ZGVzKGNvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBsaW5rQ29sdW1uU3RydWN0dXJlKGNvbHVtbnMsIHBhcmVudCwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgZGVwdGggPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICBjb2x1bW4gPSBfZXh0ZW5kcyh7fSwgY29sdW1uLCB7XG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICBkZXB0aDogZGVwdGhcbiAgICAgIH0pO1xuICAgICAgYXNzaWduQ29sdW1uQWNjZXNzb3IoY29sdW1uKTtcblxuICAgICAgaWYgKGNvbHVtbi5jb2x1bW5zKSB7XG4gICAgICAgIGNvbHVtbi5jb2x1bW5zID0gbGlua0NvbHVtblN0cnVjdHVyZShjb2x1bW4uY29sdW1ucywgY29sdW1uLCBkZXB0aCArIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29sdW1uO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGZsYXR0ZW5Db2x1bW5zKGNvbHVtbnMpIHtcbiAgICByZXR1cm4gZmxhdHRlbkJ5KGNvbHVtbnMsICdjb2x1bW5zJyk7XG4gIH1cbiAgZnVuY3Rpb24gYXNzaWduQ29sdW1uQWNjZXNzb3IoY29sdW1uKSB7XG4gICAgLy8gRmlyc3QgY2hlY2sgZm9yIHN0cmluZyBhY2Nlc3NvclxuICAgIHZhciBpZCA9IGNvbHVtbi5pZCxcbiAgICAgICAgYWNjZXNzb3IgPSBjb2x1bW4uYWNjZXNzb3IsXG4gICAgICAgIEhlYWRlciA9IGNvbHVtbi5IZWFkZXI7XG5cbiAgICBpZiAodHlwZW9mIGFjY2Vzc29yID09PSAnc3RyaW5nJykge1xuICAgICAgaWQgPSBpZCB8fCBhY2Nlc3NvcjtcbiAgICAgIHZhciBhY2Nlc3NvclBhdGggPSBhY2Nlc3Nvci5zcGxpdCgnLicpO1xuXG4gICAgICBhY2Nlc3NvciA9IGZ1bmN0aW9uIGFjY2Vzc29yKHJvdykge1xuICAgICAgICByZXR1cm4gZ2V0Qnkocm93LCBhY2Nlc3NvclBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIWlkICYmIHR5cGVvZiBIZWFkZXIgPT09ICdzdHJpbmcnICYmIEhlYWRlcikge1xuICAgICAgaWQgPSBIZWFkZXI7XG4gICAgfVxuXG4gICAgaWYgKCFpZCAmJiBjb2x1bW4uY29sdW1ucykge1xuICAgICAgY29uc29sZS5lcnJvcihjb2x1bW4pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGNvbHVtbiBJRCAob3IgdW5pcXVlIFwiSGVhZGVyXCIgdmFsdWUpIGlzIHJlcXVpcmVkIScpO1xuICAgIH1cblxuICAgIGlmICghaWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoY29sdW1uKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSBjb2x1bW4gSUQgKG9yIHN0cmluZyBhY2Nlc3NvcikgaXMgcmVxdWlyZWQhJyk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbihjb2x1bW4sIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGFjY2Vzc29yOiBhY2Nlc3NvclxuICAgIH0pO1xuICAgIHJldHVybiBjb2x1bW47XG4gIH1cbiAgZnVuY3Rpb24gZGVjb3JhdGVDb2x1bW4oY29sdW1uLCB1c2VyRGVmYXVsdENvbHVtbikge1xuICAgIGlmICghdXNlckRlZmF1bHRDb2x1bW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oY29sdW1uLCBfZXh0ZW5kcyh7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXMgYSBmYWxsYmFjayBoZWFkZXIsIGp1c3QgaW4gY2FzZVxuICAgICAgSGVhZGVyOiBlbXB0eVJlbmRlcmVyLFxuICAgICAgRm9vdGVyOiBlbXB0eVJlbmRlcmVyXG4gICAgfSwgZGVmYXVsdENvbHVtbiwge30sIHVzZXJEZWZhdWx0Q29sdW1uLCB7fSwgY29sdW1uKSk7XG4gICAgT2JqZWN0LmFzc2lnbihjb2x1bW4sIHtcbiAgICAgIG9yaWdpbmFsV2lkdGg6IGNvbHVtbi53aWR0aFxuICAgIH0pO1xuICAgIHJldHVybiBjb2x1bW47XG4gIH0gLy8gQnVpbGQgdGhlIGhlYWRlciBncm91cHMgZnJvbSB0aGUgYm90dG9tIHVwXG5cbiAgZnVuY3Rpb24gbWFrZUhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBkZWZhdWx0Q29sdW1uLCBhZGRpdGlvbmFsSGVhZGVyUHJvcGVydGllcykge1xuICAgIGlmIChhZGRpdGlvbmFsSGVhZGVyUHJvcGVydGllcyA9PT0gdm9pZCAwKSB7XG4gICAgICBhZGRpdGlvbmFsSGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIGFkZGl0aW9uYWxIZWFkZXJQcm9wZXJ0aWVzKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBoZWFkZXJHcm91cHMgPSBbXTtcbiAgICB2YXIgc2NhbkNvbHVtbnMgPSBhbGxDb2x1bW5zO1xuICAgIHZhciB1aWQgPSAwO1xuXG4gICAgdmFyIGdldFVJRCA9IGZ1bmN0aW9uIGdldFVJRCgpIHtcbiAgICAgIHJldHVybiB1aWQrKztcbiAgICB9O1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAvLyBUaGUgaGVhZGVyIGdyb3VwIHdlIGFyZSBjcmVhdGluZ1xuICAgICAgdmFyIGhlYWRlckdyb3VwID0ge1xuICAgICAgICBoZWFkZXJzOiBbXVxuICAgICAgfTsgLy8gVGhlIHBhcmVudCBjb2x1bW5zIHdlJ3JlIGdvaW5nIHRvIHNjYW4gbmV4dFxuXG4gICAgICB2YXIgcGFyZW50Q29sdW1ucyA9IFtdO1xuICAgICAgdmFyIGhhc1BhcmVudHMgPSBzY2FuQ29sdW1ucy5zb21lKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnBhcmVudDtcbiAgICAgIH0pOyAvLyBTY2FuIGVhY2ggY29sdW1uIGZvciBwYXJlbnRzXG5cbiAgICAgIHNjYW5Db2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAvLyBXaGF0IGlzIHRoZSBsYXRlc3QgKGxhc3QpIHBhcmVudCBjb2x1bW4/XG4gICAgICAgIHZhciBsYXRlc3RQYXJlbnRDb2x1bW4gPSBbXS5jb25jYXQocGFyZW50Q29sdW1ucykucmV2ZXJzZSgpWzBdO1xuICAgICAgICB2YXIgbmV3UGFyZW50O1xuXG4gICAgICAgIGlmIChoYXNQYXJlbnRzKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGNvbHVtbiBoYXMgYSBwYXJlbnQsIGFkZCBpdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICBpZiAoY29sdW1uLnBhcmVudCkge1xuICAgICAgICAgICAgbmV3UGFyZW50ID0gX2V4dGVuZHMoe30sIGNvbHVtbi5wYXJlbnQsIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxJZDogY29sdW1uLnBhcmVudC5pZCxcbiAgICAgICAgICAgICAgaWQ6IGNvbHVtbi5wYXJlbnQuaWQgKyBcIl9cIiArIGdldFVJRCgpLFxuICAgICAgICAgICAgICBoZWFkZXJzOiBbY29sdW1uXVxuICAgICAgICAgICAgfSwgYWRkaXRpb25hbEhlYWRlclByb3BlcnRpZXMoY29sdW1uKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG90aGVyIGNvbHVtbnMgaGF2ZSBwYXJlbnRzLCB3ZSdsbCBuZWVkIHRvIGFkZCBhIHBsYWNlIGhvbGRlciBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbElkID0gY29sdW1uLmlkICsgXCJfcGxhY2Vob2xkZXJcIjtcbiAgICAgICAgICAgIG5ld1BhcmVudCA9IGRlY29yYXRlQ29sdW1uKF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxJZDogb3JpZ2luYWxJZCxcbiAgICAgICAgICAgICAgaWQ6IGNvbHVtbi5pZCArIFwiX3BsYWNlaG9sZGVyX1wiICsgZ2V0VUlEKCksXG4gICAgICAgICAgICAgIHBsYWNlaG9sZGVyT2Y6IGNvbHVtbixcbiAgICAgICAgICAgICAgaGVhZGVyczogW2NvbHVtbl1cbiAgICAgICAgICAgIH0sIGFkZGl0aW9uYWxIZWFkZXJQcm9wZXJ0aWVzKGNvbHVtbikpLCBkZWZhdWx0Q29sdW1uKTtcbiAgICAgICAgICB9IC8vIElmIHRoZSByZXN1bHRpbmcgcGFyZW50IGNvbHVtbnMgYXJlIHRoZSBzYW1lLCBqdXN0IGFkZFxuICAgICAgICAgIC8vIHRoZSBjb2x1bW4gYW5kIGluY3JlbWVudCB0aGUgaGVhZGVyIHNwYW5cblxuXG4gICAgICAgICAgaWYgKGxhdGVzdFBhcmVudENvbHVtbiAmJiBsYXRlc3RQYXJlbnRDb2x1bW4ub3JpZ2luYWxJZCA9PT0gbmV3UGFyZW50Lm9yaWdpbmFsSWQpIHtcbiAgICAgICAgICAgIGxhdGVzdFBhcmVudENvbHVtbi5oZWFkZXJzLnB1c2goY29sdW1uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50Q29sdW1ucy5wdXNoKG5ld1BhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaGVhZGVyR3JvdXAuaGVhZGVycy5wdXNoKGNvbHVtbik7XG4gICAgICB9KTtcbiAgICAgIGhlYWRlckdyb3Vwcy5wdXNoKGhlYWRlckdyb3VwKTsgLy8gU3RhcnQgc2Nhbm5pbmcgdGhlIHBhcmVudCBjb2x1bW5zXG5cbiAgICAgIHNjYW5Db2x1bW5zID0gcGFyZW50Q29sdW1ucztcbiAgICB9O1xuXG4gICAgd2hpbGUgKHNjYW5Db2x1bW5zLmxlbmd0aCkge1xuICAgICAgX2xvb3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyR3JvdXBzLnJldmVyc2UoKTtcbiAgfVxuICB2YXIgcGF0aE9iakNhY2hlID0gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiBnZXRCeShvYmosIHBhdGgsIGRlZikge1xuICAgIGlmICghcGF0aCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGVLZXkgPSB0eXBlb2YgcGF0aCA9PT0gJ2Z1bmN0aW9uJyA/IHBhdGggOiBKU09OLnN0cmluZ2lmeShwYXRoKTtcblxuICAgIHZhciBwYXRoT2JqID0gcGF0aE9iakNhY2hlLmdldChjYWNoZUtleSkgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhdGhPYmogPSBtYWtlUGF0aEFycmF5KHBhdGgpO1xuICAgICAgcGF0aE9iakNhY2hlLnNldChjYWNoZUtleSwgcGF0aE9iaik7XG4gICAgICByZXR1cm4gcGF0aE9iajtcbiAgICB9KCk7XG5cbiAgICB2YXIgdmFsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhbCA9IHBhdGhPYmoucmVkdWNlKGZ1bmN0aW9uIChjdXJzb3IsIHBhdGhQYXJ0KSB7XG4gICAgICAgIHJldHVybiBjdXJzb3JbcGF0aFBhcnRdO1xuICAgICAgfSwgb2JqKTtcbiAgICB9IGNhdGNoIChlKSB7Ly8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICAgIH1cblxuICAgIHJldHVybiB0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJyA/IHZhbCA6IGRlZjtcbiAgfVxuICBmdW5jdGlvbiBnZXRGaXJzdERlZmluZWQoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHR5cGVvZiBhcmdzW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gYXJnc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbihhKSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZmxhdHRlbkJ5KGFyciwga2V5KSB7XG4gICAgdmFyIGZsYXQgPSBbXTtcblxuICAgIHZhciByZWN1cnNlID0gZnVuY3Rpb24gcmVjdXJzZShhcnIpIHtcbiAgICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGlmICghZFtrZXldKSB7XG4gICAgICAgICAgZmxhdC5wdXNoKGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY3Vyc2UoZFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJlY3Vyc2UoYXJyKTtcbiAgICByZXR1cm4gZmxhdDtcbiAgfVxuICBmdW5jdGlvbiBleHBhbmRSb3dzKHJvd3MsIF9yZWYpIHtcbiAgICB2YXIgbWFudWFsRXhwYW5kZWRLZXkgPSBfcmVmLm1hbnVhbEV4cGFuZGVkS2V5LFxuICAgICAgICBleHBhbmRlZCA9IF9yZWYuZXhwYW5kZWQsXG4gICAgICAgIF9yZWYkZXhwYW5kU3ViUm93cyA9IF9yZWYuZXhwYW5kU3ViUm93cyxcbiAgICAgICAgZXhwYW5kU3ViUm93cyA9IF9yZWYkZXhwYW5kU3ViUm93cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkZXhwYW5kU3ViUm93cztcbiAgICB2YXIgZXhwYW5kZWRSb3dzID0gW107XG5cbiAgICB2YXIgaGFuZGxlUm93ID0gZnVuY3Rpb24gaGFuZGxlUm93KHJvdywgYWRkVG9FeHBhbmRlZFJvd3MpIHtcbiAgICAgIGlmIChhZGRUb0V4cGFuZGVkUm93cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGFkZFRvRXhwYW5kZWRSb3dzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcm93LmlzRXhwYW5kZWQgPSByb3cub3JpZ2luYWwgJiYgcm93Lm9yaWdpbmFsW21hbnVhbEV4cGFuZGVkS2V5XSB8fCBleHBhbmRlZFtyb3cuaWRdO1xuICAgICAgcm93LmNhbkV4cGFuZCA9IHJvdy5zdWJSb3dzICYmICEhcm93LnN1YlJvd3MubGVuZ3RoO1xuXG4gICAgICBpZiAoYWRkVG9FeHBhbmRlZFJvd3MpIHtcbiAgICAgICAgZXhwYW5kZWRSb3dzLnB1c2gocm93KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdy5zdWJSb3dzICYmIHJvdy5zdWJSb3dzLmxlbmd0aCAmJiByb3cuaXNFeHBhbmRlZCkge1xuICAgICAgICByb3cuc3ViUm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlUm93KHJvdywgZXhwYW5kU3ViUm93cyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIGhhbmRsZVJvdyhyb3cpO1xuICAgIH0pO1xuICAgIHJldHVybiBleHBhbmRlZFJvd3M7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RmlsdGVyTWV0aG9kKGZpbHRlciwgdXNlckZpbHRlclR5cGVzLCBmaWx0ZXJUeXBlcykge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGZpbHRlcikgfHwgdXNlckZpbHRlclR5cGVzW2ZpbHRlcl0gfHwgZmlsdGVyVHlwZXNbZmlsdGVyXSB8fCBmaWx0ZXJUeXBlcy50ZXh0O1xuICB9XG4gIGZ1bmN0aW9uIHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoYXV0b1JlbW92ZSwgdmFsdWUsIGNvbHVtbikge1xuICAgIHJldHVybiBhdXRvUmVtb3ZlID8gYXV0b1JlbW92ZSh2YWx1ZSwgY29sdW1uKSA6IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gIH1cbiAgZnVuY3Rpb24gdW5wcmVwYXJlZEFjY2Vzc1dhcm5pbmcoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdC1UYWJsZTogWW91IGhhdmUgbm90IGNhbGxlZCBwcmVwYXJlUm93KHJvdykgb25lIG9yIG1vcmUgcm93cyB5b3UgYXJlIGF0dGVtcHRpbmcgdG8gcmVuZGVyLicpO1xuICB9XG4gIHZhciBwYXNzaXZlU3VwcG9ydGVkID0gbnVsbDtcbiAgZnVuY3Rpb24gcGFzc2l2ZUV2ZW50U3VwcG9ydGVkKCkge1xuICAgIC8vIG1lbW9pemUgc3VwcG9ydCB0byBhdm9pZCBhZGRpbmcgbXVsdGlwbGUgdGVzdCBldmVudHNcbiAgICBpZiAodHlwZW9mIHBhc3NpdmVTdXBwb3J0ZWQgPT09ICdib29sZWFuJykgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG4gICAgdmFyIHN1cHBvcnRlZCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwYXNzaXZlU3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuICAgIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xuICB9IC8vXG5cbiAgdmFyIHJlT3BlbkJyYWNrZXQgPSAvXFxbL2c7XG4gIHZhciByZUNsb3NlQnJhY2tldCA9IC9cXF0vZztcblxuICBmdW5jdGlvbiBtYWtlUGF0aEFycmF5KG9iaikge1xuICAgIHJldHVybiBmbGF0dGVuRGVlcChvYmopIC8vIHJlbW92ZSBhbGwgcGVyaW9kcyBpbiBwYXJ0c1xuICAgIC5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoZCkucmVwbGFjZSgnLicsICdfJyk7XG4gICAgfSkgLy8gam9pbiBwYXJ0cyB1c2luZyBwZXJpb2RcbiAgICAuam9pbignLicpIC8vIHJlcGxhY2UgYnJhY2tldHMgd2l0aCBwZXJpb2RzXG4gICAgLnJlcGxhY2UocmVPcGVuQnJhY2tldCwgJy4nKS5yZXBsYWNlKHJlQ2xvc2VCcmFja2V0LCAnJykgLy8gc3BsaXQgaXQgYmFjayBvdXQgb24gcGVyaW9kc1xuICAgIC5zcGxpdCgnLicpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmxhdHRlbkRlZXAoYXJyLCBuZXdBcnIpIHtcbiAgICBpZiAobmV3QXJyID09PSB2b2lkIDApIHtcbiAgICAgIG5ld0FyciA9IFtdO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICBuZXdBcnIucHVzaChhcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBmbGF0dGVuRGVlcChhcnJbaV0sIG5ld0Fycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0FycjtcbiAgfVxuXG4gIHZhciBkZWZhdWx0R2V0VGFibGVQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRUYWJsZVByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIHJvbGU6ICd0YWJsZSdcbiAgICB9LCBwcm9wcyk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRUYWJsZUJvZHlQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRUYWJsZUJvZHlQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICByb2xlOiAncm93Z3JvdXAnXG4gICAgfSwgcHJvcHMpO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0SGVhZGVyUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0SGVhZGVyUHJvcHMocHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgY29sdW1uID0gX3JlZi5jb2x1bW47XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleTogXCJoZWFkZXJfXCIgKyBjb2x1bW4uaWQsXG4gICAgICBjb2xTcGFuOiBjb2x1bW4udG90YWxWaXNpYmxlSGVhZGVyQ291bnQsXG4gICAgICByb2xlOiAnY29sdW1uaGVhZGVyJ1xuICAgIH0sIHByb3BzKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldEZvb3RlclByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldEZvb3RlclByb3BzKHByb3BzLCBfcmVmMikge1xuICAgIHZhciBjb2x1bW4gPSBfcmVmMi5jb2x1bW47XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleTogXCJmb290ZXJfXCIgKyBjb2x1bW4uaWQsXG4gICAgICBjb2xTcGFuOiBjb2x1bW4udG90YWxWaXNpYmxlSGVhZGVyQ291bnRcbiAgICB9LCBwcm9wcyk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRIZWFkZXJHcm91cFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldEhlYWRlckdyb3VwUHJvcHMocHJvcHMsIF9yZWYzKSB7XG4gICAgdmFyIGluZGV4ID0gX3JlZjMuaW5kZXg7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleTogXCJoZWFkZXJHcm91cF9cIiArIGluZGV4LFxuICAgICAgcm9sZTogJ3JvdydcbiAgICB9LCBwcm9wcyk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRGb290ZXJHcm91cFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldEZvb3Rlckdyb3VwUHJvcHMocHJvcHMsIF9yZWY0KSB7XG4gICAgdmFyIGluZGV4ID0gX3JlZjQuaW5kZXg7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleTogXCJmb290ZXJHcm91cF9cIiArIGluZGV4XG4gICAgfSwgcHJvcHMpO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0Um93UHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0Um93UHJvcHMocHJvcHMsIF9yZWY1KSB7XG4gICAgdmFyIHJvdyA9IF9yZWY1LnJvdztcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBcInJvd19cIiArIHJvdy5pZCxcbiAgICAgIHJvbGU6ICdyb3cnXG4gICAgfSwgcHJvcHMpO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0Q2VsbFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldENlbGxQcm9wcyhwcm9wcywgX3JlZjYpIHtcbiAgICB2YXIgY2VsbCA9IF9yZWY2LmNlbGw7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleTogXCJjZWxsX1wiICsgY2VsbC5yb3cuaWQgKyBcIl9cIiArIGNlbGwuY29sdW1uLmlkLFxuICAgICAgcm9sZTogJ2NlbGwnXG4gICAgfSwgcHJvcHMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VEZWZhdWx0UGx1Z2luSG9va3MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZU9wdGlvbnM6IFtdLFxuICAgICAgc3RhdGVSZWR1Y2VyczogW10sXG4gICAgICB1c2VDb250cm9sbGVkU3RhdGU6IFtdLFxuICAgICAgY29sdW1uczogW10sXG4gICAgICBjb2x1bW5zRGVwczogW10sXG4gICAgICBhbGxDb2x1bW5zOiBbXSxcbiAgICAgIGFsbENvbHVtbnNEZXBzOiBbXSxcbiAgICAgIGFjY2Vzc1ZhbHVlOiBbXSxcbiAgICAgIG1hdGVyaWFsaXplZENvbHVtbnM6IFtdLFxuICAgICAgbWF0ZXJpYWxpemVkQ29sdW1uc0RlcHM6IFtdLFxuICAgICAgdXNlSW5zdGFuY2VBZnRlckRhdGE6IFtdLFxuICAgICAgdmlzaWJsZUNvbHVtbnM6IFtdLFxuICAgICAgdmlzaWJsZUNvbHVtbnNEZXBzOiBbXSxcbiAgICAgIGhlYWRlckdyb3VwczogW10sXG4gICAgICBoZWFkZXJHcm91cHNEZXBzOiBbXSxcbiAgICAgIHVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9uczogW10sXG4gICAgICB1c2VJbnN0YW5jZTogW10sXG4gICAgICBwcmVwYXJlUm93OiBbXSxcbiAgICAgIGdldFRhYmxlUHJvcHM6IFtkZWZhdWx0R2V0VGFibGVQcm9wc10sXG4gICAgICBnZXRUYWJsZUJvZHlQcm9wczogW2RlZmF1bHRHZXRUYWJsZUJvZHlQcm9wc10sXG4gICAgICBnZXRIZWFkZXJHcm91cFByb3BzOiBbZGVmYXVsdEdldEhlYWRlckdyb3VwUHJvcHNdLFxuICAgICAgZ2V0Rm9vdGVyR3JvdXBQcm9wczogW2RlZmF1bHRHZXRGb290ZXJHcm91cFByb3BzXSxcbiAgICAgIGdldEhlYWRlclByb3BzOiBbZGVmYXVsdEdldEhlYWRlclByb3BzXSxcbiAgICAgIGdldEZvb3RlclByb3BzOiBbZGVmYXVsdEdldEZvb3RlclByb3BzXSxcbiAgICAgIGdldFJvd1Byb3BzOiBbZGVmYXVsdEdldFJvd1Byb3BzXSxcbiAgICAgIGdldENlbGxQcm9wczogW2RlZmF1bHRHZXRDZWxsUHJvcHNdLFxuICAgICAgdXNlRmluYWxJbnN0YW5jZTogW11cbiAgICB9O1xuICB9XG5cbiAgYWN0aW9ucy5yZXNldEhpZGRlbkNvbHVtbnMgPSAncmVzZXRIaWRkZW5Db2x1bW5zJztcbiAgYWN0aW9ucy50b2dnbGVIaWRlQ29sdW1uID0gJ3RvZ2dsZUhpZGVDb2x1bW4nO1xuICBhY3Rpb25zLnNldEhpZGRlbkNvbHVtbnMgPSAnc2V0SGlkZGVuQ29sdW1ucyc7XG4gIGFjdGlvbnMudG9nZ2xlSGlkZUFsbENvbHVtbnMgPSAndG9nZ2xlSGlkZUFsbENvbHVtbnMnO1xuICB2YXIgdXNlQ29sdW1uVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIHVzZUNvbHVtblZpc2liaWxpdHkoaG9va3MpIHtcbiAgICBob29rcy5nZXRUb2dnbGVIaWRkZW5Qcm9wcyA9IFtkZWZhdWx0R2V0VG9nZ2xlSGlkZGVuUHJvcHNdO1xuICAgIGhvb2tzLmdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHMgPSBbZGVmYXVsdEdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHNdO1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyKTtcbiAgICBob29rcy51c2VJbnN0YW5jZUJlZm9yZURpbWVuc2lvbnMucHVzaCh1c2VJbnN0YW5jZUJlZm9yZURpbWVuc2lvbnMpO1xuICAgIGhvb2tzLmhlYWRlckdyb3Vwc0RlcHMucHVzaChmdW5jdGlvbiAoZGVwcywgX3JlZikge1xuICAgICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoZGVwcywgW2luc3RhbmNlLnN0YXRlLmhpZGRlbkNvbHVtbnNdKTtcbiAgICB9KTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlKTtcbiAgfTtcbiAgdXNlQ29sdW1uVmlzaWJpbGl0eS5wbHVnaW5OYW1lID0gJ3VzZUNvbHVtblZpc2liaWxpdHknO1xuXG4gIHZhciBkZWZhdWx0R2V0VG9nZ2xlSGlkZGVuUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0VG9nZ2xlSGlkZGVuUHJvcHMocHJvcHMsIF9yZWYyKSB7XG4gICAgdmFyIGNvbHVtbiA9IF9yZWYyLmNvbHVtbjtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZSkge1xuICAgICAgICBjb2x1bW4udG9nZ2xlSGlkZGVuKCFlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgfSxcbiAgICAgIGNoZWNrZWQ6IGNvbHVtbi5pc1Zpc2libGUsXG4gICAgICB0aXRsZTogJ1RvZ2dsZSBDb2x1bW4gVmlzaWJsZSdcbiAgICB9XTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0VG9nZ2xlSGlkZUFsbENvbHVtbnNQcm9wcyhwcm9wcywgX3JlZjMpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmMy5pbnN0YW5jZTtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZSkge1xuICAgICAgICBpbnN0YW5jZS50b2dnbGVIaWRlQWxsQ29sdW1ucyghZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgIH0sXG4gICAgICBjaGVja2VkOiAhaW5zdGFuY2UuYWxsQ29sdW1uc0hpZGRlbiAmJiAhaW5zdGFuY2Uuc3RhdGUuaGlkZGVuQ29sdW1ucy5sZW5ndGgsXG4gICAgICB0aXRsZTogJ1RvZ2dsZSBBbGwgQ29sdW1ucyBIaWRkZW4nLFxuICAgICAgaW5kZXRlcm1pbmF0ZTogIWluc3RhbmNlLmFsbENvbHVtbnNIaWRkZW4gJiYgaW5zdGFuY2Uuc3RhdGUuaGlkZGVuQ29sdW1ucy5sZW5ndGhcbiAgICB9XTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24sIHByZXZpb3VzU3RhdGUsIGluc3RhbmNlKSB7XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmluaXQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIGhpZGRlbkNvbHVtbnM6IFtdXG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnJlc2V0SGlkZGVuQ29sdW1ucykge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBoaWRkZW5Db2x1bW5zOiBpbnN0YW5jZS5pbml0aWFsU3RhdGUuaGlkZGVuQ29sdW1ucyB8fCBbXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZUhpZGVDb2x1bW4pIHtcbiAgICAgIHZhciBzaG91bGQgPSB0eXBlb2YgYWN0aW9uLnZhbHVlICE9PSAndW5kZWZpbmVkJyA/IGFjdGlvbi52YWx1ZSA6ICFzdGF0ZS5oaWRkZW5Db2x1bW5zLmluY2x1ZGVzKGFjdGlvbi5jb2x1bW5JZCk7XG4gICAgICB2YXIgaGlkZGVuQ29sdW1ucyA9IHNob3VsZCA/IFtdLmNvbmNhdChzdGF0ZS5oaWRkZW5Db2x1bW5zLCBbYWN0aW9uLmNvbHVtbklkXSkgOiBzdGF0ZS5oaWRkZW5Db2x1bW5zLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZCAhPT0gYWN0aW9uLmNvbHVtbklkO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGhpZGRlbkNvbHVtbnM6IGhpZGRlbkNvbHVtbnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5zZXRIaWRkZW5Db2x1bW5zKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGhpZGRlbkNvbHVtbnM6IGZ1bmN0aW9uYWxVcGRhdGUoYWN0aW9uLnZhbHVlLCBzdGF0ZS5oaWRkZW5Db2x1bW5zKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZUhpZGVBbGxDb2x1bW5zKSB7XG4gICAgICB2YXIgc2hvdWxkQWxsID0gdHlwZW9mIGFjdGlvbi52YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyBhY3Rpb24udmFsdWUgOiAhc3RhdGUuaGlkZGVuQ29sdW1ucy5sZW5ndGg7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGhpZGRlbkNvbHVtbnM6IHNob3VsZEFsbCA/IGluc3RhbmNlLmFsbENvbHVtbnMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQuaWQ7XG4gICAgICAgIH0pIDogW11cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucyhpbnN0YW5jZSkge1xuICAgIHZhciBoZWFkZXJzID0gaW5zdGFuY2UuaGVhZGVycyxcbiAgICAgICAgaGlkZGVuQ29sdW1ucyA9IGluc3RhbmNlLnN0YXRlLmhpZGRlbkNvbHVtbnM7XG4gICAgdmFyIGlzTW91bnRlZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG5cbiAgICBpZiAoIWlzTW91bnRlZFJlZi5jdXJyZW50KSA7XG5cbiAgICB2YXIgaGFuZGxlQ29sdW1uID0gZnVuY3Rpb24gaGFuZGxlQ29sdW1uKGNvbHVtbiwgcGFyZW50VmlzaWJsZSkge1xuICAgICAgY29sdW1uLmlzVmlzaWJsZSA9IHBhcmVudFZpc2libGUgJiYgIWhpZGRlbkNvbHVtbnMuaW5jbHVkZXMoY29sdW1uLmlkKTtcbiAgICAgIHZhciB0b3RhbFZpc2libGVIZWFkZXJDb3VudCA9IDA7XG5cbiAgICAgIGlmIChjb2x1bW4uaGVhZGVycyAmJiBjb2x1bW4uaGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgY29sdW1uLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViQ29sdW1uKSB7XG4gICAgICAgICAgcmV0dXJuIHRvdGFsVmlzaWJsZUhlYWRlckNvdW50ICs9IGhhbmRsZUNvbHVtbihzdWJDb2x1bW4sIGNvbHVtbi5pc1Zpc2libGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvdGFsVmlzaWJsZUhlYWRlckNvdW50ID0gY29sdW1uLmlzVmlzaWJsZSA/IDEgOiAwO1xuICAgICAgfVxuXG4gICAgICBjb2x1bW4udG90YWxWaXNpYmxlSGVhZGVyQ291bnQgPSB0b3RhbFZpc2libGVIZWFkZXJDb3VudDtcbiAgICAgIHJldHVybiB0b3RhbFZpc2libGVIZWFkZXJDb3VudDtcbiAgICB9O1xuXG4gICAgdmFyIHRvdGFsVmlzaWJsZUhlYWRlckNvdW50ID0gMDtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YkhlYWRlcikge1xuICAgICAgcmV0dXJuIHRvdGFsVmlzaWJsZUhlYWRlckNvdW50ICs9IGhhbmRsZUNvbHVtbihzdWJIZWFkZXIsIHRydWUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICB2YXIgY29sdW1ucyA9IGluc3RhbmNlLmNvbHVtbnMsXG4gICAgICAgIGZsYXRIZWFkZXJzID0gaW5zdGFuY2UuZmxhdEhlYWRlcnMsXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2gsXG4gICAgICAgIGFsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICBnZXRIb29rcyA9IGluc3RhbmNlLmdldEhvb2tzLFxuICAgICAgICBoaWRkZW5Db2x1bW5zID0gaW5zdGFuY2Uuc3RhdGUuaGlkZGVuQ29sdW1ucyxcbiAgICAgICAgX2luc3RhbmNlJGF1dG9SZXNldEhpID0gaW5zdGFuY2UuYXV0b1Jlc2V0SGlkZGVuQ29sdW1ucyxcbiAgICAgICAgYXV0b1Jlc2V0SGlkZGVuQ29sdW1ucyA9IF9pbnN0YW5jZSRhdXRvUmVzZXRIaSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRIaTtcbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2UpO1xuICAgIHZhciBhbGxDb2x1bW5zSGlkZGVuID0gYWxsQ29sdW1ucy5sZW5ndGggPT09IGhpZGRlbkNvbHVtbnMubGVuZ3RoO1xuICAgIHZhciB0b2dnbGVIaWRlQ29sdW1uID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbHVtbklkLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy50b2dnbGVIaWRlQ29sdW1uLFxuICAgICAgICBjb2x1bW5JZDogY29sdW1uSWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIHNldEhpZGRlbkNvbHVtbnMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0SGlkZGVuQ29sdW1ucyxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgdG9nZ2xlSGlkZUFsbENvbHVtbnMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMudG9nZ2xlSGlkZUFsbENvbHVtbnMsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIGdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRvZ2dsZUhpZGVBbGxDb2x1bW5zUHJvcHMsIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSk7XG4gICAgZmxhdEhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICBjb2x1bW4udG9nZ2xlSGlkZGVuID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZUhpZGVDb2x1bW4sXG4gICAgICAgICAgY29sdW1uSWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjb2x1bW4uZ2V0VG9nZ2xlSGlkZGVuUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRvZ2dsZUhpZGRlblByb3BzLCB7XG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpLFxuICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGdldEF1dG9SZXNldEhpZGRlbkNvbHVtbnMgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0SGlkZGVuQ29sdW1ucyk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0SGlkZGVuQ29sdW1ucygpKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLnJlc2V0SGlkZGVuQ29sdW1uc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbZGlzcGF0Y2gsIGNvbHVtbnNdKTtcbiAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgICBhbGxDb2x1bW5zSGlkZGVuOiBhbGxDb2x1bW5zSGlkZGVuLFxuICAgICAgdG9nZ2xlSGlkZUNvbHVtbjogdG9nZ2xlSGlkZUNvbHVtbixcbiAgICAgIHNldEhpZGRlbkNvbHVtbnM6IHNldEhpZGRlbkNvbHVtbnMsXG4gICAgICB0b2dnbGVIaWRlQWxsQ29sdW1uczogdG9nZ2xlSGlkZUFsbENvbHVtbnMsXG4gICAgICBnZXRUb2dnbGVIaWRlQWxsQ29sdW1uc1Byb3BzOiBnZXRUb2dnbGVIaWRlQWxsQ29sdW1uc1Byb3BzXG4gICAgfSk7XG4gIH1cblxuICB2YXIgZGVmYXVsdEluaXRpYWxTdGF0ZSA9IHt9O1xuICB2YXIgZGVmYXVsdENvbHVtbkluc3RhbmNlID0ge307XG5cbiAgdmFyIGRlZmF1bHRSZWR1Y2VyID0gZnVuY3Rpb24gZGVmYXVsdFJlZHVjZXIoc3RhdGUsIGFjdGlvbiwgcHJldlN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0R2V0U3ViUm93cyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRTdWJSb3dzKHJvdywgaW5kZXgpIHtcbiAgICByZXR1cm4gcm93LnN1YlJvd3MgfHwgW107XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRSb3dJZCA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRSb3dJZChyb3csIGluZGV4LCBwYXJlbnQpIHtcbiAgICByZXR1cm4gXCJcIiArIChwYXJlbnQgPyBbcGFyZW50LmlkLCBpbmRleF0uam9pbignLicpIDogaW5kZXgpO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0VXNlQ29udHJvbGxlZFN0YXRlID0gZnVuY3Rpb24gZGVmYXVsdFVzZUNvbnRyb2xsZWRTdGF0ZShkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhwcm9wcykge1xuICAgIHZhciBfcHJvcHMkaW5pdGlhbFN0YXRlID0gcHJvcHMuaW5pdGlhbFN0YXRlLFxuICAgICAgICBpbml0aWFsU3RhdGUgPSBfcHJvcHMkaW5pdGlhbFN0YXRlID09PSB2b2lkIDAgPyBkZWZhdWx0SW5pdGlhbFN0YXRlIDogX3Byb3BzJGluaXRpYWxTdGF0ZSxcbiAgICAgICAgX3Byb3BzJGRlZmF1bHRDb2x1bW4gPSBwcm9wcy5kZWZhdWx0Q29sdW1uLFxuICAgICAgICBkZWZhdWx0Q29sdW1uID0gX3Byb3BzJGRlZmF1bHRDb2x1bW4gPT09IHZvaWQgMCA/IGRlZmF1bHRDb2x1bW5JbnN0YW5jZSA6IF9wcm9wcyRkZWZhdWx0Q29sdW1uLFxuICAgICAgICBfcHJvcHMkZ2V0U3ViUm93cyA9IHByb3BzLmdldFN1YlJvd3MsXG4gICAgICAgIGdldFN1YlJvd3MgPSBfcHJvcHMkZ2V0U3ViUm93cyA9PT0gdm9pZCAwID8gZGVmYXVsdEdldFN1YlJvd3MgOiBfcHJvcHMkZ2V0U3ViUm93cyxcbiAgICAgICAgX3Byb3BzJGdldFJvd0lkID0gcHJvcHMuZ2V0Um93SWQsXG4gICAgICAgIGdldFJvd0lkID0gX3Byb3BzJGdldFJvd0lkID09PSB2b2lkIDAgPyBkZWZhdWx0R2V0Um93SWQgOiBfcHJvcHMkZ2V0Um93SWQsXG4gICAgICAgIF9wcm9wcyRzdGF0ZVJlZHVjZXIgPSBwcm9wcy5zdGF0ZVJlZHVjZXIsXG4gICAgICAgIHN0YXRlUmVkdWNlciA9IF9wcm9wcyRzdGF0ZVJlZHVjZXIgPT09IHZvaWQgMCA/IGRlZmF1bHRSZWR1Y2VyIDogX3Byb3BzJHN0YXRlUmVkdWNlcixcbiAgICAgICAgX3Byb3BzJHVzZUNvbnRyb2xsZWRTID0gcHJvcHMudXNlQ29udHJvbGxlZFN0YXRlLFxuICAgICAgICB1c2VDb250cm9sbGVkU3RhdGUgPSBfcHJvcHMkdXNlQ29udHJvbGxlZFMgPT09IHZvaWQgMCA/IGRlZmF1bHRVc2VDb250cm9sbGVkU3RhdGUgOiBfcHJvcHMkdXNlQ29udHJvbGxlZFMsXG4gICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgW1wiaW5pdGlhbFN0YXRlXCIsIFwiZGVmYXVsdENvbHVtblwiLCBcImdldFN1YlJvd3NcIiwgXCJnZXRSb3dJZFwiLCBcInN0YXRlUmVkdWNlclwiLCBcInVzZUNvbnRyb2xsZWRTdGF0ZVwiXSk7XG5cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgIGluaXRpYWxTdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgICAgZGVmYXVsdENvbHVtbjogZGVmYXVsdENvbHVtbixcbiAgICAgIGdldFN1YlJvd3M6IGdldFN1YlJvd3MsXG4gICAgICBnZXRSb3dJZDogZ2V0Um93SWQsXG4gICAgICBzdGF0ZVJlZHVjZXI6IHN0YXRlUmVkdWNlcixcbiAgICAgIHVzZUNvbnRyb2xsZWRTdGF0ZTogdXNlQ29udHJvbGxlZFN0YXRlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgdXNlVGFibGUgPSBmdW5jdGlvbiB1c2VUYWJsZShwcm9wcykge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBsdWdpbnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IGRlZmF1bHQgcHJvcHNcbiAgICBwcm9wcyA9IGFwcGx5RGVmYXVsdHMocHJvcHMpOyAvLyBBZGQgY29yZSBwbHVnaW5zXG5cbiAgICBwbHVnaW5zID0gW3VzZUNvbHVtblZpc2liaWxpdHldLmNvbmNhdChwbHVnaW5zKTsgLy8gQ3JlYXRlIHRoZSB0YWJsZSBpbnN0YW5jZVxuXG4gICAgdmFyIGluc3RhbmNlUmVmID0gUmVhY3QudXNlUmVmKHt9KTsgLy8gQ3JlYXRlIGEgZ2V0dGVyIGZvciB0aGUgaW5zdGFuY2UgKGhlbHBzIGF2b2lkIGEgbG90IG9mIHBvdGVudGlhbCBtZW1vcnkgbGVha3MpXG5cbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2VSZWYuY3VycmVudCk7IC8vIEFzc2lnbiB0aGUgcHJvcHMsIHBsdWdpbnMgYW5kIGhvb2tzIHRvIHRoZSBpbnN0YW5jZVxuXG4gICAgT2JqZWN0LmFzc2lnbihnZXRJbnN0YW5jZSgpLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIHBsdWdpbnM6IHBsdWdpbnMsXG4gICAgICBob29rczogbWFrZURlZmF1bHRQbHVnaW5Ib29rcygpXG4gICAgfSkpOyAvLyBBbGxvdyBwbHVnaW5zIHRvIHJlZ2lzdGVyIGhvb2tzIGFzIGVhcmx5IGFzIHBvc3NpYmxlXG5cbiAgICBwbHVnaW5zLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHBsdWdpbihnZXRJbnN0YW5jZSgpLmhvb2tzKTtcbiAgICB9KTsgLy8gQ29uc3VtZSBhbGwgaG9va3MgYW5kIG1ha2UgYSBnZXR0ZXIgZm9yIHRoZW1cblxuICAgIHZhciBnZXRIb29rcyA9IHVzZUdldExhdGVzdChnZXRJbnN0YW5jZSgpLmhvb2tzKTtcbiAgICBnZXRJbnN0YW5jZSgpLmdldEhvb2tzID0gZ2V0SG9va3M7XG4gICAgZGVsZXRlIGdldEluc3RhbmNlKCkuaG9va3M7IC8vIEFsbG93IHVzZU9wdGlvbnMgaG9va3MgdG8gbW9kaWZ5IHRoZSBvcHRpb25zIGNvbWluZyBpbnRvIHRoZSB0YWJsZVxuXG4gICAgT2JqZWN0LmFzc2lnbihnZXRJbnN0YW5jZSgpLCByZWR1Y2VIb29rcyhnZXRIb29rcygpLnVzZU9wdGlvbnMsIGFwcGx5RGVmYXVsdHMocHJvcHMpKSk7XG5cbiAgICB2YXIgX2dldEluc3RhbmNlID0gZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgZGF0YSA9IF9nZXRJbnN0YW5jZS5kYXRhLFxuICAgICAgICB1c2VyQ29sdW1ucyA9IF9nZXRJbnN0YW5jZS5jb2x1bW5zLFxuICAgICAgICBpbml0aWFsU3RhdGUgPSBfZ2V0SW5zdGFuY2UuaW5pdGlhbFN0YXRlLFxuICAgICAgICBkZWZhdWx0Q29sdW1uID0gX2dldEluc3RhbmNlLmRlZmF1bHRDb2x1bW4sXG4gICAgICAgIGdldFN1YlJvd3MgPSBfZ2V0SW5zdGFuY2UuZ2V0U3ViUm93cyxcbiAgICAgICAgZ2V0Um93SWQgPSBfZ2V0SW5zdGFuY2UuZ2V0Um93SWQsXG4gICAgICAgIHN0YXRlUmVkdWNlciA9IF9nZXRJbnN0YW5jZS5zdGF0ZVJlZHVjZXIsXG4gICAgICAgIHVzZUNvbnRyb2xsZWRTdGF0ZSA9IF9nZXRJbnN0YW5jZS51c2VDb250cm9sbGVkU3RhdGU7IC8vIFNldHVwIHVzZXIgcmVkdWNlciByZWZcblxuXG4gICAgdmFyIGdldFN0YXRlUmVkdWNlciA9IHVzZUdldExhdGVzdChzdGF0ZVJlZHVjZXIpOyAvLyBCdWlsZCB0aGUgcmVkdWNlclxuXG4gICAgdmFyIHJlZHVjZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoc3RhdGUsIGFjdGlvbikge1xuICAgICAgLy8gRGV0ZWN0IGludmFsaWQgYWN0aW9uc1xuICAgICAgaWYgKCFhY3Rpb24udHlwZSkge1xuICAgICAgICBjb25zb2xlLmluZm8oe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gQWN0aW9uIPCfkYYnKTtcbiAgICAgIH0gLy8gUmVkdWNlIHRoZSBzdGF0ZSBmcm9tIGFsbCBwbHVnaW4gcmVkdWNlcnNcblxuXG4gICAgICByZXR1cm4gW10uY29uY2F0KGdldEhvb2tzKCkuc3RhdGVSZWR1Y2VycywgQXJyYXkuaXNBcnJheShnZXRTdGF0ZVJlZHVjZXIoKSkgPyBnZXRTdGF0ZVJlZHVjZXIoKSA6IFtnZXRTdGF0ZVJlZHVjZXIoKV0pLnJlZHVjZShmdW5jdGlvbiAocywgaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcihzLCBhY3Rpb24sIHN0YXRlLCBnZXRJbnN0YW5jZSgpKSB8fCBzO1xuICAgICAgfSwgc3RhdGUpO1xuICAgIH0sIFtnZXRIb29rcywgZ2V0U3RhdGVSZWR1Y2VyLCBnZXRJbnN0YW5jZV0pOyAvLyBTdGFydCB0aGUgcmVkdWNlclxuXG4gICAgdmFyIF9SZWFjdCR1c2VSZWR1Y2VyID0gUmVhY3QudXNlUmVkdWNlcihyZWR1Y2VyLCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWR1Y2VyKGluaXRpYWxTdGF0ZSwge1xuICAgICAgICB0eXBlOiBhY3Rpb25zLmluaXRcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgICAgICByZWR1Y2VyU3RhdGUgPSBfUmVhY3QkdXNlUmVkdWNlclswXSxcbiAgICAgICAgZGlzcGF0Y2ggPSBfUmVhY3QkdXNlUmVkdWNlclsxXTsgLy8gQWxsb3cgdGhlIHVzZXIgdG8gY29udHJvbCB0aGUgZmluYWwgc3RhdGUgd2l0aCBob29rc1xuXG5cbiAgICB2YXIgc3RhdGUgPSByZWR1Y2VIb29rcyhbXS5jb25jYXQoZ2V0SG9va3MoKS51c2VDb250cm9sbGVkU3RhdGUsIFt1c2VDb250cm9sbGVkU3RhdGVdKSwgcmVkdWNlclN0YXRlLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pO1xuICAgIE9iamVjdC5hc3NpZ24oZ2V0SW5zdGFuY2UoKSwge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoXG4gICAgfSk7IC8vIERlY29yYXRlIEFsbCB0aGUgY29sdW1uc1xuXG4gICAgdmFyIGNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsaW5rQ29sdW1uU3RydWN0dXJlKHJlZHVjZUhvb2tzKGdldEhvb2tzKCkuY29sdW1ucywgdXNlckNvbHVtbnMsIHtcbiAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICAgIH0pKTtcbiAgICB9LCBbZ2V0SG9va3MsIGdldEluc3RhbmNlLCB1c2VyQ29sdW1uc10uY29uY2F0KHJlZHVjZUhvb2tzKGdldEhvb2tzKCkuY29sdW1uc0RlcHMsIFtdLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pKSk7XG4gICAgZ2V0SW5zdGFuY2UoKS5jb2x1bW5zID0gY29sdW1uczsgLy8gR2V0IHRoZSBmbGF0IGxpc3Qgb2YgYWxsIGNvbHVtbnMgYW5kIGFsbG93IGhvb2tzIHRvIGRlY29yYXRlXG4gICAgLy8gdGhvc2UgY29sdW1ucyAoYW5kIHRyaWdnZXIgdGhpcyBtZW1vaXphdGlvbiB2aWEgZGVwcylcblxuICAgIHZhciBhbGxDb2x1bW5zID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVkdWNlSG9va3MoZ2V0SG9va3MoKS5hbGxDb2x1bW5zLCBmbGF0dGVuQ29sdW1ucyhjb2x1bW5zKSwge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgICAgfSkubWFwKGFzc2lnbkNvbHVtbkFjY2Vzc29yKTtcbiAgICB9LCBbY29sdW1ucywgZ2V0SG9va3MsIGdldEluc3RhbmNlXS5jb25jYXQocmVkdWNlSG9va3MoZ2V0SG9va3MoKS5hbGxDb2x1bW5zRGVwcywgW10sIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSkpKTtcbiAgICBnZXRJbnN0YW5jZSgpLmFsbENvbHVtbnMgPSBhbGxDb2x1bW5zOyAvLyBBY2Nlc3MgdGhlIHJvdyBtb2RlbCB1c2luZyBpbml0aWFsIGNvbHVtbnNcblxuICAgIHZhciBfUmVhY3QkdXNlTWVtbyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgIHZhciBmbGF0Um93cyA9IFtdO1xuICAgICAgdmFyIHJvd3NCeUlkID0ge307XG4gICAgICB2YXIgYWxsQ29sdW1uc1F1ZXVlID0gW10uY29uY2F0KGFsbENvbHVtbnMpO1xuXG4gICAgICB3aGlsZSAoYWxsQ29sdW1uc1F1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgY29sdW1uID0gYWxsQ29sdW1uc1F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGFjY2Vzc1Jvd3NGb3JDb2x1bW4oe1xuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgcm93czogcm93cyxcbiAgICAgICAgICBmbGF0Um93czogZmxhdFJvd3MsXG4gICAgICAgICAgcm93c0J5SWQ6IHJvd3NCeUlkLFxuICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgIGdldFJvd0lkOiBnZXRSb3dJZCxcbiAgICAgICAgICBnZXRTdWJSb3dzOiBnZXRTdWJSb3dzLFxuICAgICAgICAgIGFjY2Vzc1ZhbHVlSG9va3M6IGdldEhvb2tzKCkuYWNjZXNzVmFsdWUsXG4gICAgICAgICAgZ2V0SW5zdGFuY2U6IGdldEluc3RhbmNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3Jvd3MsIGZsYXRSb3dzLCByb3dzQnlJZF07XG4gICAgfSwgW2FsbENvbHVtbnMsIGRhdGEsIGdldFJvd0lkLCBnZXRTdWJSb3dzLCBnZXRIb29rcywgZ2V0SW5zdGFuY2VdKSxcbiAgICAgICAgcm93cyA9IF9SZWFjdCR1c2VNZW1vWzBdLFxuICAgICAgICBmbGF0Um93cyA9IF9SZWFjdCR1c2VNZW1vWzFdLFxuICAgICAgICByb3dzQnlJZCA9IF9SZWFjdCR1c2VNZW1vWzJdO1xuXG4gICAgT2JqZWN0LmFzc2lnbihnZXRJbnN0YW5jZSgpLCB7XG4gICAgICByb3dzOiByb3dzLFxuICAgICAgaW5pdGlhbFJvd3M6IFtdLmNvbmNhdChyb3dzKSxcbiAgICAgIGZsYXRSb3dzOiBmbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkOiByb3dzQnlJZCAvLyBtYXRlcmlhbGl6ZWRDb2x1bW5zLFxuXG4gICAgfSk7XG4gICAgbG9vcEhvb2tzKGdldEhvb2tzKCkudXNlSW5zdGFuY2VBZnRlckRhdGEsIGdldEluc3RhbmNlKCkpOyAvLyBHZXQgdGhlIGZsYXQgbGlzdCBvZiBhbGwgY29sdW1ucyBBRlRFUiB0aGUgcm93c1xuICAgIC8vIGhhdmUgYmVlbiBhY2Nlc3MsIGFuZCBhbGxvdyBob29rcyB0byBkZWNvcmF0ZVxuICAgIC8vIHRob3NlIGNvbHVtbnMgKGFuZCB0cmlnZ2VyIHRoaXMgbWVtb2l6YXRpb24gdmlhIGRlcHMpXG5cbiAgICB2YXIgdmlzaWJsZUNvbHVtbnMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWR1Y2VIb29rcyhnZXRIb29rcygpLnZpc2libGVDb2x1bW5zLCBhbGxDb2x1bW5zLCB7XG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGRlY29yYXRlQ29sdW1uKGQsIGRlZmF1bHRDb2x1bW4pO1xuICAgICAgfSk7XG4gICAgfSwgW2dldEhvb2tzLCBhbGxDb2x1bW5zLCBnZXRJbnN0YW5jZSwgZGVmYXVsdENvbHVtbl0uY29uY2F0KHJlZHVjZUhvb2tzKGdldEhvb2tzKCkudmlzaWJsZUNvbHVtbnNEZXBzLCBbXSwge1xuICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICB9KSkpOyAvLyBDb21iaW5lIG5ldyB2aXNpYmxlIGNvbHVtbnMgd2l0aCBhbGwgY29sdW1uc1xuXG4gICAgYWxsQ29sdW1ucyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbHVtbnMgPSBbXS5jb25jYXQodmlzaWJsZUNvbHVtbnMpO1xuICAgICAgYWxsQ29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgaWYgKCFjb2x1bW5zLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gY29sdW1uLmlkO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGNvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb2x1bW5zO1xuICAgIH0sIFthbGxDb2x1bW5zLCB2aXNpYmxlQ29sdW1uc10pO1xuICAgIGdldEluc3RhbmNlKCkuYWxsQ29sdW1ucyA9IGFsbENvbHVtbnM7XG5cbiAgICB7XG4gICAgICB2YXIgZHVwbGljYXRlQ29sdW1ucyA9IGFsbENvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2x1bW4sIGkpIHtcbiAgICAgICAgcmV0dXJuIGFsbENvbHVtbnMuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQuaWQgPT09IGNvbHVtbi5pZDtcbiAgICAgICAgfSkgIT09IGk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGR1cGxpY2F0ZUNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbyhhbGxDb2x1bW5zKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGNvbHVtbnMgd2VyZSBmb3VuZCB3aXRoIGlkczogXFxcIlwiICsgZHVwbGljYXRlQ29sdW1ucy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gZC5pZDtcbiAgICAgICAgfSkuam9pbignLCAnKSArIFwiXFxcIiBpbiB0aGUgY29sdW1ucyBhcnJheSBhYm92ZVwiKTtcbiAgICAgIH1cbiAgICB9IC8vIE1ha2UgdGhlIGhlYWRlckdyb3Vwc1xuXG5cbiAgICB2YXIgaGVhZGVyR3JvdXBzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVkdWNlSG9va3MoZ2V0SG9va3MoKS5oZWFkZXJHcm91cHMsIG1ha2VIZWFkZXJHcm91cHModmlzaWJsZUNvbHVtbnMsIGRlZmF1bHRDb2x1bW4pLCBnZXRJbnN0YW5jZSgpKTtcbiAgICB9LCBbZ2V0SG9va3MsIHZpc2libGVDb2x1bW5zLCBkZWZhdWx0Q29sdW1uLCBnZXRJbnN0YW5jZV0uY29uY2F0KHJlZHVjZUhvb2tzKGdldEhvb2tzKCkuaGVhZGVyR3JvdXBzRGVwcywgW10sIHtcbiAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpXG4gICAgfSkpKTtcbiAgICBnZXRJbnN0YW5jZSgpLmhlYWRlckdyb3VwcyA9IGhlYWRlckdyb3VwczsgLy8gR2V0IHRoZSBmaXJzdCBsZXZlbCBvZiBoZWFkZXJzXG5cbiAgICB2YXIgaGVhZGVycyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGhlYWRlckdyb3Vwcy5sZW5ndGggPyBoZWFkZXJHcm91cHNbMF0uaGVhZGVycyA6IFtdO1xuICAgIH0sIFtoZWFkZXJHcm91cHNdKTtcbiAgICBnZXRJbnN0YW5jZSgpLmhlYWRlcnMgPSBoZWFkZXJzOyAvLyBQcm92aWRlIGEgZmxhdCBoZWFkZXIgbGlzdCBmb3IgdXRpbGl0aWVzXG5cbiAgICBnZXRJbnN0YW5jZSgpLmZsYXRIZWFkZXJzID0gaGVhZGVyR3JvdXBzLnJlZHVjZShmdW5jdGlvbiAoYWxsLCBoZWFkZXJHcm91cCkge1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChhbGwsIGhlYWRlckdyb3VwLmhlYWRlcnMpO1xuICAgIH0sIFtdKTtcbiAgICBsb29wSG9va3MoZ2V0SG9va3MoKS51c2VJbnN0YW5jZUJlZm9yZURpbWVuc2lvbnMsIGdldEluc3RhbmNlKCkpOyAvLyBGaWx0ZXIgY29sdW1ucyBkb3duIHRvIHZpc2libGUgb25lc1xuXG4gICAgdmFyIHZpc2libGVDb2x1bW5zRGVwID0gdmlzaWJsZUNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5pc1Zpc2libGU7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZC5pZDtcbiAgICB9KS5zb3J0KCkuam9pbignXycpO1xuICAgIHZpc2libGVDb2x1bW5zID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmlzaWJsZUNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlzVmlzaWJsZTtcbiAgICAgIH0pO1xuICAgIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbdmlzaWJsZUNvbHVtbnMsIHZpc2libGVDb2x1bW5zRGVwXSk7XG4gICAgZ2V0SW5zdGFuY2UoKS52aXNpYmxlQ29sdW1ucyA9IHZpc2libGVDb2x1bW5zOyAvLyBIZWFkZXIgVmlzaWJpbGl0eSBpcyBuZWVkZWQgYnkgdGhpcyBwb2ludFxuXG4gICAgdmFyIF9jYWxjdWxhdGVIZWFkZXJXaWR0aCA9IGNhbGN1bGF0ZUhlYWRlcldpZHRocyhoZWFkZXJzKSxcbiAgICAgICAgdG90YWxDb2x1bW5zTWluV2lkdGggPSBfY2FsY3VsYXRlSGVhZGVyV2lkdGhbMF0sXG4gICAgICAgIHRvdGFsQ29sdW1uc1dpZHRoID0gX2NhbGN1bGF0ZUhlYWRlcldpZHRoWzFdLFxuICAgICAgICB0b3RhbENvbHVtbnNNYXhXaWR0aCA9IF9jYWxjdWxhdGVIZWFkZXJXaWR0aFsyXTtcblxuICAgIGdldEluc3RhbmNlKCkudG90YWxDb2x1bW5zTWluV2lkdGggPSB0b3RhbENvbHVtbnNNaW5XaWR0aDtcbiAgICBnZXRJbnN0YW5jZSgpLnRvdGFsQ29sdW1uc1dpZHRoID0gdG90YWxDb2x1bW5zV2lkdGg7XG4gICAgZ2V0SW5zdGFuY2UoKS50b3RhbENvbHVtbnNNYXhXaWR0aCA9IHRvdGFsQ29sdW1uc01heFdpZHRoO1xuICAgIGxvb3BIb29rcyhnZXRIb29rcygpLnVzZUluc3RhbmNlLCBnZXRJbnN0YW5jZSgpKSAvLyBFYWNoIG1hdGVyaWFsaXplZCBoZWFkZXIgbmVlZHMgdG8gYmUgYXNzaWduZWQgYSByZW5kZXIgZnVuY3Rpb24gYW5kIG90aGVyXG4gICAgLy8gcHJvcCBnZXR0ZXIgcHJvcGVydGllcyBoZXJlLlxuICAgIDtcbiAgICBbXS5jb25jYXQoZ2V0SW5zdGFuY2UoKS5mbGF0SGVhZGVycywgZ2V0SW5zdGFuY2UoKS5hbGxDb2x1bW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgIC8vIEdpdmUgY29sdW1ucy9oZWFkZXJzIHJlbmRlcmluZyBwb3dlclxuICAgICAgY29sdW1uLnJlbmRlciA9IG1ha2VSZW5kZXJlcihnZXRJbnN0YW5jZSgpLCBjb2x1bW4pOyAvLyBHaXZlIGNvbHVtbnMvaGVhZGVycyBhIGRlZmF1bHQgZ2V0SGVhZGVyUHJvcHNcblxuICAgICAgY29sdW1uLmdldEhlYWRlclByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRIZWFkZXJQcm9wcywge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgIH0pOyAvLyBHaXZlIGNvbHVtbnMvaGVhZGVycyBhIGRlZmF1bHQgZ2V0Rm9vdGVyUHJvcHNcblxuICAgICAgY29sdW1uLmdldEZvb3RlclByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRGb290ZXJQcm9wcywge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGdldEluc3RhbmNlKCkuaGVhZGVyR3JvdXBzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaGVhZGVyR3JvdXBzLmZpbHRlcihmdW5jdGlvbiAoaGVhZGVyR3JvdXAsIGkpIHtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBhbnkgaGVhZGVycyBhbmQgaGVhZGVyR3JvdXBzIHRoYXQgZG9uJ3QgaGF2ZSB2aXNpYmxlIGNvbHVtbnNcbiAgICAgICAgaGVhZGVyR3JvdXAuaGVhZGVycyA9IGhlYWRlckdyb3VwLmhlYWRlcnMuZmlsdGVyKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICB2YXIgcmVjdXJzZSA9IGZ1bmN0aW9uIHJlY3Vyc2UoaGVhZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcnMuZmlsdGVyKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgICAgaWYgKGNvbHVtbi5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Vyc2UoY29sdW1uLmhlYWRlcnMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5pc1Zpc2libGU7XG4gICAgICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChjb2x1bW4uaGVhZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3Vyc2UoY29sdW1uLmhlYWRlcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb2x1bW4uaXNWaXNpYmxlO1xuICAgICAgICB9KTsgLy8gR2l2ZSBoZWFkZXJHcm91cHMgZ2V0Um93UHJvcHNcblxuICAgICAgICBpZiAoaGVhZGVyR3JvdXAuaGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBoZWFkZXJHcm91cC5nZXRIZWFkZXJHcm91cFByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRIZWFkZXJHcm91cFByb3BzLCB7XG4gICAgICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgICAgIGhlYWRlckdyb3VwOiBoZWFkZXJHcm91cCxcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaGVhZGVyR3JvdXAuZ2V0Rm9vdGVyR3JvdXBQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0Rm9vdGVyR3JvdXBQcm9wcywge1xuICAgICAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKCksXG4gICAgICAgICAgICBoZWFkZXJHcm91cDogaGVhZGVyR3JvdXAsXG4gICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSwgW2hlYWRlckdyb3VwcywgZ2V0SW5zdGFuY2UsIGdldEhvb2tzXSk7XG4gICAgZ2V0SW5zdGFuY2UoKS5mb290ZXJHcm91cHMgPSBbXS5jb25jYXQoZ2V0SW5zdGFuY2UoKS5oZWFkZXJHcm91cHMpLnJldmVyc2UoKTsgLy8gVGhlIHByZXBhcmVSb3cgZnVuY3Rpb24gaXMgYWJzb2x1dGVseSBuZWNlc3NhcnkgYW5kIE1VU1QgYmUgY2FsbGVkIG9uXG4gICAgLy8gYW55IHJvd3MgdGhlIHVzZXIgd2lzaGVzIHRvIGJlIGRpc3BsYXllZC5cblxuICAgIGdldEluc3RhbmNlKCkucHJlcGFyZVJvdyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJvdy5nZXRSb3dQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0Um93UHJvcHMsIHtcbiAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKCksXG4gICAgICAgIHJvdzogcm93XG4gICAgICB9KTsgLy8gQnVpbGQgdGhlIHZpc2libGUgY2VsbHMgZm9yIGVhY2ggcm93XG5cbiAgICAgIHJvdy5hbGxDZWxscyA9IGFsbENvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcm93LnZhbHVlc1tjb2x1bW4uaWRdO1xuICAgICAgICB2YXIgY2VsbCA9IHtcbiAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTsgLy8gR2l2ZSBlYWNoIGNlbGwgYSBnZXRDZWxsUHJvcHMgYmFzZVxuXG4gICAgICAgIGNlbGwuZ2V0Q2VsbFByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRDZWxsUHJvcHMsIHtcbiAgICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgICBjZWxsOiBjZWxsXG4gICAgICAgIH0pOyAvLyBHaXZlIGVhY2ggY2VsbCBhIHJlbmRlcmVyIGZ1bmN0aW9uIChzdXBwb3J0cyBtdWx0aXBsZSByZW5kZXJlcnMpXG5cbiAgICAgICAgY2VsbC5yZW5kZXIgPSBtYWtlUmVuZGVyZXIoZ2V0SW5zdGFuY2UoKSwgY29sdW1uLCB7XG4gICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgY2VsbDogY2VsbCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgfSk7XG4gICAgICByb3cuY2VsbHMgPSB2aXNpYmxlQ29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gcm93LmFsbENlbGxzLmZpbmQoZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICByZXR1cm4gY2VsbC5jb2x1bW4uaWQgPT09IGNvbHVtbi5pZDtcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gbmVlZCB0byBhcHBseSBhbnkgcm93IHNwZWNpZmljIGhvb2tzICh1c2VFeHBhbmRlZCByZXF1aXJlcyB0aGlzKVxuXG4gICAgICBsb29wSG9va3MoZ2V0SG9va3MoKS5wcmVwYXJlUm93LCByb3csIHtcbiAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICAgIH0pO1xuICAgIH0sIFtnZXRIb29rcywgZ2V0SW5zdGFuY2UsIGFsbENvbHVtbnMsIHZpc2libGVDb2x1bW5zXSk7XG4gICAgZ2V0SW5zdGFuY2UoKS5nZXRUYWJsZVByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRUYWJsZVByb3BzLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pO1xuICAgIGdldEluc3RhbmNlKCkuZ2V0VGFibGVCb2R5UHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRhYmxlQm9keVByb3BzLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pO1xuICAgIGxvb3BIb29rcyhnZXRIb29rcygpLnVzZUZpbmFsSW5zdGFuY2UsIGdldEluc3RhbmNlKCkpO1xuICAgIHJldHVybiBnZXRJbnN0YW5jZSgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUhlYWRlcldpZHRocyhoZWFkZXJzLCBsZWZ0KSB7XG4gICAgaWYgKGxlZnQgPT09IHZvaWQgMCkge1xuICAgICAgbGVmdCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHN1bVRvdGFsTWluV2lkdGggPSAwO1xuICAgIHZhciBzdW1Ub3RhbFdpZHRoID0gMDtcbiAgICB2YXIgc3VtVG90YWxNYXhXaWR0aCA9IDA7XG4gICAgdmFyIHN1bVRvdGFsRmxleFdpZHRoID0gMDtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgdmFyIHN1YkhlYWRlcnMgPSBoZWFkZXIuaGVhZGVycztcbiAgICAgIGhlYWRlci50b3RhbExlZnQgPSBsZWZ0O1xuXG4gICAgICBpZiAoc3ViSGVhZGVycyAmJiBzdWJIZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICB2YXIgX2NhbGN1bGF0ZUhlYWRlcldpZHRoMiA9IGNhbGN1bGF0ZUhlYWRlcldpZHRocyhzdWJIZWFkZXJzLCBsZWZ0KSxcbiAgICAgICAgICAgIHRvdGFsTWluV2lkdGggPSBfY2FsY3VsYXRlSGVhZGVyV2lkdGgyWzBdLFxuICAgICAgICAgICAgdG90YWxXaWR0aCA9IF9jYWxjdWxhdGVIZWFkZXJXaWR0aDJbMV0sXG4gICAgICAgICAgICB0b3RhbE1heFdpZHRoID0gX2NhbGN1bGF0ZUhlYWRlcldpZHRoMlsyXSxcbiAgICAgICAgICAgIHRvdGFsRmxleFdpZHRoID0gX2NhbGN1bGF0ZUhlYWRlcldpZHRoMlszXTtcblxuICAgICAgICBoZWFkZXIudG90YWxNaW5XaWR0aCA9IHRvdGFsTWluV2lkdGg7XG4gICAgICAgIGhlYWRlci50b3RhbFdpZHRoID0gdG90YWxXaWR0aDtcbiAgICAgICAgaGVhZGVyLnRvdGFsTWF4V2lkdGggPSB0b3RhbE1heFdpZHRoO1xuICAgICAgICBoZWFkZXIudG90YWxGbGV4V2lkdGggPSB0b3RhbEZsZXhXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYWRlci50b3RhbE1pbldpZHRoID0gaGVhZGVyLm1pbldpZHRoO1xuICAgICAgICBoZWFkZXIudG90YWxXaWR0aCA9IE1hdGgubWluKE1hdGgubWF4KGhlYWRlci5taW5XaWR0aCwgaGVhZGVyLndpZHRoKSwgaGVhZGVyLm1heFdpZHRoKTtcbiAgICAgICAgaGVhZGVyLnRvdGFsTWF4V2lkdGggPSBoZWFkZXIubWF4V2lkdGg7XG4gICAgICAgIGhlYWRlci50b3RhbEZsZXhXaWR0aCA9IGhlYWRlci5jYW5SZXNpemUgPyBoZWFkZXIudG90YWxXaWR0aCA6IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWFkZXIuaXNWaXNpYmxlKSB7XG4gICAgICAgIGxlZnQgKz0gaGVhZGVyLnRvdGFsV2lkdGg7XG4gICAgICAgIHN1bVRvdGFsTWluV2lkdGggKz0gaGVhZGVyLnRvdGFsTWluV2lkdGg7XG4gICAgICAgIHN1bVRvdGFsV2lkdGggKz0gaGVhZGVyLnRvdGFsV2lkdGg7XG4gICAgICAgIHN1bVRvdGFsTWF4V2lkdGggKz0gaGVhZGVyLnRvdGFsTWF4V2lkdGg7XG4gICAgICAgIHN1bVRvdGFsRmxleFdpZHRoICs9IGhlYWRlci50b3RhbEZsZXhXaWR0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW3N1bVRvdGFsTWluV2lkdGgsIHN1bVRvdGFsV2lkdGgsIHN1bVRvdGFsTWF4V2lkdGgsIHN1bVRvdGFsRmxleFdpZHRoXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjY2Vzc1Jvd3NGb3JDb2x1bW4oX3JlZikge1xuICAgIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICByb3dzID0gX3JlZi5yb3dzLFxuICAgICAgICBmbGF0Um93cyA9IF9yZWYuZmxhdFJvd3MsXG4gICAgICAgIHJvd3NCeUlkID0gX3JlZi5yb3dzQnlJZCxcbiAgICAgICAgY29sdW1uID0gX3JlZi5jb2x1bW4sXG4gICAgICAgIGdldFJvd0lkID0gX3JlZi5nZXRSb3dJZCxcbiAgICAgICAgZ2V0U3ViUm93cyA9IF9yZWYuZ2V0U3ViUm93cyxcbiAgICAgICAgYWNjZXNzVmFsdWVIb29rcyA9IF9yZWYuYWNjZXNzVmFsdWVIb29rcyxcbiAgICAgICAgZ2V0SW5zdGFuY2UgPSBfcmVmLmdldEluc3RhbmNlO1xuXG4gICAgLy8gQWNjZXNzIHRoZSByb3cncyBkYXRhIGNvbHVtbi1ieS1jb2x1bW5cbiAgICAvLyBXZSBkbyBpdCB0aGlzIHdheSBzbyB3ZSBjYW4gaW5jcmVtZW50YWxseSBhZGQgbWF0ZXJpYWxpemVkXG4gICAgLy8gY29sdW1ucyBhZnRlciB0aGUgZmlyc3QgcGFzcyBhbmQgYXZvaWQgZXhjZXNzaXZlIGxvb3BpbmdcbiAgICB2YXIgYWNjZXNzUm93ID0gZnVuY3Rpb24gYWNjZXNzUm93KG9yaWdpbmFsUm93LCByb3dJbmRleCwgZGVwdGgsIHBhcmVudCwgcGFyZW50Um93cykge1xuICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVwdGggPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBLZWVwIHRoZSBvcmlnaW5hbCByZWZlcmVuY2UgYXJvdW5kXG4gICAgICB2YXIgb3JpZ2luYWwgPSBvcmlnaW5hbFJvdztcbiAgICAgIHZhciBpZCA9IGdldFJvd0lkKG9yaWdpbmFsUm93LCByb3dJbmRleCwgcGFyZW50KTtcbiAgICAgIHZhciByb3cgPSByb3dzQnlJZFtpZF07IC8vIElmIHRoZSByb3cgaGFzbid0IGJlZW4gY3JlYXRlZCwgbGV0J3MgbWFrZSBpdFxuXG4gICAgICBpZiAoIXJvdykge1xuICAgICAgICByb3cgPSB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIG9yaWdpbmFsOiBvcmlnaW5hbCxcbiAgICAgICAgICBpbmRleDogcm93SW5kZXgsXG4gICAgICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgICAgIGNlbGxzOiBbe31dIC8vIFRoaXMgaXMgYSBkdW1teSBjZWxsXG5cbiAgICAgICAgfTsgLy8gT3ZlcnJpZGUgY29tbW9uIGFycmF5IGZ1bmN0aW9ucyAoYW5kIHRoZSBkdW1teSBjZWxsJ3MgZ2V0Q2VsbFByb3BzIGZ1bmN0aW9uKVxuICAgICAgICAvLyB0byBzaG93IGFuIGVycm9yIGlmIGl0IGlzIGFjY2Vzc2VkIHdpdGhvdXQgY2FsbGluZyBwcmVwYXJlUm93XG5cbiAgICAgICAgcm93LmNlbGxzLm1hcCA9IHVucHJlcGFyZWRBY2Nlc3NXYXJuaW5nO1xuICAgICAgICByb3cuY2VsbHMuZmlsdGVyID0gdW5wcmVwYXJlZEFjY2Vzc1dhcm5pbmc7XG4gICAgICAgIHJvdy5jZWxscy5mb3JFYWNoID0gdW5wcmVwYXJlZEFjY2Vzc1dhcm5pbmc7XG4gICAgICAgIHJvdy5jZWxsc1swXS5nZXRDZWxsUHJvcHMgPSB1bnByZXBhcmVkQWNjZXNzV2FybmluZzsgLy8gQ3JlYXRlIHRoZSBjZWxscyBhbmQgdmFsdWVzXG5cbiAgICAgICAgcm93LnZhbHVlcyA9IHt9OyAvLyBQdXNoIHRoaXMgcm93IGludG8gdGhlIHBhcmVudFJvd3MgYXJyYXlcblxuICAgICAgICBwYXJlbnRSb3dzLnB1c2gocm93KTsgLy8gS2VlcCB0cmFjayBvZiBldmVyeSByb3cgaW4gYSBmbGF0IGFycmF5XG5cbiAgICAgICAgZmxhdFJvd3MucHVzaChyb3cpOyAvLyBBbHNvIGtlZXAgdHJhY2sgb2YgZXZlcnkgcm93IGJ5IGl0cyBJRFxuXG4gICAgICAgIHJvd3NCeUlkW2lkXSA9IHJvdzsgLy8gR2V0IHRoZSBvcmlnaW5hbCBzdWJyb3dzXG5cbiAgICAgICAgcm93Lm9yaWdpbmFsU3ViUm93cyA9IGdldFN1YlJvd3Mob3JpZ2luYWxSb3csIHJvd0luZGV4KTsgLy8gVGhlbiByZWN1cnNpdmVseSBhY2Nlc3MgdGhlbVxuXG4gICAgICAgIGlmIChyb3cub3JpZ2luYWxTdWJSb3dzKSB7XG4gICAgICAgICAgdmFyIHN1YlJvd3MgPSBbXTtcbiAgICAgICAgICByb3cub3JpZ2luYWxTdWJSb3dzLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NSb3coZCwgaSwgZGVwdGggKyAxLCByb3csIHN1YlJvd3MpO1xuICAgICAgICAgIH0pOyAvLyBLZWVwIHRoZSBuZXcgc3ViUm93cyBhcnJheSBvbiB0aGUgcm93XG5cbiAgICAgICAgICByb3cuc3ViUm93cyA9IHN1YlJvd3M7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocm93LnN1YlJvd3MpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJvdyBleGlzdHMsIHRoZW4gaXQncyBhbHJlYWR5IGJlZW4gYWNjZXNzZWRcbiAgICAgICAgLy8gS2VlcCByZWN1cnNpbmcsIGJ1dCBkb24ndCB3b3JyeSBhYm91dCBwYXNzaW5nIHRoZVxuICAgICAgICAvLyBhY2N1bWxhdG9yIGFycmF5ICh0aG9zZSByb3dzIGFscmVhZHkgZXhpc3QpXG4gICAgICAgIHJvdy5vcmlnaW5hbFN1YlJvd3MuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgIHJldHVybiBhY2Nlc3NSb3coZCwgaSwgZGVwdGggKyAxLCByb3cpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gSWYgdGhlIGNvbHVtbiBoYXMgYW4gYWNjZXNzb3IsIHVzZSBpdCB0byBnZXQgYSB2YWx1ZVxuXG5cbiAgICAgIGlmIChjb2x1bW4uYWNjZXNzb3IpIHtcbiAgICAgICAgcm93LnZhbHVlc1tjb2x1bW4uaWRdID0gY29sdW1uLmFjY2Vzc29yKG9yaWdpbmFsUm93LCByb3dJbmRleCwgcm93LCBwYXJlbnRSb3dzLCBkYXRhKTtcbiAgICAgIH0gLy8gQWxsb3cgcGx1Z2lucyB0byBtYW5pcHVsYXRlIHRoZSBjb2x1bW4gdmFsdWVcblxuXG4gICAgICByb3cudmFsdWVzW2NvbHVtbi5pZF0gPSByZWR1Y2VIb29rcyhhY2Nlc3NWYWx1ZUhvb2tzLCByb3cudmFsdWVzW2NvbHVtbi5pZF0sIHtcbiAgICAgICAgcm93OiByb3csXG4gICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAob3JpZ2luYWxSb3csIHJvd0luZGV4KSB7XG4gICAgICByZXR1cm4gYWNjZXNzUm93KG9yaWdpbmFsUm93LCByb3dJbmRleCwgMCwgdW5kZWZpbmVkLCByb3dzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFjdGlvbnMucmVzZXRFeHBhbmRlZCA9ICdyZXNldEV4cGFuZGVkJztcbiAgYWN0aW9ucy50b2dnbGVSb3dFeHBhbmRlZCA9ICd0b2dnbGVSb3dFeHBhbmRlZCc7XG4gIGFjdGlvbnMudG9nZ2xlQWxsUm93c0V4cGFuZGVkID0gJ3RvZ2dsZUFsbFJvd3NFeHBhbmRlZCc7XG4gIHZhciB1c2VFeHBhbmRlZCA9IGZ1bmN0aW9uIHVzZUV4cGFuZGVkKGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkUHJvcHMgPSBbZGVmYXVsdEdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZFByb3BzXTtcbiAgICBob29rcy5nZXRUb2dnbGVSb3dFeHBhbmRlZFByb3BzID0gW2RlZmF1bHRHZXRUb2dnbGVSb3dFeHBhbmRlZFByb3BzXTtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciQxKTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJDEpO1xuICAgIGhvb2tzLnByZXBhcmVSb3cucHVzaChwcmVwYXJlUm93KTtcbiAgfTtcbiAgdXNlRXhwYW5kZWQucGx1Z2luTmFtZSA9ICd1c2VFeHBhbmRlZCc7XG5cbiAgdmFyIGRlZmF1bHRHZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRQcm9wcyhwcm9wcywgX3JlZikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2U7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgIGluc3RhbmNlLnRvZ2dsZUFsbFJvd3NFeHBhbmRlZCgpO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LFxuICAgICAgdGl0bGU6ICdUb2dnbGUgQWxsIFJvd3MgRXhwYW5kZWQnXG4gICAgfV07XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRUb2dnbGVSb3dFeHBhbmRlZFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFRvZ2dsZVJvd0V4cGFuZGVkUHJvcHMocHJvcHMsIF9yZWYyKSB7XG4gICAgdmFyIHJvdyA9IF9yZWYyLnJvdztcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgICByb3cudG9nZ2xlUm93RXhwYW5kZWQoKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgfSxcbiAgICAgIHRpdGxlOiAnVG9nZ2xlIFJvdyBFeHBhbmRlZCdcbiAgICB9XTtcbiAgfTsgLy8gUmVkdWNlclxuXG5cbiAgZnVuY3Rpb24gcmVkdWNlciQxKHN0YXRlLCBhY3Rpb24sIHByZXZpb3VzU3RhdGUsIGluc3RhbmNlKSB7XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmluaXQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIGV4cGFuZGVkOiB7fVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldEV4cGFuZGVkKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGV4cGFuZGVkOiBpbnN0YW5jZS5pbml0aWFsU3RhdGUuZXhwYW5kZWQgfHwge31cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy50b2dnbGVBbGxSb3dzRXhwYW5kZWQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgIHZhciByb3dzQnlJZCA9IGluc3RhbmNlLnJvd3NCeUlkO1xuICAgICAgdmFyIGlzQWxsUm93c0V4cGFuZGVkID0gT2JqZWN0LmtleXMocm93c0J5SWQpLmxlbmd0aCA9PT0gT2JqZWN0LmtleXMoc3RhdGUuZXhwYW5kZWQpLmxlbmd0aDtcbiAgICAgIHZhciBleHBhbmRBbGwgPSB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAhaXNBbGxSb3dzRXhwYW5kZWQ7XG5cbiAgICAgIGlmIChleHBhbmRBbGwpIHtcbiAgICAgICAgdmFyIGV4cGFuZGVkID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHJvd3NCeUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChyb3dJZCkge1xuICAgICAgICAgIGV4cGFuZGVkW3Jvd0lkXSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgZXhwYW5kZWQ6IGV4cGFuZGVkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGV4cGFuZGVkOiB7fVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZVJvd0V4cGFuZGVkKSB7XG4gICAgICB2YXIgaWQgPSBhY3Rpb24uaWQsXG4gICAgICAgICAgc2V0RXhwYW5kZWQgPSBhY3Rpb24udmFsdWU7XG4gICAgICB2YXIgZXhpc3RzID0gc3RhdGUuZXhwYW5kZWRbaWRdO1xuICAgICAgdmFyIHNob3VsZEV4aXN0ID0gdHlwZW9mIHNldEV4cGFuZGVkICE9PSAndW5kZWZpbmVkJyA/IHNldEV4cGFuZGVkIDogIWV4aXN0cztcblxuICAgICAgaWYgKCFleGlzdHMgJiYgc2hvdWxkRXhpc3QpIHtcbiAgICAgICAgdmFyIF9leHRlbmRzMjtcblxuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgZXhwYW5kZWQ6IF9leHRlbmRzKHt9LCBzdGF0ZS5leHBhbmRlZCwgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbaWRdID0gdHJ1ZSwgX2V4dGVuZHMyKSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0cyAmJiAhc2hvdWxkRXhpc3QpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSRleHBhbmRlZCA9IHN0YXRlLmV4cGFuZGVkLFxuICAgICAgICAgICAgXyA9IF9zdGF0ZSRleHBhbmRlZFtpZF0sXG4gICAgICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3N0YXRlJGV4cGFuZGVkLCBbaWRdLm1hcChfdG9Qcm9wZXJ0eUtleSkpO1xuXG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgICBleHBhbmRlZDogcmVzdFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSQxKGluc3RhbmNlKSB7XG4gICAgdmFyIGRhdGEgPSBpbnN0YW5jZS5kYXRhLFxuICAgICAgICByb3dzID0gaW5zdGFuY2Uucm93cyxcbiAgICAgICAgcm93c0J5SWQgPSBpbnN0YW5jZS5yb3dzQnlJZCxcbiAgICAgICAgX2luc3RhbmNlJG1hbnVhbEV4cGFuID0gaW5zdGFuY2UubWFudWFsRXhwYW5kZWRLZXksXG4gICAgICAgIG1hbnVhbEV4cGFuZGVkS2V5ID0gX2luc3RhbmNlJG1hbnVhbEV4cGFuID09PSB2b2lkIDAgPyAnZXhwYW5kZWQnIDogX2luc3RhbmNlJG1hbnVhbEV4cGFuLFxuICAgICAgICBfaW5zdGFuY2UkcGFnaW5hdGVFeHAgPSBpbnN0YW5jZS5wYWdpbmF0ZUV4cGFuZGVkUm93cyxcbiAgICAgICAgcGFnaW5hdGVFeHBhbmRlZFJvd3MgPSBfaW5zdGFuY2UkcGFnaW5hdGVFeHAgPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkcGFnaW5hdGVFeHAsXG4gICAgICAgIF9pbnN0YW5jZSRleHBhbmRTdWJSbyA9IGluc3RhbmNlLmV4cGFuZFN1YlJvd3MsXG4gICAgICAgIGV4cGFuZFN1YlJvd3MgPSBfaW5zdGFuY2UkZXhwYW5kU3ViUm8gPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkZXhwYW5kU3ViUm8sXG4gICAgICAgIF9pbnN0YW5jZSRhdXRvUmVzZXRFeCA9IGluc3RhbmNlLmF1dG9SZXNldEV4cGFuZGVkLFxuICAgICAgICBhdXRvUmVzZXRFeHBhbmRlZCA9IF9pbnN0YW5jZSRhdXRvUmVzZXRFeCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRFeCxcbiAgICAgICAgZ2V0SG9va3MgPSBpbnN0YW5jZS5nZXRIb29rcyxcbiAgICAgICAgcGx1Z2lucyA9IGluc3RhbmNlLnBsdWdpbnMsXG4gICAgICAgIGV4cGFuZGVkID0gaW5zdGFuY2Uuc3RhdGUuZXhwYW5kZWQsXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2g7XG4gICAgZW5zdXJlUGx1Z2luT3JkZXIocGx1Z2lucywgWyd1c2VTb3J0QnknLCAndXNlR3JvdXBCeScsICd1c2VQaXZvdENvbHVtbnMnLCAndXNlR2xvYmFsRmlsdGVyJ10sICd1c2VFeHBhbmRlZCcpO1xuICAgIHZhciBnZXRBdXRvUmVzZXRFeHBhbmRlZCA9IHVzZUdldExhdGVzdChhdXRvUmVzZXRFeHBhbmRlZCk7XG4gICAgdmFyIGlzQWxsUm93c0V4cGFuZGVkID0gQm9vbGVhbihPYmplY3Qua2V5cyhyb3dzQnlJZCkubGVuZ3RoICYmIE9iamVjdC5rZXlzKGV4cGFuZGVkKS5sZW5ndGgpO1xuXG4gICAgaWYgKGlzQWxsUm93c0V4cGFuZGVkKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMocm93c0J5SWQpLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiAhZXhwYW5kZWRbaWRdO1xuICAgICAgfSkpIHtcbiAgICAgICAgaXNBbGxSb3dzRXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IC8vIEJ5cGFzcyBhbnkgZWZmZWN0cyBmcm9tIGZpcmluZyB3aGVuIHRoaXMgY2hhbmdlc1xuXG5cbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRFeHBhbmRlZCgpKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLnJlc2V0RXhwYW5kZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2Rpc3BhdGNoLCBkYXRhXSk7XG4gICAgdmFyIHRvZ2dsZVJvd0V4cGFuZGVkID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGlkLCB2YWx1ZSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZVJvd0V4cGFuZGVkLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIHRvZ2dsZUFsbFJvd3NFeHBhbmRlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy50b2dnbGVBbGxSb3dzRXhwYW5kZWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIGV4cGFuZGVkUm93cyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHBhZ2luYXRlRXhwYW5kZWRSb3dzKSB7XG4gICAgICAgIHJldHVybiBleHBhbmRSb3dzKHJvd3MsIHtcbiAgICAgICAgICBtYW51YWxFeHBhbmRlZEtleTogbWFudWFsRXhwYW5kZWRLZXksXG4gICAgICAgICAgZXhwYW5kZWQ6IGV4cGFuZGVkLFxuICAgICAgICAgIGV4cGFuZFN1YlJvd3M6IGV4cGFuZFN1YlJvd3NcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH0sIFtwYWdpbmF0ZUV4cGFuZGVkUm93cywgcm93cywgbWFudWFsRXhwYW5kZWRLZXksIGV4cGFuZGVkLCBleHBhbmRTdWJSb3dzXSk7XG4gICAgdmFyIGV4cGFuZGVkRGVwdGggPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmaW5kRXhwYW5kZWREZXB0aChleHBhbmRlZCk7XG4gICAgfSwgW2V4cGFuZGVkXSk7XG4gICAgdmFyIGdldEluc3RhbmNlID0gdXNlR2V0TGF0ZXN0KGluc3RhbmNlKTtcbiAgICB2YXIgZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZFByb3BzLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIHByZUV4cGFuZGVkUm93czogcm93cyxcbiAgICAgIGV4cGFuZGVkUm93czogZXhwYW5kZWRSb3dzLFxuICAgICAgcm93czogZXhwYW5kZWRSb3dzLFxuICAgICAgZXhwYW5kZWREZXB0aDogZXhwYW5kZWREZXB0aCxcbiAgICAgIGlzQWxsUm93c0V4cGFuZGVkOiBpc0FsbFJvd3NFeHBhbmRlZCxcbiAgICAgIHRvZ2dsZVJvd0V4cGFuZGVkOiB0b2dnbGVSb3dFeHBhbmRlZCxcbiAgICAgIHRvZ2dsZUFsbFJvd3NFeHBhbmRlZDogdG9nZ2xlQWxsUm93c0V4cGFuZGVkLFxuICAgICAgZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkUHJvcHM6IGdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZFByb3BzXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlUm93KHJvdywgX3JlZjMpIHtcbiAgICB2YXIgZ2V0SG9va3MgPSBfcmVmMy5pbnN0YW5jZS5nZXRIb29rcyxcbiAgICAgICAgaW5zdGFuY2UgPSBfcmVmMy5pbnN0YW5jZTtcblxuICAgIHJvdy50b2dnbGVSb3dFeHBhbmRlZCA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS50b2dnbGVSb3dFeHBhbmRlZChyb3cuaWQsIHNldCk7XG4gICAgfTtcblxuICAgIHJvdy5nZXRUb2dnbGVSb3dFeHBhbmRlZFByb3BzID0gbWFrZVByb3BHZXR0ZXIoZ2V0SG9va3MoKS5nZXRUb2dnbGVSb3dFeHBhbmRlZFByb3BzLCB7XG4gICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICByb3c6IHJvd1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEV4cGFuZGVkRGVwdGgoZXhwYW5kZWQpIHtcbiAgICB2YXIgbWF4RGVwdGggPSAwO1xuICAgIE9iamVjdC5rZXlzKGV4cGFuZGVkKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgdmFyIHNwbGl0SWQgPSBpZC5zcGxpdCgnLicpO1xuICAgICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgc3BsaXRJZC5sZW5ndGgpO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXhEZXB0aDtcbiAgfVxuXG4gIHZhciB0ZXh0ID0gZnVuY3Rpb24gdGV4dChyb3dzLCBpZHMsIGZpbHRlclZhbHVlKSB7XG4gICAgcm93cyA9IHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJvd1ZhbHVlID0gcm93LnZhbHVlc1tpZF07XG4gICAgICAgIHJldHVybiBTdHJpbmcocm93VmFsdWUpLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoU3RyaW5nKGZpbHRlclZhbHVlKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByb3dzO1xuICB9O1xuXG4gIHRleHQuYXV0b1JlbW92ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gIXZhbDtcbiAgfTtcblxuICB2YXIgZXhhY3RUZXh0ID0gZnVuY3Rpb24gZXhhY3RUZXh0KHJvd3MsIGlkcywgZmlsdGVyVmFsdWUpIHtcbiAgICByZXR1cm4gcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcm93VmFsdWUgPSByb3cudmFsdWVzW2lkXTtcbiAgICAgICAgcmV0dXJuIHJvd1ZhbHVlICE9PSB1bmRlZmluZWQgPyBTdHJpbmcocm93VmFsdWUpLnRvTG93ZXJDYXNlKCkgPT09IFN0cmluZyhmaWx0ZXJWYWx1ZSkudG9Mb3dlckNhc2UoKSA6IHRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBleGFjdFRleHQuYXV0b1JlbW92ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gIXZhbDtcbiAgfTtcblxuICB2YXIgZXhhY3RUZXh0Q2FzZSA9IGZ1bmN0aW9uIGV4YWN0VGV4dENhc2Uocm93cywgaWRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgIHJldHVybiByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciByb3dWYWx1ZSA9IHJvdy52YWx1ZXNbaWRdO1xuICAgICAgICByZXR1cm4gcm93VmFsdWUgIT09IHVuZGVmaW5lZCA/IFN0cmluZyhyb3dWYWx1ZSkgPT09IFN0cmluZyhmaWx0ZXJWYWx1ZSkgOiB0cnVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgZXhhY3RUZXh0Q2FzZS5hdXRvUmVtb3ZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiAhdmFsO1xuICB9O1xuXG4gIHZhciBpbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKHJvd3MsIGlkcywgZmlsdGVyVmFsdWUpIHtcbiAgICByZXR1cm4gcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcm93VmFsdWUgPSByb3cudmFsdWVzW2lkXTtcbiAgICAgICAgcmV0dXJuIHJvd1ZhbHVlLmluY2x1ZGVzKGZpbHRlclZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGluY2x1ZGVzLmF1dG9SZW1vdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuICF2YWwgfHwgIXZhbC5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGluY2x1ZGVzQWxsID0gZnVuY3Rpb24gaW5jbHVkZXNBbGwocm93cywgaWRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgIHJldHVybiByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciByb3dWYWx1ZSA9IHJvdy52YWx1ZXNbaWRdO1xuICAgICAgICByZXR1cm4gcm93VmFsdWUgJiYgcm93VmFsdWUubGVuZ3RoICYmIGZpbHRlclZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gcm93VmFsdWUuaW5jbHVkZXModmFsKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBpbmNsdWRlc0FsbC5hdXRvUmVtb3ZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiAhdmFsIHx8ICF2YWwubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBpbmNsdWRlc1NvbWUgPSBmdW5jdGlvbiBpbmNsdWRlc1NvbWUocm93cywgaWRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgIHJldHVybiByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciByb3dWYWx1ZSA9IHJvdy52YWx1ZXNbaWRdO1xuICAgICAgICByZXR1cm4gcm93VmFsdWUgJiYgcm93VmFsdWUubGVuZ3RoICYmIGZpbHRlclZhbHVlLnNvbWUoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIHJldHVybiByb3dWYWx1ZS5pbmNsdWRlcyh2YWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGluY2x1ZGVzU29tZS5hdXRvUmVtb3ZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiAhdmFsIHx8ICF2YWwubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBpbmNsdWRlc1ZhbHVlID0gZnVuY3Rpb24gaW5jbHVkZXNWYWx1ZShyb3dzLCBpZHMsIGZpbHRlclZhbHVlKSB7XG4gICAgcmV0dXJuIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJvd1ZhbHVlID0gcm93LnZhbHVlc1tpZF07XG4gICAgICAgIHJldHVybiBmaWx0ZXJWYWx1ZS5pbmNsdWRlcyhyb3dWYWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBpbmNsdWRlc1ZhbHVlLmF1dG9SZW1vdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuICF2YWwgfHwgIXZhbC5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGV4YWN0ID0gZnVuY3Rpb24gZXhhY3Qocm93cywgaWRzLCBmaWx0ZXJWYWx1ZSkge1xuICAgIHJldHVybiByb3dzLmZpbHRlcihmdW5jdGlvbiAocm93KSB7XG4gICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciByb3dWYWx1ZSA9IHJvdy52YWx1ZXNbaWRdO1xuICAgICAgICByZXR1cm4gcm93VmFsdWUgPT09IGZpbHRlclZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgZXhhY3QuYXV0b1JlbW92ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG4gIH07XG5cbiAgdmFyIGVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhyb3dzLCBpZHMsIGZpbHRlclZhbHVlKSB7XG4gICAgcmV0dXJuIHJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJvd1ZhbHVlID0gcm93LnZhbHVlc1tpZF07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuICAgICAgICByZXR1cm4gcm93VmFsdWUgPT0gZmlsdGVyVmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBlcXVhbHMuYXV0b1JlbW92ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09IG51bGw7XG4gIH07XG5cbiAgdmFyIGJldHdlZW4gPSBmdW5jdGlvbiBiZXR3ZWVuKHJvd3MsIGlkcywgZmlsdGVyVmFsdWUpIHtcbiAgICB2YXIgX3JlZiA9IGZpbHRlclZhbHVlIHx8IFtdLFxuICAgICAgICBtaW4gPSBfcmVmWzBdLFxuICAgICAgICBtYXggPSBfcmVmWzFdO1xuXG4gICAgbWluID0gdHlwZW9mIG1pbiA9PT0gJ251bWJlcicgPyBtaW4gOiAtSW5maW5pdHk7XG4gICAgbWF4ID0gdHlwZW9mIG1heCA9PT0gJ251bWJlcicgPyBtYXggOiBJbmZpbml0eTtcblxuICAgIGlmIChtaW4gPiBtYXgpIHtcbiAgICAgIHZhciB0ZW1wID0gbWluO1xuICAgICAgbWluID0gbWF4O1xuICAgICAgbWF4ID0gdGVtcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcm93VmFsdWUgPSByb3cudmFsdWVzW2lkXTtcbiAgICAgICAgcmV0dXJuIHJvd1ZhbHVlID49IG1pbiAmJiByb3dWYWx1ZSA8PSBtYXg7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBiZXR3ZWVuLmF1dG9SZW1vdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuICF2YWwgfHwgdHlwZW9mIHZhbFswXSAhPT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbFsxXSAhPT0gJ251bWJlcic7XG4gIH07XG5cbiAgdmFyIGZpbHRlclR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB0ZXh0OiB0ZXh0LFxuICAgIGV4YWN0VGV4dDogZXhhY3RUZXh0LFxuICAgIGV4YWN0VGV4dENhc2U6IGV4YWN0VGV4dENhc2UsXG4gICAgaW5jbHVkZXM6IGluY2x1ZGVzLFxuICAgIGluY2x1ZGVzQWxsOiBpbmNsdWRlc0FsbCxcbiAgICBpbmNsdWRlc1NvbWU6IGluY2x1ZGVzU29tZSxcbiAgICBpbmNsdWRlc1ZhbHVlOiBpbmNsdWRlc1ZhbHVlLFxuICAgIGV4YWN0OiBleGFjdCxcbiAgICBlcXVhbHM6IGVxdWFscyxcbiAgICBiZXR3ZWVuOiBiZXR3ZWVuXG4gIH0pO1xuXG4gIGFjdGlvbnMucmVzZXRGaWx0ZXJzID0gJ3Jlc2V0RmlsdGVycyc7XG4gIGFjdGlvbnMuc2V0RmlsdGVyID0gJ3NldEZpbHRlcic7XG4gIGFjdGlvbnMuc2V0QWxsRmlsdGVycyA9ICdzZXRBbGxGaWx0ZXJzJztcbiAgdmFyIHVzZUZpbHRlcnMgPSBmdW5jdGlvbiB1c2VGaWx0ZXJzKGhvb2tzKSB7XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkMik7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSQyKTtcbiAgfTtcbiAgdXNlRmlsdGVycy5wbHVnaW5OYW1lID0gJ3VzZUZpbHRlcnMnO1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIkMihzdGF0ZSwgYWN0aW9uLCBwcmV2aW91c1N0YXRlLCBpbnN0YW5jZSkge1xuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBmaWx0ZXJzOiBbXVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldEZpbHRlcnMpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgZmlsdGVyczogaW5zdGFuY2UuaW5pdGlhbFN0YXRlLmZpbHRlcnMgfHwgW11cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5zZXRGaWx0ZXIpIHtcbiAgICAgIHZhciBjb2x1bW5JZCA9IGFjdGlvbi5jb2x1bW5JZCxcbiAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IGFjdGlvbi5maWx0ZXJWYWx1ZTtcbiAgICAgIHZhciBhbGxDb2x1bW5zID0gaW5zdGFuY2UuYWxsQ29sdW1ucyxcbiAgICAgICAgICB1c2VyRmlsdGVyVHlwZXMgPSBpbnN0YW5jZS5maWx0ZXJUeXBlcztcbiAgICAgIHZhciBjb2x1bW4gPSBhbGxDb2x1bW5zLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IGNvbHVtbklkO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0LVRhYmxlOiBDb3VsZCBub3QgZmluZCBhIGNvbHVtbiB3aXRoIGlkOiBcIiArIGNvbHVtbklkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbHRlck1ldGhvZCA9IGdldEZpbHRlck1ldGhvZChjb2x1bW4uZmlsdGVyLCB1c2VyRmlsdGVyVHlwZXMgfHwge30sIGZpbHRlclR5cGVzKTtcbiAgICAgIHZhciBwcmV2aW91c2ZpbHRlciA9IHN0YXRlLmZpbHRlcnMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5pZCA9PT0gY29sdW1uSWQ7XG4gICAgICB9KTtcbiAgICAgIHZhciBuZXdGaWx0ZXIgPSBmdW5jdGlvbmFsVXBkYXRlKGZpbHRlclZhbHVlLCBwcmV2aW91c2ZpbHRlciAmJiBwcmV2aW91c2ZpbHRlci52YWx1ZSk7IC8vXG5cbiAgICAgIGlmIChzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlck1ldGhvZC5hdXRvUmVtb3ZlLCBuZXdGaWx0ZXIsIGNvbHVtbikpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIGZpbHRlcnM6IHN0YXRlLmZpbHRlcnMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5pZCAhPT0gY29sdW1uSWQ7XG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2aW91c2ZpbHRlcikge1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmIChkLmlkID09PSBjb2x1bW5JZCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBjb2x1bW5JZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3RmlsdGVyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGZpbHRlcnM6IFtdLmNvbmNhdChzdGF0ZS5maWx0ZXJzLCBbe1xuICAgICAgICAgIGlkOiBjb2x1bW5JZCxcbiAgICAgICAgICB2YWx1ZTogbmV3RmlsdGVyXG4gICAgICAgIH1dKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnNldEFsbEZpbHRlcnMpIHtcbiAgICAgIHZhciBmaWx0ZXJzID0gYWN0aW9uLmZpbHRlcnM7XG4gICAgICB2YXIgX2FsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICAgIF91c2VyRmlsdGVyVHlwZXMgPSBpbnN0YW5jZS5maWx0ZXJUeXBlcztcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgLy8gRmlsdGVyIG91dCB1bmRlZmluZWQgdmFsdWVzXG4gICAgICAgIGZpbHRlcnM6IGZ1bmN0aW9uYWxVcGRhdGUoZmlsdGVycywgc3RhdGUuZmlsdGVycykuZmlsdGVyKGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICB2YXIgY29sdW1uID0gX2FsbENvbHVtbnMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQuaWQgPT09IGZpbHRlci5pZDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBmaWx0ZXJNZXRob2QgPSBnZXRGaWx0ZXJNZXRob2QoY29sdW1uLmZpbHRlciwgX3VzZXJGaWx0ZXJUeXBlcyB8fCB7fSwgZmlsdGVyVHlwZXMpO1xuXG4gICAgICAgICAgaWYgKHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyTWV0aG9kLmF1dG9SZW1vdmUsIGZpbHRlci52YWx1ZSwgY29sdW1uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkMihpbnN0YW5jZSkge1xuICAgIHZhciBkYXRhID0gaW5zdGFuY2UuZGF0YSxcbiAgICAgICAgcm93cyA9IGluc3RhbmNlLnJvd3MsXG4gICAgICAgIGZsYXRSb3dzID0gaW5zdGFuY2UuZmxhdFJvd3MsXG4gICAgICAgIHJvd3NCeUlkID0gaW5zdGFuY2Uucm93c0J5SWQsXG4gICAgICAgIGFsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICB1c2VyRmlsdGVyVHlwZXMgPSBpbnN0YW5jZS5maWx0ZXJUeXBlcyxcbiAgICAgICAgbWFudWFsRmlsdGVycyA9IGluc3RhbmNlLm1hbnVhbEZpbHRlcnMsXG4gICAgICAgIF9pbnN0YW5jZSRkZWZhdWx0Q2FuRiA9IGluc3RhbmNlLmRlZmF1bHRDYW5GaWx0ZXIsXG4gICAgICAgIGRlZmF1bHRDYW5GaWx0ZXIgPSBfaW5zdGFuY2UkZGVmYXVsdENhbkYgPT09IHZvaWQgMCA/IGZhbHNlIDogX2luc3RhbmNlJGRlZmF1bHRDYW5GLFxuICAgICAgICBkaXNhYmxlRmlsdGVycyA9IGluc3RhbmNlLmRpc2FibGVGaWx0ZXJzLFxuICAgICAgICBmaWx0ZXJzID0gaW5zdGFuY2Uuc3RhdGUuZmlsdGVycyxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaCxcbiAgICAgICAgX2luc3RhbmNlJGF1dG9SZXNldEZpID0gaW5zdGFuY2UuYXV0b1Jlc2V0RmlsdGVycyxcbiAgICAgICAgYXV0b1Jlc2V0RmlsdGVycyA9IF9pbnN0YW5jZSRhdXRvUmVzZXRGaSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRGaTtcbiAgICB2YXIgc2V0RmlsdGVyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnNldEZpbHRlcixcbiAgICAgICAgY29sdW1uSWQ6IGNvbHVtbklkLFxuICAgICAgICBmaWx0ZXJWYWx1ZTogZmlsdGVyVmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIHZhciBzZXRBbGxGaWx0ZXJzID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGZpbHRlcnMpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy5zZXRBbGxGaWx0ZXJzLFxuICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICBhbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgdmFyIGlkID0gY29sdW1uLmlkLFxuICAgICAgICAgIGFjY2Vzc29yID0gY29sdW1uLmFjY2Vzc29yLFxuICAgICAgICAgIGNvbHVtbkRlZmF1bHRDYW5GaWx0ZXIgPSBjb2x1bW4uZGVmYXVsdENhbkZpbHRlcixcbiAgICAgICAgICBjb2x1bW5EaXNhYmxlRmlsdGVycyA9IGNvbHVtbi5kaXNhYmxlRmlsdGVyczsgLy8gRGV0ZXJtaW5lIGlmIGEgY29sdW1uIGlzIGZpbHRlcmFibGVcblxuICAgICAgY29sdW1uLmNhbkZpbHRlciA9IGFjY2Vzc29yID8gZ2V0Rmlyc3REZWZpbmVkKGNvbHVtbkRpc2FibGVGaWx0ZXJzID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIGRpc2FibGVGaWx0ZXJzID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIHRydWUpIDogZ2V0Rmlyc3REZWZpbmVkKGNvbHVtbkRlZmF1bHRDYW5GaWx0ZXIsIGRlZmF1bHRDYW5GaWx0ZXIsIGZhbHNlKTsgLy8gUHJvdmlkZSB0aGUgY29sdW1uIGEgd2F5IG9mIHVwZGF0aW5nIHRoZSBmaWx0ZXIgdmFsdWVcblxuICAgICAgY29sdW1uLnNldEZpbHRlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHNldEZpbHRlcihjb2x1bW4uaWQsIHZhbCk7XG4gICAgICB9OyAvLyBQcm92aWRlIHRoZSBjdXJyZW50IGZpbHRlciB2YWx1ZSB0byB0aGUgY29sdW1uIGZvclxuICAgICAgLy8gY29udmVuaWVuY2VcblxuXG4gICAgICB2YXIgZm91bmQgPSBmaWx0ZXJzLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IGlkO1xuICAgICAgfSk7XG4gICAgICBjb2x1bW4uZmlsdGVyVmFsdWUgPSBmb3VuZCAmJiBmb3VuZC52YWx1ZTtcbiAgICB9KTtcblxuICAgIHZhciBfUmVhY3QkdXNlTWVtbyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1hbnVhbEZpbHRlcnMgfHwgIWZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbcm93cywgZmxhdFJvd3MsIHJvd3NCeUlkXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbHRlcmVkRmxhdFJvd3MgPSBbXTtcbiAgICAgIHZhciBmaWx0ZXJlZFJvd3NCeUlkID0ge307IC8vIEZpbHRlcnMgdG9wIGxldmVsIGFuZCBuZXN0ZWQgcm93c1xuXG4gICAgICB2YXIgZmlsdGVyUm93cyA9IGZ1bmN0aW9uIGZpbHRlclJvd3Mocm93cywgZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgICBkZXB0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsdGVyZWRSb3dzID0gcm93cztcbiAgICAgICAgZmlsdGVyZWRSb3dzID0gZmlsdGVycy5yZWR1Y2UoZnVuY3Rpb24gKGZpbHRlcmVkU29GYXIsIF9yZWYpIHtcbiAgICAgICAgICB2YXIgY29sdW1uSWQgPSBfcmVmLmlkLFxuICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZSA9IF9yZWYudmFsdWU7XG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlsdGVycyBjb2x1bW5cbiAgICAgICAgICB2YXIgY29sdW1uID0gYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gY29sdW1uSWQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkU29GYXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICBjb2x1bW4ucHJlRmlsdGVyZWRSb3dzID0gZmlsdGVyZWRTb0ZhcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZmlsdGVyTWV0aG9kID0gZ2V0RmlsdGVyTWV0aG9kKGNvbHVtbi5maWx0ZXIsIHVzZXJGaWx0ZXJUeXBlcyB8fCB7fSwgZmlsdGVyVHlwZXMpO1xuXG4gICAgICAgICAgaWYgKCFmaWx0ZXJNZXRob2QpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIGEgdmFsaWQgJ2NvbHVtbi5maWx0ZXInIGZvciBjb2x1bW4gd2l0aCB0aGUgSUQ6IFwiICsgY29sdW1uLmlkICsgXCIuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkU29GYXI7XG4gICAgICAgICAgfSAvLyBQYXNzIHRoZSByb3dzLCBpZCwgZmlsdGVyVmFsdWUgYW5kIGNvbHVtbiB0byB0aGUgZmlsdGVyTWV0aG9kXG4gICAgICAgICAgLy8gdG8gZ2V0IHRoZSBmaWx0ZXJlZCByb3dzIGJhY2tcblxuXG4gICAgICAgICAgY29sdW1uLmZpbHRlcmVkUm93cyA9IGZpbHRlck1ldGhvZChmaWx0ZXJlZFNvRmFyLCBbY29sdW1uSWRdLCBmaWx0ZXJWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGNvbHVtbi5maWx0ZXJlZFJvd3M7XG4gICAgICAgIH0sIHJvd3MpOyAvLyBBcHBseSB0aGUgZmlsdGVyIHRvIGFueSBzdWJSb3dzXG4gICAgICAgIC8vIFdlIHRlY2huaWNhbGx5IGNvdWxkIGRvIHRoaXMgcmVjdXJzaXZlbHkgaW4gdGhlIGFib3ZlIGxvb3AsXG4gICAgICAgIC8vIGJ1dCB0aGF0IHdvdWxkIHNldmVyZWx5IGhpbmRlciB0aGUgQVBJIGZvciB0aGUgdXNlciwgc2luY2UgdGhleVxuICAgICAgICAvLyB3b3VsZCBiZSByZXF1aXJlZCB0byBkbyB0aGF0IHJlY3Vyc2lvbiBpbiBzb21lIHNjZW5hcmlvc1xuXG4gICAgICAgIGZpbHRlcmVkUm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICBmaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBmaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG5cbiAgICAgICAgICBpZiAoIXJvdy5zdWJSb3dzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm93LnN1YlJvd3MgPSByb3cuc3ViUm93cyAmJiByb3cuc3ViUm93cy5sZW5ndGggPiAwID8gZmlsdGVyUm93cyhyb3cuc3ViUm93cywgZGVwdGggKyAxKSA6IHJvdy5zdWJSb3dzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkUm93cztcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBbZmlsdGVyUm93cyhyb3dzKSwgZmlsdGVyZWRGbGF0Um93cywgZmlsdGVyZWRSb3dzQnlJZF07XG4gICAgfSwgW21hbnVhbEZpbHRlcnMsIGZpbHRlcnMsIHJvd3MsIGZsYXRSb3dzLCByb3dzQnlJZCwgYWxsQ29sdW1ucywgdXNlckZpbHRlclR5cGVzXSksXG4gICAgICAgIGZpbHRlcmVkUm93cyA9IF9SZWFjdCR1c2VNZW1vWzBdLFxuICAgICAgICBmaWx0ZXJlZEZsYXRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMV0sXG4gICAgICAgIGZpbHRlcmVkUm93c0J5SWQgPSBfUmVhY3QkdXNlTWVtb1syXTtcblxuICAgIFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gTm93IHRoYXQgZWFjaCBmaWx0ZXJlZCBjb2x1bW4gaGFzIGl0J3MgcGFydGlhbGx5IGZpbHRlcmVkIHJvd3MsXG4gICAgICAvLyBsZXRzIGFzc2lnbiB0aGUgZmluYWwgZmlsdGVyZWQgcm93cyB0byBhbGwgb2YgdGhlIG90aGVyIGNvbHVtbnNcbiAgICAgIHZhciBub25GaWx0ZXJlZENvbHVtbnMgPSBhbGxDb2x1bW5zLmZpbHRlcihmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIHJldHVybiAhZmlsdGVycy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQuaWQgPT09IGNvbHVtbi5pZDtcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gVGhpcyBlc3NlbnRpYWxseSBlbmFibGVzIGZhY2V0ZWQgZmlsdGVyIG9wdGlvbnMgdG8gYmUgYnVpbHQgZWFzaWx5XG4gICAgICAvLyB1c2luZyBldmVyeSBjb2x1bW4ncyBwcmVGaWx0ZXJlZFJvd3MgdmFsdWVcblxuICAgICAgbm9uRmlsdGVyZWRDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICBjb2x1bW4ucHJlRmlsdGVyZWRSb3dzID0gZmlsdGVyZWRSb3dzO1xuICAgICAgICBjb2x1bW4uZmlsdGVyZWRSb3dzID0gZmlsdGVyZWRSb3dzO1xuICAgICAgfSk7XG4gICAgfSwgW2ZpbHRlcmVkUm93cywgZmlsdGVycywgYWxsQ29sdW1uc10pO1xuICAgIHZhciBnZXRBdXRvUmVzZXRGaWx0ZXJzID0gdXNlR2V0TGF0ZXN0KGF1dG9SZXNldEZpbHRlcnMpO1xuICAgIHVzZU1vdW50ZWRMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGdldEF1dG9SZXNldEZpbHRlcnMoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldEZpbHRlcnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2Rpc3BhdGNoLCBtYW51YWxGaWx0ZXJzID8gbnVsbCA6IGRhdGFdKTtcbiAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgICBwcmVGaWx0ZXJlZFJvd3M6IHJvd3MsXG4gICAgICBwcmVGaWx0ZXJlZEZsYXRSb3dzOiBmbGF0Um93cyxcbiAgICAgIHByZUZpbHRlcmVkUm93c0J5SWQ6IHJvd3NCeUlkLFxuICAgICAgZmlsdGVyZWRSb3dzOiBmaWx0ZXJlZFJvd3MsXG4gICAgICBmaWx0ZXJlZEZsYXRSb3dzOiBmaWx0ZXJlZEZsYXRSb3dzLFxuICAgICAgZmlsdGVyZWRSb3dzQnlJZDogZmlsdGVyZWRSb3dzQnlJZCxcbiAgICAgIHJvd3M6IGZpbHRlcmVkUm93cyxcbiAgICAgIGZsYXRSb3dzOiBmaWx0ZXJlZEZsYXRSb3dzLFxuICAgICAgcm93c0J5SWQ6IGZpbHRlcmVkUm93c0J5SWQsXG4gICAgICBzZXRGaWx0ZXI6IHNldEZpbHRlcixcbiAgICAgIHNldEFsbEZpbHRlcnM6IHNldEFsbEZpbHRlcnNcbiAgICB9KTtcbiAgfVxuXG4gIGFjdGlvbnMucmVzZXRHbG9iYWxGaWx0ZXIgPSAncmVzZXRHbG9iYWxGaWx0ZXInO1xuICBhY3Rpb25zLnNldEdsb2JhbEZpbHRlciA9ICdzZXRHbG9iYWxGaWx0ZXInO1xuICB2YXIgdXNlR2xvYmFsRmlsdGVyID0gZnVuY3Rpb24gdXNlR2xvYmFsRmlsdGVyKGhvb2tzKSB7XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkMyk7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSQzKTtcbiAgfTtcbiAgdXNlR2xvYmFsRmlsdGVyLnBsdWdpbk5hbWUgPSAndXNlR2xvYmFsRmlsdGVyJztcblxuICBmdW5jdGlvbiByZWR1Y2VyJDMoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRHbG9iYWxGaWx0ZXIpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgZ2xvYmFsRmlsdGVyOiBpbnN0YW5jZS5pbml0aWFsU3RhdGUuZ2xvYmFsRmlsdGVyIHx8IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnNldEdsb2JhbEZpbHRlcikge1xuICAgICAgdmFyIGZpbHRlclZhbHVlID0gYWN0aW9uLmZpbHRlclZhbHVlO1xuICAgICAgdmFyIHVzZXJGaWx0ZXJUeXBlcyA9IGluc3RhbmNlLnVzZXJGaWx0ZXJUeXBlcztcbiAgICAgIHZhciBmaWx0ZXJNZXRob2QgPSBnZXRGaWx0ZXJNZXRob2QoaW5zdGFuY2UuZ2xvYmFsRmlsdGVyLCB1c2VyRmlsdGVyVHlwZXMgfHwge30sIGZpbHRlclR5cGVzKTtcbiAgICAgIHZhciBuZXdGaWx0ZXIgPSBmdW5jdGlvbmFsVXBkYXRlKGZpbHRlclZhbHVlLCBzdGF0ZS5nbG9iYWxGaWx0ZXIpOyAvL1xuXG4gICAgICBpZiAoc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJNZXRob2QuYXV0b1JlbW92ZSwgbmV3RmlsdGVyKSkge1xuICAgICAgICB2YXIgZ2xvYmFsRmlsdGVyID0gc3RhdGUuZ2xvYmFsRmlsdGVyLFxuICAgICAgICAgICAgc3RhdGVXaXRob3V0R2xvYmFsRmlsdGVyID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc3RhdGUsIFtcImdsb2JhbEZpbHRlclwiXSk7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlV2l0aG91dEdsb2JhbEZpbHRlcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBnbG9iYWxGaWx0ZXI6IG5ld0ZpbHRlclxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkMyhpbnN0YW5jZSkge1xuICAgIHZhciBkYXRhID0gaW5zdGFuY2UuZGF0YSxcbiAgICAgICAgcm93cyA9IGluc3RhbmNlLnJvd3MsXG4gICAgICAgIGZsYXRSb3dzID0gaW5zdGFuY2UuZmxhdFJvd3MsXG4gICAgICAgIHJvd3NCeUlkID0gaW5zdGFuY2Uucm93c0J5SWQsXG4gICAgICAgIGFsbENvbHVtbnMgPSBpbnN0YW5jZS5hbGxDb2x1bW5zLFxuICAgICAgICB1c2VyRmlsdGVyVHlwZXMgPSBpbnN0YW5jZS5maWx0ZXJUeXBlcyxcbiAgICAgICAgZ2xvYmFsRmlsdGVyID0gaW5zdGFuY2UuZ2xvYmFsRmlsdGVyLFxuICAgICAgICBtYW51YWxHbG9iYWxGaWx0ZXIgPSBpbnN0YW5jZS5tYW51YWxHbG9iYWxGaWx0ZXIsXG4gICAgICAgIGdsb2JhbEZpbHRlclZhbHVlID0gaW5zdGFuY2Uuc3RhdGUuZ2xvYmFsRmlsdGVyLFxuICAgICAgICBkaXNwYXRjaCA9IGluc3RhbmNlLmRpc3BhdGNoLFxuICAgICAgICBfaW5zdGFuY2UkYXV0b1Jlc2V0R2wgPSBpbnN0YW5jZS5hdXRvUmVzZXRHbG9iYWxGaWx0ZXIsXG4gICAgICAgIGF1dG9SZXNldEdsb2JhbEZpbHRlciA9IF9pbnN0YW5jZSRhdXRvUmVzZXRHbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRHbCxcbiAgICAgICAgZGlzYWJsZUdsb2JhbEZpbHRlciA9IGluc3RhbmNlLmRpc2FibGVHbG9iYWxGaWx0ZXI7XG4gICAgdmFyIHNldEdsb2JhbEZpbHRlciA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChmaWx0ZXJWYWx1ZSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnNldEdsb2JhbEZpbHRlcixcbiAgICAgICAgZmlsdGVyVmFsdWU6IGZpbHRlclZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTsgLy8gVE9ETzogQ3JlYXRlIGEgZmlsdGVyIGNhY2hlIGZvciBpbmNyZW1lbnRhbCBoaWdoIHNwZWVkIG11bHRpLWZpbHRlcmluZ1xuICAgIC8vIFRoaXMgZ2V0cyBwcmV0dHkgY29tcGxpY2F0ZWQgcHJldHR5IGZhc3QsIHNpbmNlIHlvdSBoYXZlIHRvIG1haW50YWluIGFcbiAgICAvLyBjYWNoZSBmb3IgZWFjaCByb3cgZ3JvdXAgKHRvcC1sZXZlbCByb3dzLCBhbmQgZWFjaCByb3cncyByZWN1cnNpdmUgc3Vicm93cylcbiAgICAvLyBUaGlzIHdvdWxkIG1ha2UgbXVsdGktZmlsdGVyaW5nIGEgbG90IGZhc3RlciB0aG91Z2guIFRvbyBmYXI/XG5cbiAgICB2YXIgX1JlYWN0JHVzZU1lbW8gPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChtYW51YWxHbG9iYWxGaWx0ZXIgfHwgdHlwZW9mIGdsb2JhbEZpbHRlclZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gW3Jvd3MsIGZsYXRSb3dzLCByb3dzQnlJZF07XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWx0ZXJlZEZsYXRSb3dzID0gW107XG4gICAgICB2YXIgZmlsdGVyZWRSb3dzQnlJZCA9IHt9O1xuICAgICAgdmFyIGZpbHRlck1ldGhvZCA9IGdldEZpbHRlck1ldGhvZChnbG9iYWxGaWx0ZXIsIHVzZXJGaWx0ZXJUeXBlcyB8fCB7fSwgZmlsdGVyVHlwZXMpO1xuXG4gICAgICBpZiAoIWZpbHRlck1ldGhvZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBhIHZhbGlkICdnbG9iYWxGaWx0ZXInIG9wdGlvbi5cIik7XG4gICAgICAgIHJldHVybiByb3dzO1xuICAgICAgfVxuXG4gICAgICBhbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICB2YXIgY29sdW1uRGlzYWJsZUdsb2JhbEZpbHRlciA9IGNvbHVtbi5kaXNhYmxlR2xvYmFsRmlsdGVyO1xuICAgICAgICBjb2x1bW4uY2FuRmlsdGVyID0gZ2V0Rmlyc3REZWZpbmVkKGNvbHVtbkRpc2FibGVHbG9iYWxGaWx0ZXIgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgZGlzYWJsZUdsb2JhbEZpbHRlciA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGZpbHRlcmFibGVDb2x1bW5zID0gYWxsQ29sdW1ucy5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMuY2FuRmlsdGVyID09PSB0cnVlO1xuICAgICAgfSk7IC8vIEZpbHRlcnMgdG9wIGxldmVsIGFuZCBuZXN0ZWQgcm93c1xuXG4gICAgICB2YXIgZmlsdGVyUm93cyA9IGZ1bmN0aW9uIGZpbHRlclJvd3MoZmlsdGVyZWRSb3dzKSB7XG4gICAgICAgIGZpbHRlcmVkUm93cyA9IGZpbHRlck1ldGhvZChmaWx0ZXJlZFJvd3MsIGZpbHRlcmFibGVDb2x1bW5zLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLmlkO1xuICAgICAgICB9KSwgZ2xvYmFsRmlsdGVyVmFsdWUpO1xuICAgICAgICBmaWx0ZXJlZFJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgZmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgZmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIHJvdy5zdWJSb3dzID0gcm93LnN1YlJvd3MgJiYgcm93LnN1YlJvd3MubGVuZ3RoID8gZmlsdGVyUm93cyhyb3cuc3ViUm93cykgOiByb3cuc3ViUm93cztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZFJvd3M7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gW2ZpbHRlclJvd3Mocm93cyksIGZpbHRlcmVkRmxhdFJvd3MsIGZpbHRlcmVkUm93c0J5SWRdO1xuICAgIH0sIFttYW51YWxHbG9iYWxGaWx0ZXIsIGdsb2JhbEZpbHRlclZhbHVlLCBnbG9iYWxGaWx0ZXIsIHVzZXJGaWx0ZXJUeXBlcywgYWxsQ29sdW1ucywgcm93cywgZmxhdFJvd3MsIHJvd3NCeUlkLCBkaXNhYmxlR2xvYmFsRmlsdGVyXSksXG4gICAgICAgIGdsb2JhbEZpbHRlcmVkUm93cyA9IF9SZWFjdCR1c2VNZW1vWzBdLFxuICAgICAgICBnbG9iYWxGaWx0ZXJlZEZsYXRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMV0sXG4gICAgICAgIGdsb2JhbEZpbHRlcmVkUm93c0J5SWQgPSBfUmVhY3QkdXNlTWVtb1syXTtcblxuICAgIHZhciBnZXRBdXRvUmVzZXRHbG9iYWxGaWx0ZXIgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0R2xvYmFsRmlsdGVyKTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRHbG9iYWxGaWx0ZXIoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldEdsb2JhbEZpbHRlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbZGlzcGF0Y2gsIG1hbnVhbEdsb2JhbEZpbHRlciA/IG51bGwgOiBkYXRhXSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgcHJlR2xvYmFsRmlsdGVyZWRSb3dzOiByb3dzLFxuICAgICAgcHJlR2xvYmFsRmlsdGVyZWRGbGF0Um93czogZmxhdFJvd3MsXG4gICAgICBwcmVHbG9iYWxGaWx0ZXJlZFJvd3NCeUlkOiByb3dzQnlJZCxcbiAgICAgIGdsb2JhbEZpbHRlcmVkUm93czogZ2xvYmFsRmlsdGVyZWRSb3dzLFxuICAgICAgZ2xvYmFsRmlsdGVyZWRGbGF0Um93czogZ2xvYmFsRmlsdGVyZWRGbGF0Um93cyxcbiAgICAgIGdsb2JhbEZpbHRlcmVkUm93c0J5SWQ6IGdsb2JhbEZpbHRlcmVkUm93c0J5SWQsXG4gICAgICByb3dzOiBnbG9iYWxGaWx0ZXJlZFJvd3MsXG4gICAgICBmbGF0Um93czogZ2xvYmFsRmlsdGVyZWRGbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkOiBnbG9iYWxGaWx0ZXJlZFJvd3NCeUlkLFxuICAgICAgc2V0R2xvYmFsRmlsdGVyOiBzZXRHbG9iYWxGaWx0ZXIsXG4gICAgICBkaXNhYmxlR2xvYmFsRmlsdGVyOiBkaXNhYmxlR2xvYmFsRmlsdGVyXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdW0odmFsdWVzLCBhZ2dyZWdhdGVkVmFsdWVzKSB7XG4gICAgLy8gSXQncyBmYXN0ZXIgdG8ganVzdCBhZGQgdGhlIGFnZ3JlZ2F0aW9ucyB0b2dldGhlciBpbnN0ZWFkIG9mXG4gICAgLy8gcHJvY2VzcyBsZWFmIG5vZGVzIGluZGl2aWR1YWxseVxuICAgIHJldHVybiBhZ2dyZWdhdGVkVmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBuZXh0KSB7XG4gICAgICByZXR1cm4gc3VtICsgKHR5cGVvZiBuZXh0ID09PSAnbnVtYmVyJyA/IG5leHQgOiAwKTtcbiAgICB9LCAwKTtcbiAgfVxuICBmdW5jdGlvbiBtaW4odmFsdWVzKSB7XG4gICAgdmFyIG1pbiA9IHZhbHVlc1swXSB8fCAwO1xuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBmdW5jdGlvbiBtYXgodmFsdWVzKSB7XG4gICAgdmFyIG1heCA9IHZhbHVlc1swXSB8fCAwO1xuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuICBmdW5jdGlvbiBtaW5NYXgodmFsdWVzKSB7XG4gICAgdmFyIG1pbiA9IHZhbHVlc1swXSB8fCAwO1xuICAgIHZhciBtYXggPSB2YWx1ZXNbMF0gfHwgMDtcbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgdmFsdWUpO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWluICsgXCIuLlwiICsgbWF4O1xuICB9XG4gIGZ1bmN0aW9uIGF2ZXJhZ2UodmFsdWVzKSB7XG4gICAgcmV0dXJuIHN1bShudWxsLCB2YWx1ZXMpIC8gdmFsdWVzLmxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBtZWRpYW4odmFsdWVzKSB7XG4gICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbWlkID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMik7XG4gICAgdmFyIG51bXMgPSBbXS5jb25jYXQodmFsdWVzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggJSAyICE9PSAwID8gbnVtc1ttaWRdIDogKG51bXNbbWlkIC0gMV0gKyBudW1zW21pZF0pIC8gMjtcbiAgfVxuICBmdW5jdGlvbiB1bmlxdWUodmFsdWVzKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldCh2YWx1ZXMpLnZhbHVlcygpKTtcbiAgfVxuICBmdW5jdGlvbiB1bmlxdWVDb3VudCh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpLnNpemU7XG4gIH1cbiAgZnVuY3Rpb24gY291bnQodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5sZW5ndGg7XG4gIH1cblxuICB2YXIgYWdncmVnYXRpb25zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBzdW06IHN1bSxcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heCxcbiAgICBtaW5NYXg6IG1pbk1heCxcbiAgICBhdmVyYWdlOiBhdmVyYWdlLFxuICAgIG1lZGlhbjogbWVkaWFuLFxuICAgIHVuaXF1ZTogdW5pcXVlLFxuICAgIHVuaXF1ZUNvdW50OiB1bmlxdWVDb3VudCxcbiAgICBjb3VudDogY291bnRcbiAgfSk7XG5cbiAgdmFyIGVtcHR5QXJyYXkgPSBbXTtcbiAgdmFyIGVtcHR5T2JqZWN0ID0ge307IC8vIEFjdGlvbnNcblxuICBhY3Rpb25zLnJlc2V0R3JvdXBCeSA9ICdyZXNldEdyb3VwQnknO1xuICBhY3Rpb25zLnNldEdyb3VwQnkgPSAnc2V0R3JvdXBCeSc7XG4gIGFjdGlvbnMudG9nZ2xlR3JvdXBCeSA9ICd0b2dnbGVHcm91cEJ5JztcbiAgdmFyIHVzZUdyb3VwQnkgPSBmdW5jdGlvbiB1c2VHcm91cEJ5KGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0R3JvdXBCeVRvZ2dsZVByb3BzID0gW2RlZmF1bHRHZXRHcm91cEJ5VG9nZ2xlUHJvcHNdO1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyJDQpO1xuICAgIGhvb2tzLnZpc2libGVDb2x1bW5zRGVwcy5wdXNoKGZ1bmN0aW9uIChkZXBzLCBfcmVmKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlO1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChkZXBzLCBbaW5zdGFuY2Uuc3RhdGUuZ3JvdXBCeV0pO1xuICAgIH0pO1xuICAgIGhvb2tzLnZpc2libGVDb2x1bW5zLnB1c2godmlzaWJsZUNvbHVtbnMpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UkNCk7XG4gICAgaG9va3MucHJlcGFyZVJvdy5wdXNoKHByZXBhcmVSb3ckMSk7XG4gIH07XG4gIHVzZUdyb3VwQnkucGx1Z2luTmFtZSA9ICd1c2VHcm91cEJ5JztcblxuICB2YXIgZGVmYXVsdEdldEdyb3VwQnlUb2dnbGVQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRHcm91cEJ5VG9nZ2xlUHJvcHMocHJvcHMsIF9yZWYyKSB7XG4gICAgdmFyIGhlYWRlciA9IF9yZWYyLmhlYWRlcjtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBvbkNsaWNrOiBoZWFkZXIuY2FuR3JvdXBCeSA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgICBoZWFkZXIudG9nZ2xlR3JvdXBCeSgpO1xuICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogaGVhZGVyLmNhbkdyb3VwQnkgPyAncG9pbnRlcicgOiB1bmRlZmluZWRcbiAgICAgIH0sXG4gICAgICB0aXRsZTogJ1RvZ2dsZSBHcm91cEJ5J1xuICAgIH1dO1xuICB9OyAvLyBSZWR1Y2VyXG5cblxuICBmdW5jdGlvbiByZWR1Y2VyJDQoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgZ3JvdXBCeTogW11cbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRHcm91cEJ5KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGdyb3VwQnk6IGluc3RhbmNlLmluaXRpYWxTdGF0ZS5ncm91cEJ5IHx8IFtdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0R3JvdXBCeSkge1xuICAgICAgdmFyIHZhbHVlID0gYWN0aW9uLnZhbHVlO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBncm91cEJ5OiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZUdyb3VwQnkpIHtcbiAgICAgIHZhciBjb2x1bW5JZCA9IGFjdGlvbi5jb2x1bW5JZCxcbiAgICAgICAgICBzZXRHcm91cEJ5ID0gYWN0aW9uLnZhbHVlO1xuICAgICAgdmFyIHJlc29sdmVkR3JvdXBCeSA9IHR5cGVvZiBzZXRHcm91cEJ5ICE9PSAndW5kZWZpbmVkJyA/IHNldEdyb3VwQnkgOiAhc3RhdGUuZ3JvdXBCeS5pbmNsdWRlcyhjb2x1bW5JZCk7XG5cbiAgICAgIGlmIChyZXNvbHZlZEdyb3VwQnkpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIGdyb3VwQnk6IFtdLmNvbmNhdChzdGF0ZS5ncm91cEJ5LCBbY29sdW1uSWRdKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBncm91cEJ5OiBzdGF0ZS5ncm91cEJ5LmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkICE9PSBjb2x1bW5JZDtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2libGVDb2x1bW5zKGNvbHVtbnMsIF9yZWYzKSB7XG4gICAgdmFyIGdyb3VwQnkgPSBfcmVmMy5pbnN0YW5jZS5zdGF0ZS5ncm91cEJ5O1xuICAgIC8vIFNvcnQgZ3JvdXBlZCBjb2x1bW5zIHRvIHRoZSBzdGFydCBvZiB0aGUgY29sdW1uIGxpc3RcbiAgICAvLyBiZWZvcmUgdGhlIGhlYWRlcnMgYXJlIGJ1aWx0XG4gICAgdmFyIGdyb3VwQnlDb2x1bW5zID0gZ3JvdXBCeS5tYXAoZnVuY3Rpb24gKGcpIHtcbiAgICAgIHJldHVybiBjb2x1bW5zLmZpbmQoZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICByZXR1cm4gY29sLmlkID09PSBnO1xuICAgICAgfSk7XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIHZhciBub25Hcm91cEJ5Q29sdW1ucyA9IGNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2wpIHtcbiAgICAgIHJldHVybiAhZ3JvdXBCeS5pbmNsdWRlcyhjb2wuaWQpO1xuICAgIH0pO1xuICAgIGNvbHVtbnMgPSBbXS5jb25jYXQoZ3JvdXBCeUNvbHVtbnMsIG5vbkdyb3VwQnlDb2x1bW5zKTtcbiAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgY29sdW1uLmlzR3JvdXBlZCA9IGdyb3VwQnkuaW5jbHVkZXMoY29sdW1uLmlkKTtcbiAgICAgIGNvbHVtbi5ncm91cGVkSW5kZXggPSBncm91cEJ5LmluZGV4T2YoY29sdW1uLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29sdW1ucztcbiAgfVxuXG4gIHZhciBkZWZhdWx0VXNlckFnZ3JlZ2F0aW9ucyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHVzZUluc3RhbmNlJDQoaW5zdGFuY2UpIHtcbiAgICB2YXIgZGF0YSA9IGluc3RhbmNlLmRhdGEsXG4gICAgICAgIHJvd3MgPSBpbnN0YW5jZS5yb3dzLFxuICAgICAgICBmbGF0Um93cyA9IGluc3RhbmNlLmZsYXRSb3dzLFxuICAgICAgICByb3dzQnlJZCA9IGluc3RhbmNlLnJvd3NCeUlkLFxuICAgICAgICBhbGxDb2x1bW5zID0gaW5zdGFuY2UuYWxsQ29sdW1ucyxcbiAgICAgICAgZmxhdEhlYWRlcnMgPSBpbnN0YW5jZS5mbGF0SGVhZGVycyxcbiAgICAgICAgX2luc3RhbmNlJGdyb3VwQnlGbiA9IGluc3RhbmNlLmdyb3VwQnlGbixcbiAgICAgICAgZ3JvdXBCeUZuID0gX2luc3RhbmNlJGdyb3VwQnlGbiA9PT0gdm9pZCAwID8gZGVmYXVsdEdyb3VwQnlGbiA6IF9pbnN0YW5jZSRncm91cEJ5Rm4sXG4gICAgICAgIG1hbnVhbEdyb3VwQnkgPSBpbnN0YW5jZS5tYW51YWxHcm91cEJ5LFxuICAgICAgICBfaW5zdGFuY2UkYWdncmVnYXRpb24gPSBpbnN0YW5jZS5hZ2dyZWdhdGlvbnMsXG4gICAgICAgIHVzZXJBZ2dyZWdhdGlvbnMgPSBfaW5zdGFuY2UkYWdncmVnYXRpb24gPT09IHZvaWQgMCA/IGRlZmF1bHRVc2VyQWdncmVnYXRpb25zIDogX2luc3RhbmNlJGFnZ3JlZ2F0aW9uLFxuICAgICAgICBwbHVnaW5zID0gaW5zdGFuY2UucGx1Z2lucyxcbiAgICAgICAgZ3JvdXBCeSA9IGluc3RhbmNlLnN0YXRlLmdyb3VwQnksXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2gsXG4gICAgICAgIF9pbnN0YW5jZSRhdXRvUmVzZXRHciA9IGluc3RhbmNlLmF1dG9SZXNldEdyb3VwQnksXG4gICAgICAgIGF1dG9SZXNldEdyb3VwQnkgPSBfaW5zdGFuY2UkYXV0b1Jlc2V0R3IgPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkYXV0b1Jlc2V0R3IsXG4gICAgICAgIGRpc2FibGVHcm91cEJ5ID0gaW5zdGFuY2UuZGlzYWJsZUdyb3VwQnksXG4gICAgICAgIGRlZmF1bHRDYW5Hcm91cEJ5ID0gaW5zdGFuY2UuZGVmYXVsdENhbkdyb3VwQnksXG4gICAgICAgIGdldEhvb2tzID0gaW5zdGFuY2UuZ2V0SG9va3M7XG4gICAgZW5zdXJlUGx1Z2luT3JkZXIocGx1Z2lucywgWyd1c2VDb2x1bW5PcmRlcicsICd1c2VGaWx0ZXJzJ10sICd1c2VHcm91cEJ5Jyk7XG4gICAgdmFyIGdldEluc3RhbmNlID0gdXNlR2V0TGF0ZXN0KGluc3RhbmNlKTtcbiAgICBhbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgdmFyIGFjY2Vzc29yID0gY29sdW1uLmFjY2Vzc29yLFxuICAgICAgICAgIGRlZmF1bHRDb2x1bW5Hcm91cEJ5ID0gY29sdW1uLmRlZmF1bHRHcm91cEJ5LFxuICAgICAgICAgIGNvbHVtbkRpc2FibGVHcm91cEJ5ID0gY29sdW1uLmRpc2FibGVHcm91cEJ5O1xuICAgICAgY29sdW1uLmNhbkdyb3VwQnkgPSBhY2Nlc3NvciA/IGdldEZpcnN0RGVmaW5lZChjb2x1bW4uY2FuR3JvdXBCeSwgY29sdW1uRGlzYWJsZUdyb3VwQnkgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgZGlzYWJsZUdyb3VwQnkgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgdHJ1ZSkgOiBnZXRGaXJzdERlZmluZWQoY29sdW1uLmNhbkdyb3VwQnksIGRlZmF1bHRDb2x1bW5Hcm91cEJ5LCBkZWZhdWx0Q2FuR3JvdXBCeSwgZmFsc2UpO1xuXG4gICAgICBpZiAoY29sdW1uLmNhbkdyb3VwQnkpIHtcbiAgICAgICAgY29sdW1uLnRvZ2dsZUdyb3VwQnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnRvZ2dsZUdyb3VwQnkoY29sdW1uLmlkKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29sdW1uLkFnZ3JlZ2F0ZWQgPSBjb2x1bW4uQWdncmVnYXRlZCB8fCBjb2x1bW4uQ2VsbDtcbiAgICB9KTtcbiAgICB2YXIgdG9nZ2xlR3JvdXBCeSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChjb2x1bW5JZCwgdmFsdWUpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy50b2dnbGVHcm91cEJ5LFxuICAgICAgICBjb2x1bW5JZDogY29sdW1uSWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIHNldEdyb3VwQnkgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy5zZXRHcm91cEJ5LFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIGZsYXRIZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgaGVhZGVyLmdldEdyb3VwQnlUb2dnbGVQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0R3JvdXBCeVRvZ2dsZVByb3BzLCB7XG4gICAgICAgIGluc3RhbmNlOiBnZXRJbnN0YW5jZSgpLFxuICAgICAgICBoZWFkZXI6IGhlYWRlclxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgX1JlYWN0JHVzZU1lbW8gPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChtYW51YWxHcm91cEJ5IHx8ICFncm91cEJ5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW3Jvd3MsIGZsYXRSb3dzLCByb3dzQnlJZCwgZW1wdHlBcnJheSwgZW1wdHlPYmplY3QsIGZsYXRSb3dzLCByb3dzQnlJZF07XG4gICAgICB9IC8vIEVuc3VyZSB0aGF0IHRoZSBsaXN0IG9mIGZpbHRlcmVkIGNvbHVtbnMgZXhpc3RcblxuXG4gICAgICB2YXIgZXhpc3RpbmdHcm91cEJ5ID0gZ3JvdXBCeS5maWx0ZXIoZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgcmV0dXJuIGFsbENvbHVtbnMuZmluZChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbC5pZCA9PT0gZztcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gRmluZCB0aGUgY29sdW1ucyB0aGF0IGNhbiBvciBhcmUgYWdncmVnYXRpbmdcbiAgICAgIC8vIFVzZXMgZWFjaCBjb2x1bW4gdG8gYWdncmVnYXRlIHJvd3MgaW50byBhIHNpbmdsZSB2YWx1ZVxuXG4gICAgICB2YXIgYWdncmVnYXRlUm93c1RvVmFsdWVzID0gZnVuY3Rpb24gYWdncmVnYXRlUm93c1RvVmFsdWVzKGxlYWZSb3dzLCBncm91cGVkUm93cywgZGVwdGgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHt9O1xuICAgICAgICBhbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgIC8vIERvbid0IGFnZ3JlZ2F0ZSBjb2x1bW5zIHRoYXQgYXJlIGluIHRoZSBncm91cEJ5XG4gICAgICAgICAgaWYgKGV4aXN0aW5nR3JvdXBCeS5pbmNsdWRlcyhjb2x1bW4uaWQpKSB7XG4gICAgICAgICAgICB2YWx1ZXNbY29sdW1uLmlkXSA9IGdyb3VwZWRSb3dzWzBdID8gZ3JvdXBlZFJvd3NbMF0udmFsdWVzW2NvbHVtbi5pZF0gOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gQWdncmVnYXRlIHRoZSB2YWx1ZXNcblxuXG4gICAgICAgICAgdmFyIGFnZ3JlZ2F0ZUZuID0gdHlwZW9mIGNvbHVtbi5hZ2dyZWdhdGUgPT09ICdmdW5jdGlvbicgPyBjb2x1bW4uYWdncmVnYXRlIDogdXNlckFnZ3JlZ2F0aW9uc1tjb2x1bW4uYWdncmVnYXRlXSB8fCBhZ2dyZWdhdGlvbnNbY29sdW1uLmFnZ3JlZ2F0ZV07XG5cbiAgICAgICAgICBpZiAoYWdncmVnYXRlRm4pIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY29sdW1uVmFsdWVzIHRvIGFnZ3JlZ2F0ZVxuICAgICAgICAgICAgdmFyIGdyb3VwZWRWYWx1ZXMgPSBncm91cGVkUm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gcm93LnZhbHVlc1tjb2x1bW4uaWRdO1xuICAgICAgICAgICAgfSk7IC8vIEdldCB0aGUgY29sdW1uVmFsdWVzIHRvIGFnZ3JlZ2F0ZVxuXG4gICAgICAgICAgICB2YXIgbGVhZlZhbHVlcyA9IGxlYWZSb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgIHZhciBjb2x1bW5WYWx1ZSA9IHJvdy52YWx1ZXNbY29sdW1uLmlkXTtcblxuICAgICAgICAgICAgICBpZiAoIWRlcHRoICYmIGNvbHVtbi5hZ2dyZWdhdGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBhZ2dyZWdhdGVWYWx1ZUZuID0gdHlwZW9mIGNvbHVtbi5hZ2dyZWdhdGVWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IGNvbHVtbi5hZ2dyZWdhdGVWYWx1ZSA6IHVzZXJBZ2dyZWdhdGlvbnNbY29sdW1uLmFnZ3JlZ2F0ZVZhbHVlXSB8fCBhZ2dyZWdhdGlvbnNbY29sdW1uLmFnZ3JlZ2F0ZVZhbHVlXTtcblxuICAgICAgICAgICAgICAgIGlmICghYWdncmVnYXRlVmFsdWVGbikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QgVGFibGU6IEludmFsaWQgY29sdW1uLmFnZ3JlZ2F0ZVZhbHVlIG9wdGlvbiBmb3IgY29sdW1uIGxpc3RlZCBhYm92ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5WYWx1ZSA9IGFnZ3JlZ2F0ZVZhbHVlRm4oY29sdW1uVmFsdWUsIHJvdywgY29sdW1uKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBjb2x1bW5WYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFsdWVzW2NvbHVtbi5pZF0gPSBhZ2dyZWdhdGVGbihsZWFmVmFsdWVzLCBncm91cGVkVmFsdWVzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbHVtbi5hZ2dyZWdhdGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyh7XG4gICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0IFRhYmxlOiBJbnZhbGlkIGNvbHVtbi5hZ2dyZWdhdGUgb3B0aW9uIGZvciBjb2x1bW4gbGlzdGVkIGFib3ZlXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXNbY29sdW1uLmlkXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH07XG5cbiAgICAgIHZhciBncm91cGVkRmxhdFJvd3MgPSBbXTtcbiAgICAgIHZhciBncm91cGVkUm93c0J5SWQgPSB7fTtcbiAgICAgIHZhciBvbmx5R3JvdXBlZEZsYXRSb3dzID0gW107XG4gICAgICB2YXIgb25seUdyb3VwZWRSb3dzQnlJZCA9IHt9O1xuICAgICAgdmFyIG5vbkdyb3VwZWRGbGF0Um93cyA9IFtdO1xuICAgICAgdmFyIG5vbkdyb3VwZWRSb3dzQnlJZCA9IHt9OyAvLyBSZWN1cnNpdmVseSBncm91cCB0aGUgZGF0YVxuXG4gICAgICB2YXIgZ3JvdXBVcFJlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gZ3JvdXBVcFJlY3Vyc2l2ZWx5KHJvd3MsIGRlcHRoLCBwYXJlbnRJZCkge1xuICAgICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRlcHRoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhc3QgbGV2ZWwsIGp1c3QgcmV0dXJuIHRoZSByb3dzXG4gICAgICAgIGlmIChkZXB0aCA9PT0gZXhpc3RpbmdHcm91cEJ5Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiByb3dzLm1hcChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHJvdywge1xuICAgICAgICAgICAgICBkZXB0aDogZGVwdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbHVtbklkID0gZXhpc3RpbmdHcm91cEJ5W2RlcHRoXTsgLy8gR3JvdXAgdGhlIHJvd3MgdG9nZXRoZXIgZm9yIHRoaXMgbGV2ZWxcblxuICAgICAgICB2YXIgcm93R3JvdXBzTWFwID0gZ3JvdXBCeUZuKHJvd3MsIGNvbHVtbklkKTsgLy8gUGVmb3JtIGFnZ3JlZ2F0aW9ucyBmb3IgZWFjaCBncm91cFxuXG4gICAgICAgIHZhciBhZ2dyZWdhdGVkR3JvdXBlZFJvd3MgPSBPYmplY3QuZW50cmllcyhyb3dHcm91cHNNYXApLm1hcChmdW5jdGlvbiAoX3JlZjQsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGdyb3VwQnlWYWwgPSBfcmVmNFswXSxcbiAgICAgICAgICAgICAgZ3JvdXBlZFJvd3MgPSBfcmVmNFsxXTtcbiAgICAgICAgICB2YXIgaWQgPSBjb2x1bW5JZCArIFwiOlwiICsgZ3JvdXBCeVZhbDtcbiAgICAgICAgICBpZCA9IHBhcmVudElkID8gcGFyZW50SWQgKyBcIj5cIiArIGlkIDogaWQ7IC8vIEZpcnN0LCBSZWN1cnNlIHRvIGdyb3VwIHN1YiByb3dzIGJlZm9yZSBhZ2dyZWdhdGlvblxuXG4gICAgICAgICAgdmFyIHN1YlJvd3MgPSBncm91cFVwUmVjdXJzaXZlbHkoZ3JvdXBlZFJvd3MsIGRlcHRoICsgMSwgaWQpOyAvLyBGbGF0dGVuIHRoZSBsZWFmIHJvd3Mgb2YgdGhlIHJvd3MgaW4gdGhpcyBncm91cFxuXG4gICAgICAgICAgdmFyIGxlYWZSb3dzID0gZGVwdGggPyBmbGF0dGVuQnkoZ3JvdXBlZFJvd3MsICdsZWFmUm93cycpIDogZ3JvdXBlZFJvd3M7XG4gICAgICAgICAgdmFyIHZhbHVlcyA9IGFnZ3JlZ2F0ZVJvd3NUb1ZhbHVlcyhsZWFmUm93cywgZ3JvdXBlZFJvd3MsIGRlcHRoKTtcbiAgICAgICAgICB2YXIgcm93ID0ge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgaXNHcm91cGVkOiB0cnVlLFxuICAgICAgICAgICAgZ3JvdXBCeUlEOiBjb2x1bW5JZCxcbiAgICAgICAgICAgIGdyb3VwQnlWYWw6IGdyb3VwQnlWYWwsXG4gICAgICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgICAgIHN1YlJvd3M6IHN1YlJvd3MsXG4gICAgICAgICAgICBsZWFmUm93czogbGVhZlJvd3MsXG4gICAgICAgICAgICBkZXB0aDogZGVwdGgsXG4gICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICAgIHN1YlJvd3MuZm9yRWFjaChmdW5jdGlvbiAoc3ViUm93KSB7XG4gICAgICAgICAgICBncm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgICAgZ3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG5cbiAgICAgICAgICAgIGlmIChzdWJSb3cuaXNHcm91cGVkKSB7XG4gICAgICAgICAgICAgIG9ubHlHcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgICAgICBvbmx5R3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub25Hcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgICAgICBub25Hcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0ZWRHcm91cGVkUm93cztcbiAgICAgIH07XG5cbiAgICAgIHZhciBncm91cGVkUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShyb3dzKTtcbiAgICAgIGdyb3VwZWRSb3dzLmZvckVhY2goZnVuY3Rpb24gKHN1YlJvdykge1xuICAgICAgICBncm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICBncm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcblxuICAgICAgICBpZiAoc3ViUm93LmlzR3JvdXBlZCkge1xuICAgICAgICAgIG9ubHlHcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub25Hcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gQXNzaWduIHRoZSBuZXcgZGF0YVxuXG4gICAgICByZXR1cm4gW2dyb3VwZWRSb3dzLCBncm91cGVkRmxhdFJvd3MsIGdyb3VwZWRSb3dzQnlJZCwgb25seUdyb3VwZWRGbGF0Um93cywgb25seUdyb3VwZWRSb3dzQnlJZCwgbm9uR3JvdXBlZEZsYXRSb3dzLCBub25Hcm91cGVkUm93c0J5SWRdO1xuICAgIH0sIFttYW51YWxHcm91cEJ5LCBncm91cEJ5LCByb3dzLCBmbGF0Um93cywgcm93c0J5SWQsIGFsbENvbHVtbnMsIHVzZXJBZ2dyZWdhdGlvbnMsIGdyb3VwQnlGbl0pLFxuICAgICAgICBncm91cGVkUm93cyA9IF9SZWFjdCR1c2VNZW1vWzBdLFxuICAgICAgICBncm91cGVkRmxhdFJvd3MgPSBfUmVhY3QkdXNlTWVtb1sxXSxcbiAgICAgICAgZ3JvdXBlZFJvd3NCeUlkID0gX1JlYWN0JHVzZU1lbW9bMl0sXG4gICAgICAgIG9ubHlHcm91cGVkRmxhdFJvd3MgPSBfUmVhY3QkdXNlTWVtb1szXSxcbiAgICAgICAgb25seUdyb3VwZWRSb3dzQnlJZCA9IF9SZWFjdCR1c2VNZW1vWzRdLFxuICAgICAgICBub25Hcm91cGVkRmxhdFJvd3MgPSBfUmVhY3QkdXNlTWVtb1s1XSxcbiAgICAgICAgbm9uR3JvdXBlZFJvd3NCeUlkID0gX1JlYWN0JHVzZU1lbW9bNl07XG5cbiAgICB2YXIgZ2V0QXV0b1Jlc2V0R3JvdXBCeSA9IHVzZUdldExhdGVzdChhdXRvUmVzZXRHcm91cEJ5KTtcbiAgICB1c2VNb3VudGVkTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRBdXRvUmVzZXRHcm91cEJ5KCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRHcm91cEJ5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtkaXNwYXRjaCwgbWFudWFsR3JvdXBCeSA/IG51bGwgOiBkYXRhXSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgcHJlR3JvdXBlZFJvd3M6IHJvd3MsXG4gICAgICBwcmVHcm91cGVkRmxhdFJvdzogZmxhdFJvd3MsXG4gICAgICBwcmVHcm91cGVkUm93c0J5SWQ6IHJvd3NCeUlkLFxuICAgICAgZ3JvdXBlZFJvd3M6IGdyb3VwZWRSb3dzLFxuICAgICAgZ3JvdXBlZEZsYXRSb3dzOiBncm91cGVkRmxhdFJvd3MsXG4gICAgICBncm91cGVkUm93c0J5SWQ6IGdyb3VwZWRSb3dzQnlJZCxcbiAgICAgIG9ubHlHcm91cGVkRmxhdFJvd3M6IG9ubHlHcm91cGVkRmxhdFJvd3MsXG4gICAgICBvbmx5R3JvdXBlZFJvd3NCeUlkOiBvbmx5R3JvdXBlZFJvd3NCeUlkLFxuICAgICAgbm9uR3JvdXBlZEZsYXRSb3dzOiBub25Hcm91cGVkRmxhdFJvd3MsXG4gICAgICBub25Hcm91cGVkUm93c0J5SWQ6IG5vbkdyb3VwZWRSb3dzQnlJZCxcbiAgICAgIHJvd3M6IGdyb3VwZWRSb3dzLFxuICAgICAgZmxhdFJvd3M6IGdyb3VwZWRGbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkOiBncm91cGVkUm93c0J5SWQsXG4gICAgICB0b2dnbGVHcm91cEJ5OiB0b2dnbGVHcm91cEJ5LFxuICAgICAgc2V0R3JvdXBCeTogc2V0R3JvdXBCeVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVJvdyQxKHJvdykge1xuICAgIHJvdy5hbGxDZWxscy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICB2YXIgX3JvdyRzdWJSb3dzO1xuXG4gICAgICAvLyBHcm91cGVkIGNlbGxzIGFyZSBpbiB0aGUgZ3JvdXBCeSBhbmQgdGhlIHBpdm90IGNlbGwgZm9yIHRoZSByb3dcbiAgICAgIGNlbGwuaXNHcm91cGVkID0gY2VsbC5jb2x1bW4uaXNHcm91cGVkICYmIGNlbGwuY29sdW1uLmlkID09PSByb3cuZ3JvdXBCeUlEOyAvLyBQbGFjZWhvbGRlciBjZWxscyBhcmUgYW55IGNvbHVtbnMgaW4gdGhlIGdyb3VwQnkgdGhhdCBhcmUgbm90IGdyb3VwZWRcblxuICAgICAgY2VsbC5pc1BsYWNlaG9sZGVyID0gIWNlbGwuaXNHcm91cGVkICYmIGNlbGwuY29sdW1uLmlzR3JvdXBlZDsgLy8gQWdncmVnYXRlZCBjZWxscyBhcmUgbm90IGdyb3VwZWQsIG5vdCByZXBlYXRlZCwgYnV0IHN0aWxsIGhhdmUgc3ViUm93c1xuXG4gICAgICBjZWxsLmlzQWdncmVnYXRlZCA9ICFjZWxsLmlzR3JvdXBlZCAmJiAhY2VsbC5pc1BsYWNlaG9sZGVyICYmICgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JHN1YlJvd3MubGVuZ3RoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRHcm91cEJ5Rm4ocm93cywgY29sdW1uSWQpIHtcbiAgICByZXR1cm4gcm93cy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHJvdywgaSkge1xuICAgICAgLy8gVE9ETzogTWlnaHQgd2FudCB0byBpbXBsZW1lbnQgYSBrZXkgc2VyaWFsaXplciBoZXJlIHNvXG4gICAgICAvLyBpcnJlZ3VsYXIgY29sdW1uIHZhbHVlcyBjYW4gc3RpbGwgYmUgZ3JvdXBlZCBpZiBuZWVkZWQ/XG4gICAgICB2YXIgcmVzS2V5ID0gXCJcIiArIHJvdy52YWx1ZXNbY29sdW1uSWRdO1xuICAgICAgcHJldltyZXNLZXldID0gQXJyYXkuaXNBcnJheShwcmV2W3Jlc0tleV0pID8gcHJldltyZXNLZXldIDogW107XG4gICAgICBwcmV2W3Jlc0tleV0ucHVzaChyb3cpO1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xuICB9XG5cbiAgdmFyIHJlU3BsaXRBbHBoYU51bWVyaWMgPSAvKFswLTldKykvZ207IC8vIE1peGVkIHNvcnRpbmcgaXMgc2xvdywgYnV0IHZlcnkgaW5jbHVzaXZlIG9mIG1hbnkgZWRnZSBjYXNlcy5cbiAgLy8gSXQgaGFuZGxlcyBudW1iZXJzLCBtaXhlZCBhbHBoYW51bWVyaWMgY29tYmluYXRpb25zLCBhbmQgZXZlblxuICAvLyBudWxsLCB1bmRlZmluZWQsIGFuZCBJbmZpbml0eVxuXG4gIHZhciBhbHBoYW51bWVyaWMgPSBmdW5jdGlvbiBhbHBoYW51bWVyaWMocm93QSwgcm93QiwgY29sdW1uSWQpIHtcbiAgICB2YXIgX2dldFJvd1ZhbHVlc0J5Q29sdW1uID0gZ2V0Um93VmFsdWVzQnlDb2x1bW5JRChyb3dBLCByb3dCLCBjb2x1bW5JZCksXG4gICAgICAgIGEgPSBfZ2V0Um93VmFsdWVzQnlDb2x1bW5bMF0sXG4gICAgICAgIGIgPSBfZ2V0Um93VmFsdWVzQnlDb2x1bW5bMV07IC8vIEZvcmNlIHRvIHN0cmluZ3MgKG9yIFwiXCIgZm9yIHVuc3VwcG9ydGVkIHR5cGVzKVxuXG5cbiAgICBhID0gdG9TdHJpbmcoYSk7XG4gICAgYiA9IHRvU3RyaW5nKGIpOyAvLyBTcGxpdCBvbiBudW1iZXIgZ3JvdXBzLCBidXQga2VlcCB0aGUgZGVsaW1pdGVyXG4gICAgLy8gVGhlbiByZW1vdmUgZmFsc2V5IHNwbGl0IHZhbHVlc1xuXG4gICAgYSA9IGEuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGIgPSBiLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmZpbHRlcihCb29sZWFuKTsgLy8gV2hpbGVcblxuICAgIHdoaWxlIChhLmxlbmd0aCAmJiBiLmxlbmd0aCkge1xuICAgICAgdmFyIGFhID0gYS5zaGlmdCgpO1xuICAgICAgdmFyIGJiID0gYi5zaGlmdCgpO1xuICAgICAgdmFyIGFuID0gcGFyc2VJbnQoYWEsIDEwKTtcbiAgICAgIHZhciBibiA9IHBhcnNlSW50KGJiLCAxMCk7XG4gICAgICB2YXIgY29tYm8gPSBbYW4sIGJuXS5zb3J0KCk7IC8vIEJvdGggYXJlIHN0cmluZ1xuXG4gICAgICBpZiAoaXNOYU4oY29tYm9bMF0pKSB7XG4gICAgICAgIGlmIChhYSA+IGJiKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmIgPiBhYSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBPbmUgaXMgYSBzdHJpbmcsIG9uZSBpcyBhIG51bWJlclxuXG5cbiAgICAgIGlmIChpc05hTihjb21ib1sxXSkpIHtcbiAgICAgICAgcmV0dXJuIGlzTmFOKGFuKSA/IC0xIDogMTtcbiAgICAgIH0gLy8gQm90aCBhcmUgbnVtYmVyc1xuXG5cbiAgICAgIGlmIChhbiA+IGJuKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm4gPiBhbikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gIH07XG4gIGZ1bmN0aW9uIGRhdGV0aW1lKHJvd0EsIHJvd0IsIGNvbHVtbklkKSB7XG4gICAgdmFyIF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjIgPSBnZXRSb3dWYWx1ZXNCeUNvbHVtbklEKHJvd0EsIHJvd0IsIGNvbHVtbklkKSxcbiAgICAgICAgYSA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjJbMF0sXG4gICAgICAgIGIgPSBfZ2V0Um93VmFsdWVzQnlDb2x1bW4yWzFdO1xuXG4gICAgYSA9IGEuZ2V0VGltZSgpO1xuICAgIGIgPSBiLmdldFRpbWUoKTtcbiAgICByZXR1cm4gY29tcGFyZUJhc2ljKGEsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGJhc2ljKHJvd0EsIHJvd0IsIGNvbHVtbklkKSB7XG4gICAgdmFyIF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjMgPSBnZXRSb3dWYWx1ZXNCeUNvbHVtbklEKHJvd0EsIHJvd0IsIGNvbHVtbklkKSxcbiAgICAgICAgYSA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjNbMF0sXG4gICAgICAgIGIgPSBfZ2V0Um93VmFsdWVzQnlDb2x1bW4zWzFdO1xuXG4gICAgcmV0dXJuIGNvbXBhcmVCYXNpYyhhLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBzdHJpbmcocm93QSwgcm93QiwgY29sdW1uSWQpIHtcbiAgICB2YXIgX2dldFJvd1ZhbHVlc0J5Q29sdW1uNCA9IGdldFJvd1ZhbHVlc0J5Q29sdW1uSUQocm93QSwgcm93QiwgY29sdW1uSWQpLFxuICAgICAgICBhID0gX2dldFJvd1ZhbHVlc0J5Q29sdW1uNFswXSxcbiAgICAgICAgYiA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjRbMV07XG5cbiAgICBhID0gYS5zcGxpdCgnJykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGIgPSBiLnNwbGl0KCcnKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICB3aGlsZSAoYS5sZW5ndGggJiYgYi5sZW5ndGgpIHtcbiAgICAgIHZhciBhYSA9IGEuc2hpZnQoKTtcbiAgICAgIHZhciBiYiA9IGIuc2hpZnQoKTtcbiAgICAgIHZhciBhbG93ZXIgPSBhYS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGJsb3dlciA9IGJiLnRvTG93ZXJDYXNlKCk7IC8vIENhc2UgaW5zZW5zaXRpdmUgY29tcGFyaXNvbiB1bnRpbCBjaGFyYWN0ZXJzIG1hdGNoXG5cbiAgICAgIGlmIChhbG93ZXIgPiBibG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG93ZXIgPiBhbG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSAvLyBJZiBsb3dlcmNhc2UgY2hhcmFjdGVycyBhcmUgaWRlbnRpY2FsXG5cblxuICAgICAgaWYgKGFhID4gYmIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChiYiA+IGFhKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gbnVtYmVyKHJvd0EsIHJvd0IsIGNvbHVtbklkKSB7XG4gICAgdmFyIF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjUgPSBnZXRSb3dWYWx1ZXNCeUNvbHVtbklEKHJvd0EsIHJvd0IsIGNvbHVtbklkKSxcbiAgICAgICAgYSA9IF9nZXRSb3dWYWx1ZXNCeUNvbHVtbjVbMF0sXG4gICAgICAgIGIgPSBfZ2V0Um93VmFsdWVzQnlDb2x1bW41WzFdO1xuXG4gICAgdmFyIHJlcGxhY2VOb25OdW1lcmljID0gL1teMC05Ll0vZ2k7XG4gICAgYSA9IE51bWJlcihTdHJpbmcoYSkucmVwbGFjZShyZXBsYWNlTm9uTnVtZXJpYywgJycpKTtcbiAgICBiID0gTnVtYmVyKFN0cmluZyhiKS5yZXBsYWNlKHJlcGxhY2VOb25OdW1lcmljLCAnJykpO1xuICAgIHJldHVybiBjb21wYXJlQmFzaWMoYSwgYik7XG4gIH0gLy8gVXRpbHNcblxuICBmdW5jdGlvbiBjb21wYXJlQmFzaWMoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Um93VmFsdWVzQnlDb2x1bW5JRChyb3cxLCByb3cyLCBjb2x1bW5JZCkge1xuICAgIHJldHVybiBbcm93MS52YWx1ZXNbY29sdW1uSWRdLCByb3cyLnZhbHVlc1tjb2x1bW5JZF1dO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9TdHJpbmcoYSkge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTihhKSB8fCBhID09PSBJbmZpbml0eSB8fCBhID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU3RyaW5nKGEpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBzb3J0VHlwZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGFscGhhbnVtZXJpYzogYWxwaGFudW1lcmljLFxuICAgIGRhdGV0aW1lOiBkYXRldGltZSxcbiAgICBiYXNpYzogYmFzaWMsXG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgbnVtYmVyOiBudW1iZXJcbiAgfSk7XG5cbiAgYWN0aW9ucy5yZXNldFNvcnRCeSA9ICdyZXNldFNvcnRCeSc7XG4gIGFjdGlvbnMuc2V0U29ydEJ5ID0gJ3NldFNvcnRCeSc7XG4gIGFjdGlvbnMudG9nZ2xlU29ydEJ5ID0gJ3RvZ2dsZVNvcnRCeSc7XG4gIGFjdGlvbnMuY2xlYXJTb3J0QnkgPSAnY2xlYXJTb3J0QnknO1xuICBkZWZhdWx0Q29sdW1uLnNvcnRUeXBlID0gJ2FscGhhbnVtZXJpYyc7XG4gIGRlZmF1bHRDb2x1bW4uc29ydERlc2NGaXJzdCA9IGZhbHNlO1xuICB2YXIgdXNlU29ydEJ5ID0gZnVuY3Rpb24gdXNlU29ydEJ5KGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0U29ydEJ5VG9nZ2xlUHJvcHMgPSBbZGVmYXVsdEdldFNvcnRCeVRvZ2dsZVByb3BzXTtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciQ1KTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJDUpO1xuICB9O1xuICB1c2VTb3J0QnkucGx1Z2luTmFtZSA9ICd1c2VTb3J0QnknO1xuXG4gIHZhciBkZWZhdWx0R2V0U29ydEJ5VG9nZ2xlUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0U29ydEJ5VG9nZ2xlUHJvcHMocHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgICBjb2x1bW4gPSBfcmVmLmNvbHVtbjtcbiAgICB2YXIgX2luc3RhbmNlJGlzTXVsdGlTb3J0ID0gaW5zdGFuY2UuaXNNdWx0aVNvcnRFdmVudCxcbiAgICAgICAgaXNNdWx0aVNvcnRFdmVudCA9IF9pbnN0YW5jZSRpc011bHRpU29ydCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBlLnNoaWZ0S2V5O1xuICAgIH0gOiBfaW5zdGFuY2UkaXNNdWx0aVNvcnQ7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgb25DbGljazogY29sdW1uLmNhblNvcnQgPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnBlcnNpc3QoKTtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVNvcnRCeSh1bmRlZmluZWQsICFpbnN0YW5jZS5kaXNhYmxlTXVsdGlTb3J0ICYmIGlzTXVsdGlTb3J0RXZlbnQoZSkpO1xuICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogY29sdW1uLmNhblNvcnQgPyAncG9pbnRlcicgOiB1bmRlZmluZWRcbiAgICAgIH0sXG4gICAgICB0aXRsZTogY29sdW1uLmNhblNvcnQgPyAnVG9nZ2xlIFNvcnRCeScgOiB1bmRlZmluZWRcbiAgICB9XTtcbiAgfTsgLy8gUmVkdWNlclxuXG5cbiAgZnVuY3Rpb24gcmVkdWNlciQ1KHN0YXRlLCBhY3Rpb24sIHByZXZpb3VzU3RhdGUsIGluc3RhbmNlKSB7XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmluaXQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIHNvcnRCeTogW11cbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRTb3J0QnkpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgc29ydEJ5OiBpbnN0YW5jZS5pbml0aWFsU3RhdGUuc29ydEJ5IHx8IFtdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuY2xlYXJTb3J0QnkpIHtcbiAgICAgIHZhciBzb3J0QnkgPSBzdGF0ZS5zb3J0Qnk7XG4gICAgICB2YXIgbmV3U29ydEJ5ID0gc29ydEJ5LmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5pZCAhPT0gYWN0aW9uLmNvbHVtbklkO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHNvcnRCeTogbmV3U29ydEJ5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0U29ydEJ5KSB7XG4gICAgICB2YXIgX3NvcnRCeSA9IGFjdGlvbi5zb3J0Qnk7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHNvcnRCeTogX3NvcnRCeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnRvZ2dsZVNvcnRCeSkge1xuICAgICAgdmFyIGNvbHVtbklkID0gYWN0aW9uLmNvbHVtbklkLFxuICAgICAgICAgIGRlc2MgPSBhY3Rpb24uZGVzYyxcbiAgICAgICAgICBtdWx0aSA9IGFjdGlvbi5tdWx0aTtcbiAgICAgIHZhciBhbGxDb2x1bW5zID0gaW5zdGFuY2UuYWxsQ29sdW1ucyxcbiAgICAgICAgICBkaXNhYmxlTXVsdGlTb3J0ID0gaW5zdGFuY2UuZGlzYWJsZU11bHRpU29ydCxcbiAgICAgICAgICBkaXNhYmxlU29ydFJlbW92ZSA9IGluc3RhbmNlLmRpc2FibGVTb3J0UmVtb3ZlLFxuICAgICAgICAgIGRpc2FibGVNdWx0aVJlbW92ZSA9IGluc3RhbmNlLmRpc2FibGVNdWx0aVJlbW92ZSxcbiAgICAgICAgICBfaW5zdGFuY2UkbWF4TXVsdGlTb3IgPSBpbnN0YW5jZS5tYXhNdWx0aVNvcnRDb2xDb3VudCxcbiAgICAgICAgICBtYXhNdWx0aVNvcnRDb2xDb3VudCA9IF9pbnN0YW5jZSRtYXhNdWx0aVNvciA9PT0gdm9pZCAwID8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgOiBfaW5zdGFuY2UkbWF4TXVsdGlTb3I7XG4gICAgICB2YXIgX3NvcnRCeTIgPSBzdGF0ZS5zb3J0Qnk7IC8vIEZpbmQgdGhlIGNvbHVtbiBmb3IgdGhpcyBjb2x1bW5JZFxuXG4gICAgICB2YXIgY29sdW1uID0gYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkID09PSBjb2x1bW5JZDtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNvcnREZXNjRmlyc3QgPSBjb2x1bW4uc29ydERlc2NGaXJzdDsgLy8gRmluZCBhbnkgZXhpc3Rpbmcgc29ydEJ5IGZvciB0aGlzIGNvbHVtblxuXG4gICAgICB2YXIgZXhpc3RpbmdTb3J0QnkgPSBfc29ydEJ5Mi5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkID09PSBjb2x1bW5JZDtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZXhpc3RpbmdJbmRleCA9IF9zb3J0QnkyLmZpbmRJbmRleChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5pZCA9PT0gY29sdW1uSWQ7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGhhc0Rlc2NEZWZpbmVkID0gdHlwZW9mIGRlc2MgIT09ICd1bmRlZmluZWQnICYmIGRlc2MgIT09IG51bGw7XG4gICAgICB2YXIgX25ld1NvcnRCeSA9IFtdOyAvLyBXaGF0IHNob3VsZCB3ZSBkbyB3aXRoIHRoaXMgc29ydCBhY3Rpb24/XG5cbiAgICAgIHZhciBzb3J0QWN0aW9uO1xuXG4gICAgICBpZiAoIWRpc2FibGVNdWx0aVNvcnQgJiYgbXVsdGkpIHtcbiAgICAgICAgaWYgKGV4aXN0aW5nU29ydEJ5KSB7XG4gICAgICAgICAgc29ydEFjdGlvbiA9ICd0b2dnbGUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvcnRBY3Rpb24gPSAnYWRkJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsIG1vZGVcbiAgICAgICAgaWYgKGV4aXN0aW5nSW5kZXggIT09IF9zb3J0QnkyLmxlbmd0aCAtIDEgfHwgX3NvcnRCeTIubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgc29ydEFjdGlvbiA9ICdyZXBsYWNlJztcbiAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZ1NvcnRCeSkge1xuICAgICAgICAgIHNvcnRBY3Rpb24gPSAndG9nZ2xlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlcGxhY2UnO1xuICAgICAgICB9XG4gICAgICB9IC8vIEhhbmRsZSB0b2dnbGUgc3RhdGVzIHRoYXQgd2lsbCByZW1vdmUgdGhlIHNvcnRCeVxuXG5cbiAgICAgIGlmIChzb3J0QWN0aW9uID09PSAndG9nZ2xlJyAmJiAvLyBNdXN0IGJlIHRvZ2dsaW5nXG4gICAgICAhZGlzYWJsZVNvcnRSZW1vdmUgJiYgLy8gSWYgZGlzYWJsZVNvcnRSZW1vdmUsIGRpc2FibGUgaW4gZ2VuZXJhbFxuICAgICAgIWhhc0Rlc2NEZWZpbmVkICYmICggLy8gTXVzdCBub3QgYmUgc2V0dGluZyBkZXNjXG4gICAgICBtdWx0aSA/ICFkaXNhYmxlTXVsdGlSZW1vdmUgOiB0cnVlKSAmJiAoIC8vIElmIG11bHRpLCBkb24ndCBhbGxvdyBpZiBkaXNhYmxlTXVsdGlSZW1vdmVcbiAgICAgIGV4aXN0aW5nU29ydEJ5ICYmIC8vIEZpbmFsbHksIGRldGVjdCBpZiBpdCBzaG91bGQgaW5kZWVkIGJlIHJlbW92ZWRcbiAgICAgIGV4aXN0aW5nU29ydEJ5LmRlc2MgJiYgIXNvcnREZXNjRmlyc3QgfHwgIWV4aXN0aW5nU29ydEJ5LmRlc2MgJiYgc29ydERlc2NGaXJzdCkpIHtcbiAgICAgICAgc29ydEFjdGlvbiA9ICdyZW1vdmUnO1xuICAgICAgfVxuXG4gICAgICBpZiAoc29ydEFjdGlvbiA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgIF9uZXdTb3J0QnkgPSBbe1xuICAgICAgICAgIGlkOiBjb2x1bW5JZCxcbiAgICAgICAgICBkZXNjOiBoYXNEZXNjRGVmaW5lZCA/IGRlc2MgOiBzb3J0RGVzY0ZpcnN0XG4gICAgICAgIH1dO1xuICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAnYWRkJykge1xuICAgICAgICBfbmV3U29ydEJ5ID0gW10uY29uY2F0KF9zb3J0QnkyLCBbe1xuICAgICAgICAgIGlkOiBjb2x1bW5JZCxcbiAgICAgICAgICBkZXNjOiBoYXNEZXNjRGVmaW5lZCA/IGRlc2MgOiBzb3J0RGVzY0ZpcnN0XG4gICAgICAgIH1dKTsgLy8gVGFrZSBsYXRlc3QgbiBjb2x1bW5zXG5cbiAgICAgICAgX25ld1NvcnRCeS5zcGxpY2UoMCwgX25ld1NvcnRCeS5sZW5ndGggLSBtYXhNdWx0aVNvcnRDb2xDb3VudCk7XG4gICAgICB9IGVsc2UgaWYgKHNvcnRBY3Rpb24gPT09ICd0b2dnbGUnKSB7XG4gICAgICAgIC8vIFRoaXMgZmxpcHMgKG9yIHNldHMpIHRoZVxuICAgICAgICBfbmV3U29ydEJ5ID0gX3NvcnRCeTIubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgaWYgKGQuaWQgPT09IGNvbHVtbklkKSB7XG4gICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGQsIHtcbiAgICAgICAgICAgICAgZGVzYzogaGFzRGVzY0RlZmluZWQgPyBkZXNjIDogIWV4aXN0aW5nU29ydEJ5LmRlc2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc29ydEFjdGlvbiA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgX25ld1NvcnRCeSA9IF9zb3J0QnkyLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiBkLmlkICE9PSBjb2x1bW5JZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgc29ydEJ5OiBfbmV3U29ydEJ5XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSQ1KGluc3RhbmNlKSB7XG4gICAgdmFyIGRhdGEgPSBpbnN0YW5jZS5kYXRhLFxuICAgICAgICByb3dzID0gaW5zdGFuY2Uucm93cyxcbiAgICAgICAgZmxhdFJvd3MgPSBpbnN0YW5jZS5mbGF0Um93cyxcbiAgICAgICAgYWxsQ29sdW1ucyA9IGluc3RhbmNlLmFsbENvbHVtbnMsXG4gICAgICAgIF9pbnN0YW5jZSRvcmRlckJ5Rm4gPSBpbnN0YW5jZS5vcmRlckJ5Rm4sXG4gICAgICAgIG9yZGVyQnlGbiA9IF9pbnN0YW5jZSRvcmRlckJ5Rm4gPT09IHZvaWQgMCA/IGRlZmF1bHRPcmRlckJ5Rm4gOiBfaW5zdGFuY2Ukb3JkZXJCeUZuLFxuICAgICAgICB1c2VyU29ydFR5cGVzID0gaW5zdGFuY2Uuc29ydFR5cGVzLFxuICAgICAgICBtYW51YWxTb3J0QnkgPSBpbnN0YW5jZS5tYW51YWxTb3J0QnksXG4gICAgICAgIGRlZmF1bHRDYW5Tb3J0ID0gaW5zdGFuY2UuZGVmYXVsdENhblNvcnQsXG4gICAgICAgIGRpc2FibGVTb3J0QnkgPSBpbnN0YW5jZS5kaXNhYmxlU29ydEJ5LFxuICAgICAgICBmbGF0SGVhZGVycyA9IGluc3RhbmNlLmZsYXRIZWFkZXJzLFxuICAgICAgICBzb3J0QnkgPSBpbnN0YW5jZS5zdGF0ZS5zb3J0QnksXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2gsXG4gICAgICAgIHBsdWdpbnMgPSBpbnN0YW5jZS5wbHVnaW5zLFxuICAgICAgICBnZXRIb29rcyA9IGluc3RhbmNlLmdldEhvb2tzLFxuICAgICAgICBfaW5zdGFuY2UkYXV0b1Jlc2V0U28gPSBpbnN0YW5jZS5hdXRvUmVzZXRTb3J0QnksXG4gICAgICAgIGF1dG9SZXNldFNvcnRCeSA9IF9pbnN0YW5jZSRhdXRvUmVzZXRTbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRhdXRvUmVzZXRTbztcbiAgICBlbnN1cmVQbHVnaW5PcmRlcihwbHVnaW5zLCBbJ3VzZUZpbHRlcnMnLCAndXNlR2xvYmFsRmlsdGVyJywgJ3VzZUdyb3VwQnknLCAndXNlUGl2b3RDb2x1bW5zJ10sICd1c2VTb3J0QnknKTtcbiAgICB2YXIgc2V0U29ydEJ5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHNvcnRCeSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnNldFNvcnRCeSxcbiAgICAgICAgc29ydEJ5OiBzb3J0QnlcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pOyAvLyBVcGRhdGVzIHNvcnRpbmcgYmFzZWQgb24gYSBjb2x1bW5JZCwgZGVzYyBmbGFnIGFuZCBtdWx0aSBmbGFnXG5cbiAgICB2YXIgdG9nZ2xlU29ydEJ5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbHVtbklkLCBkZXNjLCBtdWx0aSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZVNvcnRCeSxcbiAgICAgICAgY29sdW1uSWQ6IGNvbHVtbklkLFxuICAgICAgICBkZXNjOiBkZXNjLFxuICAgICAgICBtdWx0aTogbXVsdGlcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pOyAvLyB1c2UgcmVmZXJlbmNlIHRvIGF2b2lkIG1lbW9yeSBsZWFrIGluICMxNjA4XG5cbiAgICB2YXIgZ2V0SW5zdGFuY2UgPSB1c2VHZXRMYXRlc3QoaW5zdGFuY2UpOyAvLyBBZGQgdGhlIGdldFNvcnRCeVRvZ2dsZVByb3BzIG1ldGhvZCB0byBjb2x1bW5zIGFuZCBoZWFkZXJzXG5cbiAgICBmbGF0SGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgIHZhciBhY2Nlc3NvciA9IGNvbHVtbi5hY2Nlc3NvcixcbiAgICAgICAgICBkZWZhdWx0Q29sdW1uQ2FuU29ydCA9IGNvbHVtbi5jYW5Tb3J0LFxuICAgICAgICAgIGNvbHVtbkRpc2FibGVTb3J0QnkgPSBjb2x1bW4uZGlzYWJsZVNvcnRCeSxcbiAgICAgICAgICBpZCA9IGNvbHVtbi5pZDtcbiAgICAgIHZhciBjYW5Tb3J0ID0gYWNjZXNzb3IgPyBnZXRGaXJzdERlZmluZWQoY29sdW1uRGlzYWJsZVNvcnRCeSA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCBkaXNhYmxlU29ydEJ5ID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIHRydWUpIDogZ2V0Rmlyc3REZWZpbmVkKGRlZmF1bHRDYW5Tb3J0LCBkZWZhdWx0Q29sdW1uQ2FuU29ydCwgZmFsc2UpO1xuICAgICAgY29sdW1uLmNhblNvcnQgPSBjYW5Tb3J0O1xuXG4gICAgICBpZiAoY29sdW1uLmNhblNvcnQpIHtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVNvcnRCeSA9IGZ1bmN0aW9uIChkZXNjLCBtdWx0aSkge1xuICAgICAgICAgIHJldHVybiB0b2dnbGVTb3J0QnkoY29sdW1uLmlkLCBkZXNjLCBtdWx0aSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29sdW1uLmNsZWFyU29ydEJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IGFjdGlvbnMuY2xlYXJTb3J0QnksXG4gICAgICAgICAgICBjb2x1bW5JZDogY29sdW1uLmlkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbHVtbi5nZXRTb3J0QnlUb2dnbGVQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0U29ydEJ5VG9nZ2xlUHJvcHMsIHtcbiAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKCksXG4gICAgICAgIGNvbHVtbjogY29sdW1uXG4gICAgICB9KTtcbiAgICAgIHZhciBjb2x1bW5Tb3J0ID0gc29ydEJ5LmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaWQgPT09IGlkO1xuICAgICAgfSk7XG4gICAgICBjb2x1bW4uaXNTb3J0ZWQgPSAhIWNvbHVtblNvcnQ7XG4gICAgICBjb2x1bW4uc29ydGVkSW5kZXggPSBzb3J0QnkuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkID09PSBpZDtcbiAgICAgIH0pO1xuICAgICAgY29sdW1uLmlzU29ydGVkRGVzYyA9IGNvbHVtbi5pc1NvcnRlZCA/IGNvbHVtblNvcnQuZGVzYyA6IHVuZGVmaW5lZDtcbiAgICB9KTtcblxuICAgIHZhciBfUmVhY3QkdXNlTWVtbyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG1hbnVhbFNvcnRCeSB8fCAhc29ydEJ5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW3Jvd3MsIGZsYXRSb3dzXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvcnRlZEZsYXRSb3dzID0gW107IC8vIEZpbHRlciBvdXQgc29ydEJ5cyB0aGF0IGNvcnJlc3BvbmQgdG8gbm9uIGV4aXN0aW5nIGNvbHVtbnNcblxuICAgICAgdmFyIGF2YWlsYWJsZVNvcnRCeSA9IHNvcnRCeS5maWx0ZXIoZnVuY3Rpb24gKHNvcnQpIHtcbiAgICAgICAgcmV0dXJuIGFsbENvbHVtbnMuZmluZChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbC5pZCA9PT0gc29ydC5pZDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHNvcnREYXRhID0gZnVuY3Rpb24gc29ydERhdGEocm93cykge1xuICAgICAgICAvLyBVc2UgdGhlIG9yZGVyQnlGbiB0byBjb21wb3NlIG11bHRpcGxlIHNvcnRCeSdzIHRvZ2V0aGVyLlxuICAgICAgICAvLyBUaGlzIHdpbGwgYWxzbyBwZXJmb3JtIGEgc3RhYmxlIHNvcnRpbmcgdXNpbmcgdGhlIHJvdyBpbmRleFxuICAgICAgICAvLyBpZiBuZWVkZWQuXG4gICAgICAgIHZhciBzb3J0ZWREYXRhID0gb3JkZXJCeUZuKHJvd3MsIGF2YWlsYWJsZVNvcnRCeS5tYXAoZnVuY3Rpb24gKHNvcnQpIHtcbiAgICAgICAgICAvLyBTdXBwb3J0IGN1c3RvbSBzb3J0aW5nIG1ldGhvZHMgZm9yIGVhY2ggY29sdW1uXG4gICAgICAgICAgdmFyIGNvbHVtbiA9IGFsbENvbHVtbnMuZmluZChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQuaWQgPT09IHNvcnQuaWQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QtVGFibGU6IENvdWxkIG5vdCBmaW5kIGEgY29sdW1uIHdpdGggaWQ6IFwiICsgc29ydC5pZCArIFwiIHdoaWxlIHNvcnRpbmdcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNvcnRUeXBlID0gY29sdW1uLnNvcnRUeXBlOyAvLyBMb29rIHVwIHNvcnRCeSBmdW5jdGlvbnMgaW4gdGhpcyBvcmRlcjpcbiAgICAgICAgICAvLyBjb2x1bW4gZnVuY3Rpb25cbiAgICAgICAgICAvLyBjb2x1bW4gc3RyaW5nIGxvb2t1cCBvbiB1c2VyIHNvcnRUeXBlXG4gICAgICAgICAgLy8gY29sdW1uIHN0cmluZyBsb29rdXAgb24gYnVpbHQtaW4gc29ydFR5cGVcbiAgICAgICAgICAvLyBkZWZhdWx0IGZ1bmN0aW9uXG4gICAgICAgICAgLy8gZGVmYXVsdCBzdHJpbmcgbG9va3VwIG9uIHVzZXIgc29ydFR5cGVcbiAgICAgICAgICAvLyBkZWZhdWx0IHN0cmluZyBsb29rdXAgb24gYnVpbHQtaW4gc29ydFR5cGVcblxuICAgICAgICAgIHZhciBzb3J0TWV0aG9kID0gaXNGdW5jdGlvbihzb3J0VHlwZSkgfHwgKHVzZXJTb3J0VHlwZXMgfHwge30pW3NvcnRUeXBlXSB8fCBzb3J0VHlwZXNbc29ydFR5cGVdO1xuXG4gICAgICAgICAgaWYgKCFzb3J0TWV0aG9kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdC1UYWJsZTogQ291bGQgbm90IGZpbmQgYSB2YWxpZCBzb3J0VHlwZSBvZiAnXCIgKyBzb3J0VHlwZSArIFwiJyBmb3IgY29sdW1uICdcIiArIHNvcnQuaWQgKyBcIicuXCIpO1xuICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBjb3JyZWN0IHNvcnRGbi5cbiAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHNob3VsZCBhbHdheXMgcmV0dXJuIGluIGFzY2VuZGluZyBvcmRlclxuXG5cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0TWV0aG9kKGEsIGIsIHNvcnQuaWQsIHNvcnQuZGVzYyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSksIC8vIE1hcCB0aGUgZGlyZWN0aW9uc1xuICAgICAgICBhdmFpbGFibGVTb3J0QnkubWFwKGZ1bmN0aW9uIChzb3J0KSB7XG4gICAgICAgICAgLy8gRGV0ZWN0IGFuZCB1c2UgdGhlIHNvcnRJbnZlcnRlZCBvcHRpb25cbiAgICAgICAgICB2YXIgY29sdW1uID0gYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5pZCA9PT0gc29ydC5pZDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjb2x1bW4gJiYgY29sdW1uLnNvcnRJbnZlcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnQuZGVzYztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gIXNvcnQuZGVzYztcbiAgICAgICAgfSkpOyAvLyBJZiB0aGVyZSBhcmUgc3ViLXJvd3MsIHNvcnQgdGhlbVxuXG4gICAgICAgIHNvcnRlZERhdGEuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgc29ydGVkRmxhdFJvd3MucHVzaChyb3cpO1xuXG4gICAgICAgICAgaWYgKCFyb3cuc3ViUm93cyB8fCByb3cuc3ViUm93cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cuc3ViUm93cyA9IHNvcnREYXRhKHJvdy5zdWJSb3dzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzb3J0ZWREYXRhO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFtzb3J0RGF0YShyb3dzKSwgc29ydGVkRmxhdFJvd3NdO1xuICAgIH0sIFttYW51YWxTb3J0QnksIHNvcnRCeSwgcm93cywgZmxhdFJvd3MsIGFsbENvbHVtbnMsIG9yZGVyQnlGbiwgdXNlclNvcnRUeXBlc10pLFxuICAgICAgICBzb3J0ZWRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMF0sXG4gICAgICAgIHNvcnRlZEZsYXRSb3dzID0gX1JlYWN0JHVzZU1lbW9bMV07XG5cbiAgICB2YXIgZ2V0QXV0b1Jlc2V0U29ydEJ5ID0gdXNlR2V0TGF0ZXN0KGF1dG9SZXNldFNvcnRCeSk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0U29ydEJ5KCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRTb3J0QnlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW21hbnVhbFNvcnRCeSA/IG51bGwgOiBkYXRhXSk7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwge1xuICAgICAgcHJlU29ydGVkUm93czogcm93cyxcbiAgICAgIHByZVNvcnRlZEZsYXRSb3dzOiBmbGF0Um93cyxcbiAgICAgIHNvcnRlZFJvd3M6IHNvcnRlZFJvd3MsXG4gICAgICBzb3J0ZWRGbGF0Um93czogc29ydGVkRmxhdFJvd3MsXG4gICAgICByb3dzOiBzb3J0ZWRSb3dzLFxuICAgICAgZmxhdFJvd3M6IHNvcnRlZEZsYXRSb3dzLFxuICAgICAgc2V0U29ydEJ5OiBzZXRTb3J0QnksXG4gICAgICB0b2dnbGVTb3J0Qnk6IHRvZ2dsZVNvcnRCeVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdE9yZGVyQnlGbihhcnIsIGZ1bmNzLCBkaXJzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChhcnIpLnNvcnQoZnVuY3Rpb24gKHJvd0EsIHJvd0IpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNvcnRGbiA9IGZ1bmNzW2ldO1xuICAgICAgICB2YXIgZGVzYyA9IGRpcnNbaV0gPT09IGZhbHNlIHx8IGRpcnNbaV0gPT09ICdkZXNjJztcbiAgICAgICAgdmFyIHNvcnRJbnQgPSBzb3J0Rm4ocm93QSwgcm93Qik7XG5cbiAgICAgICAgaWYgKHNvcnRJbnQgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZGVzYyA/IC1zb3J0SW50IDogc29ydEludDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlyc1swXSA/IHJvd0EuaW5kZXggLSByb3dCLmluZGV4IDogcm93Qi5pbmRleCAtIHJvd0EuaW5kZXg7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcGx1Z2luTmFtZSA9ICd1c2VQYWdpbmF0aW9uJzsgLy8gQWN0aW9uc1xuXG4gIGFjdGlvbnMucmVzZXRQYWdlID0gJ3Jlc2V0UGFnZSc7XG4gIGFjdGlvbnMuZ290b1BhZ2UgPSAnZ290b1BhZ2UnO1xuICBhY3Rpb25zLnNldFBhZ2VTaXplID0gJ3NldFBhZ2VTaXplJztcbiAgdmFyIHVzZVBhZ2luYXRpb24gPSBmdW5jdGlvbiB1c2VQYWdpbmF0aW9uKGhvb2tzKSB7XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkNik7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSQ2KTtcbiAgfTtcbiAgdXNlUGFnaW5hdGlvbi5wbHVnaW5OYW1lID0gcGx1Z2luTmFtZTtcblxuICBmdW5jdGlvbiByZWR1Y2VyJDYoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgcGFnZVNpemU6IDEwLFxuICAgICAgICBwYWdlSW5kZXg6IDBcbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRQYWdlKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHBhZ2VJbmRleDogaW5zdGFuY2UuaW5pdGlhbFN0YXRlLnBhZ2VJbmRleCB8fCAwXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuZ290b1BhZ2UpIHtcbiAgICAgIHZhciBwYWdlQ291bnQgPSBpbnN0YW5jZS5wYWdlQ291bnQsXG4gICAgICAgICAgcGFnZSA9IGluc3RhbmNlLnBhZ2U7XG4gICAgICB2YXIgbmV3UGFnZUluZGV4ID0gZnVuY3Rpb25hbFVwZGF0ZShhY3Rpb24ucGFnZUluZGV4LCBzdGF0ZS5wYWdlSW5kZXgpO1xuICAgICAgdmFyIGNhbk5hdmlnYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmIChuZXdQYWdlSW5kZXggPiBzdGF0ZS5wYWdlSW5kZXgpIHtcbiAgICAgICAgLy8gbmV4dCBwYWdlXG4gICAgICAgIGNhbk5hdmlnYXRlID0gcGFnZUNvdW50ID09PSAtMSA/IHBhZ2UubGVuZ3RoID49IHN0YXRlLnBhZ2VTaXplIDogbmV3UGFnZUluZGV4IDwgcGFnZUNvdW50O1xuICAgICAgfSBlbHNlIGlmIChuZXdQYWdlSW5kZXggPCBzdGF0ZS5wYWdlSW5kZXgpIHtcbiAgICAgICAgLy8gcHJldiBwYWdlXG4gICAgICAgIGNhbk5hdmlnYXRlID0gbmV3UGFnZUluZGV4ID4gLTE7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2FuTmF2aWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHBhZ2VJbmRleDogbmV3UGFnZUluZGV4XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0UGFnZVNpemUpIHtcbiAgICAgIHZhciBwYWdlU2l6ZSA9IGFjdGlvbi5wYWdlU2l6ZTtcbiAgICAgIHZhciB0b3BSb3dJbmRleCA9IHN0YXRlLnBhZ2VTaXplICogc3RhdGUucGFnZUluZGV4O1xuICAgICAgdmFyIHBhZ2VJbmRleCA9IE1hdGguZmxvb3IodG9wUm93SW5kZXggLyBwYWdlU2l6ZSk7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4LFxuICAgICAgICBwYWdlU2l6ZTogcGFnZVNpemVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUluc3RhbmNlJDYoaW5zdGFuY2UpIHtcbiAgICB2YXIgcm93cyA9IGluc3RhbmNlLnJvd3MsXG4gICAgICAgIF9pbnN0YW5jZSRhdXRvUmVzZXRQYSA9IGluc3RhbmNlLmF1dG9SZXNldFBhZ2UsXG4gICAgICAgIGF1dG9SZXNldFBhZ2UgPSBfaW5zdGFuY2UkYXV0b1Jlc2V0UGEgPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkYXV0b1Jlc2V0UGEsXG4gICAgICAgIF9pbnN0YW5jZSRtYW51YWxFeHBhbiA9IGluc3RhbmNlLm1hbnVhbEV4cGFuZGVkS2V5LFxuICAgICAgICBtYW51YWxFeHBhbmRlZEtleSA9IF9pbnN0YW5jZSRtYW51YWxFeHBhbiA9PT0gdm9pZCAwID8gJ2V4cGFuZGVkJyA6IF9pbnN0YW5jZSRtYW51YWxFeHBhbixcbiAgICAgICAgcGx1Z2lucyA9IGluc3RhbmNlLnBsdWdpbnMsXG4gICAgICAgIHVzZXJQYWdlQ291bnQgPSBpbnN0YW5jZS5wYWdlQ291bnQsXG4gICAgICAgIF9pbnN0YW5jZSRwYWdpbmF0ZUV4cCA9IGluc3RhbmNlLnBhZ2luYXRlRXhwYW5kZWRSb3dzLFxuICAgICAgICBwYWdpbmF0ZUV4cGFuZGVkUm93cyA9IF9pbnN0YW5jZSRwYWdpbmF0ZUV4cCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRwYWdpbmF0ZUV4cCxcbiAgICAgICAgX2luc3RhbmNlJGV4cGFuZFN1YlJvID0gaW5zdGFuY2UuZXhwYW5kU3ViUm93cyxcbiAgICAgICAgZXhwYW5kU3ViUm93cyA9IF9pbnN0YW5jZSRleHBhbmRTdWJSbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRleHBhbmRTdWJSbyxcbiAgICAgICAgX2luc3RhbmNlJHN0YXRlID0gaW5zdGFuY2Uuc3RhdGUsXG4gICAgICAgIHBhZ2VTaXplID0gX2luc3RhbmNlJHN0YXRlLnBhZ2VTaXplLFxuICAgICAgICBwYWdlSW5kZXggPSBfaW5zdGFuY2Ukc3RhdGUucGFnZUluZGV4LFxuICAgICAgICBleHBhbmRlZCA9IF9pbnN0YW5jZSRzdGF0ZS5leHBhbmRlZCxcbiAgICAgICAgZ2xvYmFsRmlsdGVyID0gX2luc3RhbmNlJHN0YXRlLmdsb2JhbEZpbHRlcixcbiAgICAgICAgZmlsdGVycyA9IF9pbnN0YW5jZSRzdGF0ZS5maWx0ZXJzLFxuICAgICAgICBncm91cEJ5ID0gX2luc3RhbmNlJHN0YXRlLmdyb3VwQnksXG4gICAgICAgIHNvcnRCeSA9IF9pbnN0YW5jZSRzdGF0ZS5zb3J0QnksXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2gsXG4gICAgICAgIGRhdGEgPSBpbnN0YW5jZS5kYXRhLFxuICAgICAgICBtYW51YWxQYWdpbmF0aW9uID0gaW5zdGFuY2UubWFudWFsUGFnaW5hdGlvbjtcbiAgICBlbnN1cmVQbHVnaW5PcmRlcihwbHVnaW5zLCBbJ3VzZUdsb2JhbEZpbHRlcicsICd1c2VGaWx0ZXJzJywgJ3VzZUdyb3VwQnknLCAndXNlU29ydEJ5JywgJ3VzZUV4cGFuZGVkJ10sICd1c2VQYWdpbmF0aW9uJyk7XG4gICAgdmFyIGdldEF1dG9SZXNldFBhZ2UgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0UGFnZSk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0UGFnZSgpKSB7XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBhY3Rpb25zLnJlc2V0UGFnZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbZGlzcGF0Y2gsIG1hbnVhbFBhZ2luYXRpb24gPyBudWxsIDogZGF0YSwgZ2xvYmFsRmlsdGVyLCBmaWx0ZXJzLCBncm91cEJ5LCBzb3J0QnldKTtcbiAgICB2YXIgcGFnZUNvdW50ID0gbWFudWFsUGFnaW5hdGlvbiA/IHVzZXJQYWdlQ291bnQgOiBNYXRoLmNlaWwocm93cy5sZW5ndGggLyBwYWdlU2l6ZSk7XG4gICAgdmFyIHBhZ2VPcHRpb25zID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGFnZUNvdW50ID4gMCA/IFtdLmNvbmNhdChuZXcgQXJyYXkocGFnZUNvdW50KSkuZmlsbChudWxsKS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9KSA6IFtdO1xuICAgIH0sIFtwYWdlQ291bnRdKTtcbiAgICB2YXIgcGFnZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhZ2U7XG5cbiAgICAgIGlmIChtYW51YWxQYWdpbmF0aW9uKSB7XG4gICAgICAgIHBhZ2UgPSByb3dzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhZ2VTdGFydCA9IHBhZ2VTaXplICogcGFnZUluZGV4O1xuICAgICAgICB2YXIgcGFnZUVuZCA9IHBhZ2VTdGFydCArIHBhZ2VTaXplO1xuICAgICAgICBwYWdlID0gcm93cy5zbGljZShwYWdlU3RhcnQsIHBhZ2VFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcbiAgICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHBhbmRSb3dzKHBhZ2UsIHtcbiAgICAgICAgbWFudWFsRXhwYW5kZWRLZXk6IG1hbnVhbEV4cGFuZGVkS2V5LFxuICAgICAgICBleHBhbmRlZDogZXhwYW5kZWQsXG4gICAgICAgIGV4cGFuZFN1YlJvd3M6IGV4cGFuZFN1YlJvd3NcbiAgICAgIH0pO1xuICAgIH0sIFtleHBhbmRTdWJSb3dzLCBleHBhbmRlZCwgbWFudWFsRXhwYW5kZWRLZXksIG1hbnVhbFBhZ2luYXRpb24sIHBhZ2VJbmRleCwgcGFnZVNpemUsIHBhZ2luYXRlRXhwYW5kZWRSb3dzLCByb3dzXSk7XG4gICAgdmFyIGNhblByZXZpb3VzUGFnZSA9IHBhZ2VJbmRleCA+IDA7XG4gICAgdmFyIGNhbk5leHRQYWdlID0gcGFnZUNvdW50ID09PSAtMSA/IHBhZ2UubGVuZ3RoID49IHBhZ2VTaXplIDogcGFnZUluZGV4IDwgcGFnZUNvdW50IC0gMTtcbiAgICB2YXIgZ290b1BhZ2UgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAocGFnZUluZGV4KSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuZ290b1BhZ2UsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4XG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgcHJldmlvdXNQYWdlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdvdG9QYWdlKGZ1bmN0aW9uIChvbGQpIHtcbiAgICAgICAgcmV0dXJuIG9sZCAtIDE7XG4gICAgICB9KTtcbiAgICB9LCBbZ290b1BhZ2VdKTtcbiAgICB2YXIgbmV4dFBhZ2UgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ290b1BhZ2UoZnVuY3Rpb24gKG9sZCkge1xuICAgICAgICByZXR1cm4gb2xkICsgMTtcbiAgICAgIH0pO1xuICAgIH0sIFtnb3RvUGFnZV0pO1xuICAgIHZhciBzZXRQYWdlU2l6ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChwYWdlU2l6ZSkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnNldFBhZ2VTaXplLFxuICAgICAgICBwYWdlU2l6ZTogcGFnZVNpemVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIHBhZ2VPcHRpb25zOiBwYWdlT3B0aW9ucyxcbiAgICAgIHBhZ2VDb3VudDogcGFnZUNvdW50LFxuICAgICAgcGFnZTogcGFnZSxcbiAgICAgIGNhblByZXZpb3VzUGFnZTogY2FuUHJldmlvdXNQYWdlLFxuICAgICAgY2FuTmV4dFBhZ2U6IGNhbk5leHRQYWdlLFxuICAgICAgZ290b1BhZ2U6IGdvdG9QYWdlLFxuICAgICAgcHJldmlvdXNQYWdlOiBwcmV2aW91c1BhZ2UsXG4gICAgICBuZXh0UGFnZTogbmV4dFBhZ2UsXG4gICAgICBzZXRQYWdlU2l6ZTogc2V0UGFnZVNpemVcbiAgICB9KTtcbiAgfVxuXG4gIGFjdGlvbnMucmVzZXRQaXZvdCA9ICdyZXNldFBpdm90JztcbiAgYWN0aW9ucy50b2dnbGVQaXZvdCA9ICd0b2dnbGVQaXZvdCc7XG4gIHZhciBfVU5TVEFCTEVfdXNlUGl2b3RDb2x1bW5zID0gZnVuY3Rpb24gX1VOU1RBQkxFX3VzZVBpdm90Q29sdW1ucyhob29rcykge1xuICAgIGhvb2tzLmdldFBpdm90VG9nZ2xlUHJvcHMgPSBbZGVmYXVsdEdldFBpdm90VG9nZ2xlUHJvcHNdO1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyJDcpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlQWZ0ZXJEYXRhLnB1c2godXNlSW5zdGFuY2VBZnRlckRhdGEpO1xuICAgIGhvb2tzLmFsbENvbHVtbnMucHVzaChhbGxDb2x1bW5zKTtcbiAgICBob29rcy5hY2Nlc3NWYWx1ZS5wdXNoKGFjY2Vzc1ZhbHVlKTtcbiAgICBob29rcy5tYXRlcmlhbGl6ZWRDb2x1bW5zLnB1c2gobWF0ZXJpYWxpemVkQ29sdW1ucyk7XG4gICAgaG9va3MubWF0ZXJpYWxpemVkQ29sdW1uc0RlcHMucHVzaChtYXRlcmlhbGl6ZWRDb2x1bW5zRGVwcyk7XG4gICAgaG9va3MudmlzaWJsZUNvbHVtbnMucHVzaCh2aXNpYmxlQ29sdW1ucyQxKTtcbiAgICBob29rcy52aXNpYmxlQ29sdW1uc0RlcHMucHVzaCh2aXNpYmxlQ29sdW1uc0RlcHMpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UkNyk7XG4gICAgaG9va3MucHJlcGFyZVJvdy5wdXNoKHByZXBhcmVSb3ckMik7XG4gIH07XG4gIF9VTlNUQUJMRV91c2VQaXZvdENvbHVtbnMucGx1Z2luTmFtZSA9ICd1c2VQaXZvdENvbHVtbnMnO1xuICB2YXIgZGVmYXVsdFBpdm90Q29sdW1ucyA9IFtdO1xuXG4gIHZhciBkZWZhdWx0R2V0UGl2b3RUb2dnbGVQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRQaXZvdFRvZ2dsZVByb3BzKHByb3BzLCBfcmVmKSB7XG4gICAgdmFyIGhlYWRlciA9IF9yZWYuaGVhZGVyO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIG9uQ2xpY2s6IGhlYWRlci5jYW5QaXZvdCA/IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgICBoZWFkZXIudG9nZ2xlUGl2b3QoKTtcbiAgICAgIH0gOiB1bmRlZmluZWQsXG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6IGhlYWRlci5jYW5QaXZvdCA/ICdwb2ludGVyJyA6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIHRpdGxlOiAnVG9nZ2xlIFBpdm90J1xuICAgIH1dO1xuICB9OyAvLyBSZWR1Y2VyXG5cblxuICBmdW5jdGlvbiByZWR1Y2VyJDcoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgcGl2b3RDb2x1bW5zOiBkZWZhdWx0UGl2b3RDb2x1bW5zXG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnJlc2V0UGl2b3QpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgcGl2b3RDb2x1bW5zOiBpbnN0YW5jZS5pbml0aWFsU3RhdGUucGl2b3RDb2x1bW5zIHx8IGRlZmF1bHRQaXZvdENvbHVtbnNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy50b2dnbGVQaXZvdCkge1xuICAgICAgdmFyIGNvbHVtbklkID0gYWN0aW9uLmNvbHVtbklkLFxuICAgICAgICAgIHNldFBpdm90ID0gYWN0aW9uLnZhbHVlO1xuICAgICAgdmFyIHJlc29sdmVkUGl2b3QgPSB0eXBlb2Ygc2V0UGl2b3QgIT09ICd1bmRlZmluZWQnID8gc2V0UGl2b3QgOiAhc3RhdGUucGl2b3RDb2x1bW5zLmluY2x1ZGVzKGNvbHVtbklkKTtcblxuICAgICAgaWYgKHJlc29sdmVkUGl2b3QpIHtcbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICAgIHBpdm90Q29sdW1uczogW10uY29uY2F0KHN0YXRlLnBpdm90Q29sdW1ucywgW2NvbHVtbklkXSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgcGl2b3RDb2x1bW5zOiBzdGF0ZS5waXZvdENvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGQgIT09IGNvbHVtbklkO1xuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2VBZnRlckRhdGEoaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS5hbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgY29sdW1uLmlzUGl2b3RTb3VyY2UgPSBpbnN0YW5jZS5zdGF0ZS5waXZvdENvbHVtbnMuaW5jbHVkZXMoY29sdW1uLmlkKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbENvbHVtbnMoY29sdW1ucywgX3JlZjIpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmMi5pbnN0YW5jZTtcbiAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgY29sdW1uLmlzUGl2b3RTb3VyY2UgPSBpbnN0YW5jZS5zdGF0ZS5waXZvdENvbHVtbnMuaW5jbHVkZXMoY29sdW1uLmlkKTtcbiAgICAgIGNvbHVtbi51bmlxdWVWYWx1ZXMgPSBuZXcgU2V0KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbHVtbnM7XG4gIH1cblxuICBmdW5jdGlvbiBhY2Nlc3NWYWx1ZSh2YWx1ZSwgX3JlZjMpIHtcbiAgICB2YXIgY29sdW1uID0gX3JlZjMuY29sdW1uO1xuXG4gICAgaWYgKGNvbHVtbi51bmlxdWVWYWx1ZXMgJiYgdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29sdW1uLnVuaXF1ZVZhbHVlcy5hZGQodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGVyaWFsaXplZENvbHVtbnMobWF0ZXJpYWxpemVkLCBfcmVmNCkge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWY0Lmluc3RhbmNlO1xuICAgIHZhciBhbGxDb2x1bW5zID0gaW5zdGFuY2UuYWxsQ29sdW1ucyxcbiAgICAgICAgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICAgIGlmICghc3RhdGUucGl2b3RDb2x1bW5zLmxlbmd0aCB8fCAhc3RhdGUuZ3JvdXBCeSB8fCAhc3RhdGUuZ3JvdXBCeS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBtYXRlcmlhbGl6ZWQ7XG4gICAgfVxuXG4gICAgdmFyIHBpdm90Q29sdW1ucyA9IHN0YXRlLnBpdm90Q29sdW1ucy5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gYWxsQ29sdW1ucy5maW5kKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkID09PSBpZDtcbiAgICAgIH0pO1xuICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgICB2YXIgc291cmNlQ29sdW1ucyA9IGFsbENvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gIWQuaXNQaXZvdFNvdXJjZSAmJiAhc3RhdGUuZ3JvdXBCeS5pbmNsdWRlcyhkLmlkKSAmJiAhc3RhdGUucGl2b3RDb2x1bW5zLmluY2x1ZGVzKGQuaWQpO1xuICAgIH0pO1xuXG4gICAgdmFyIGJ1aWxkUGl2b3RDb2x1bW5zID0gZnVuY3Rpb24gYnVpbGRQaXZvdENvbHVtbnMoZGVwdGgsIHBhcmVudCwgcGl2b3RGaWx0ZXJzKSB7XG4gICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICBkZXB0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChwaXZvdEZpbHRlcnMgPT09IHZvaWQgMCkge1xuICAgICAgICBwaXZvdEZpbHRlcnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBpdm90Q29sdW1uID0gcGl2b3RDb2x1bW5zW2RlcHRoXTtcblxuICAgICAgaWYgKCFwaXZvdENvbHVtbikge1xuICAgICAgICByZXR1cm4gc291cmNlQ29sdW1ucy5tYXAoZnVuY3Rpb24gKHNvdXJjZUNvbHVtbikge1xuICAgICAgICAgIC8vIFRPRE86IFdlIGNvdWxkIG9mZmVyIHN1cHBvcnQgaGVyZSBmb3IgcmVuZXN0aW5nIHBpdm90ZWRcbiAgICAgICAgICAvLyBjb2x1bW5zIGluc2lkZSBjb3BpZXMgb2YgdGhlaXIgaGVhZGVyIGdyb3Vwcy4gRm9yIG5vdyxcbiAgICAgICAgICAvLyB0aGF0IHNlZW1zIGxpa2UgaXQgd291bGQgYmUgKDEpIG92ZXJraWxsIG9uIG5lc3RpbmcsIGNvbnNpZGVyaW5nXG4gICAgICAgICAgLy8geW91IGFscmVhZHkgZ2V0IG5lc3RpbmcgZm9yIGV2ZXJ5IHBpdm90IGxldmVsIGFuZCAoMilcbiAgICAgICAgICAvLyByZWFsbHkgaGFyZC4gOilcbiAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHNvdXJjZUNvbHVtbiwge1xuICAgICAgICAgICAgY2FuUGl2b3Q6IGZhbHNlLFxuICAgICAgICAgICAgaXNQaXZvdGVkOiB0cnVlLFxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICBkZXB0aDogZGVwdGgsXG4gICAgICAgICAgICBpZDogXCJcIiArIChwYXJlbnQgPyBwYXJlbnQuaWQgKyBcIi5cIiArIHNvdXJjZUNvbHVtbi5pZCA6IHNvdXJjZUNvbHVtbi5pZCksXG4gICAgICAgICAgICBhY2Nlc3NvcjogZnVuY3Rpb24gYWNjZXNzb3Iob3JpZ2luYWxSb3csIGksIHJvdykge1xuICAgICAgICAgICAgICBpZiAocGl2b3RGaWx0ZXJzLmV2ZXJ5KGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyKHJvdyk7XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdy52YWx1ZXNbc291cmNlQ29sdW1uLmlkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVuaXF1ZVZhbHVlcyA9IEFycmF5LmZyb20ocGl2b3RDb2x1bW4udW5pcXVlVmFsdWVzKS5zb3J0KCk7XG4gICAgICByZXR1cm4gdW5pcXVlVmFsdWVzLm1hcChmdW5jdGlvbiAodW5pcXVlVmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbHVtbkdyb3VwID0gX2V4dGVuZHMoe30sIHBpdm90Q29sdW1uLCB7XG4gICAgICAgICAgSGVhZGVyOiBwaXZvdENvbHVtbi5QaXZvdEhlYWRlciB8fCB0eXBlb2YgcGl2b3RDb2x1bW4uaGVhZGVyID09PSAnc3RyaW5nJyA/IHBpdm90Q29sdW1uLkhlYWRlciArIFwiOiBcIiArIHVuaXF1ZVZhbHVlIDogdW5pcXVlVmFsdWUsXG4gICAgICAgICAgaXNQaXZvdEdyb3VwOiB0cnVlLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgICAgICBpZDogcGFyZW50ID8gcGFyZW50LmlkICsgXCIuXCIgKyBwaXZvdENvbHVtbi5pZCArIFwiLlwiICsgdW5pcXVlVmFsdWUgOiBwaXZvdENvbHVtbi5pZCArIFwiLlwiICsgdW5pcXVlVmFsdWUsXG4gICAgICAgICAgcGl2b3RWYWx1ZTogdW5pcXVlVmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29sdW1uR3JvdXAuY29sdW1ucyA9IGJ1aWxkUGl2b3RDb2x1bW5zKGRlcHRoICsgMSwgY29sdW1uR3JvdXAsIFtdLmNvbmNhdChwaXZvdEZpbHRlcnMsIFtmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgcmV0dXJuIHJvdy52YWx1ZXNbcGl2b3RDb2x1bW4uaWRdID09PSB1bmlxdWVWYWx1ZTtcbiAgICAgICAgfV0pKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbkdyb3VwO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBuZXdNYXRlcmlhbGl6ZWQgPSBmbGF0dGVuQ29sdW1ucyhidWlsZFBpdm90Q29sdW1ucygpKTtcbiAgICByZXR1cm4gW10uY29uY2F0KG1hdGVyaWFsaXplZCwgbmV3TWF0ZXJpYWxpemVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGVyaWFsaXplZENvbHVtbnNEZXBzKGRlcHMsIF9yZWY1KSB7XG4gICAgdmFyIF9yZWY1JGluc3RhbmNlJHN0YXRlID0gX3JlZjUuaW5zdGFuY2Uuc3RhdGUsXG4gICAgICAgIHBpdm90Q29sdW1ucyA9IF9yZWY1JGluc3RhbmNlJHN0YXRlLnBpdm90Q29sdW1ucyxcbiAgICAgICAgZ3JvdXBCeSA9IF9yZWY1JGluc3RhbmNlJHN0YXRlLmdyb3VwQnk7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChkZXBzLCBbcGl2b3RDb2x1bW5zLCBncm91cEJ5XSk7XG4gIH1cblxuICBmdW5jdGlvbiB2aXNpYmxlQ29sdW1ucyQxKHZpc2libGVDb2x1bW5zLCBfcmVmNikge1xuICAgIHZhciBzdGF0ZSA9IF9yZWY2Lmluc3RhbmNlLnN0YXRlO1xuICAgIHZpc2libGVDb2x1bW5zID0gdmlzaWJsZUNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gIWQuaXNQaXZvdFNvdXJjZTtcbiAgICB9KTtcblxuICAgIGlmIChzdGF0ZS5waXZvdENvbHVtbnMubGVuZ3RoICYmIHN0YXRlLmdyb3VwQnkgJiYgc3RhdGUuZ3JvdXBCeS5sZW5ndGgpIHtcbiAgICAgIHZpc2libGVDb2x1bW5zID0gdmlzaWJsZUNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbi5pc0dyb3VwZWQgfHwgY29sdW1uLmlzUGl2b3RlZDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB2aXNpYmxlQ29sdW1ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2libGVDb2x1bW5zRGVwcyhkZXBzLCBfcmVmNykge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWY3Lmluc3RhbmNlO1xuICAgIHJldHVybiBbXS5jb25jYXQoZGVwcywgW2luc3RhbmNlLnN0YXRlLnBpdm90Q29sdW1ucywgaW5zdGFuY2Uuc3RhdGUuZ3JvdXBCeV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkNyhpbnN0YW5jZSkge1xuICAgIHZhciBjb2x1bW5zID0gaW5zdGFuY2UuY29sdW1ucyxcbiAgICAgICAgYWxsQ29sdW1ucyA9IGluc3RhbmNlLmFsbENvbHVtbnMsXG4gICAgICAgIGZsYXRIZWFkZXJzID0gaW5zdGFuY2UuZmxhdEhlYWRlcnMsXG4gICAgICAgIGdldEhvb2tzID0gaW5zdGFuY2UuZ2V0SG9va3MsXG4gICAgICAgIHBsdWdpbnMgPSBpbnN0YW5jZS5wbHVnaW5zLFxuICAgICAgICBkaXNwYXRjaCA9IGluc3RhbmNlLmRpc3BhdGNoLFxuICAgICAgICBfaW5zdGFuY2UkYXV0b1Jlc2V0UGkgPSBpbnN0YW5jZS5hdXRvUmVzZXRQaXZvdCxcbiAgICAgICAgYXV0b1Jlc2V0UGl2b3QgPSBfaW5zdGFuY2UkYXV0b1Jlc2V0UGkgPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkYXV0b1Jlc2V0UGksXG4gICAgICAgIG1hbmF1bFBpdm90ID0gaW5zdGFuY2UubWFuYXVsUGl2b3QsXG4gICAgICAgIGRpc2FibGVQaXZvdCA9IGluc3RhbmNlLmRpc2FibGVQaXZvdCxcbiAgICAgICAgZGVmYXVsdENhblBpdm90ID0gaW5zdGFuY2UuZGVmYXVsdENhblBpdm90O1xuICAgIGVuc3VyZVBsdWdpbk9yZGVyKHBsdWdpbnMsIFsndXNlR3JvdXBCeSddLCAndXNlUGl2b3RDb2x1bW5zJyk7XG4gICAgdmFyIGdldEluc3RhbmNlID0gdXNlR2V0TGF0ZXN0KGluc3RhbmNlKTtcbiAgICBhbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgdmFyIGFjY2Vzc29yID0gY29sdW1uLmFjY2Vzc29yLFxuICAgICAgICAgIGRlZmF1bHRDb2x1bW5QaXZvdCA9IGNvbHVtbi5kZWZhdWx0UGl2b3QsXG4gICAgICAgICAgY29sdW1uRGlzYWJsZVBpdm90ID0gY29sdW1uLmRpc2FibGVQaXZvdDtcbiAgICAgIGNvbHVtbi5jYW5QaXZvdCA9IGFjY2Vzc29yID8gZ2V0Rmlyc3REZWZpbmVkKGNvbHVtbi5jYW5QaXZvdCwgY29sdW1uRGlzYWJsZVBpdm90ID09PSB0cnVlID8gZmFsc2UgOiB1bmRlZmluZWQsIGRpc2FibGVQaXZvdCA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCB0cnVlKSA6IGdldEZpcnN0RGVmaW5lZChjb2x1bW4uY2FuUGl2b3QsIGRlZmF1bHRDb2x1bW5QaXZvdCwgZGVmYXVsdENhblBpdm90LCBmYWxzZSk7XG5cbiAgICAgIGlmIChjb2x1bW4uY2FuUGl2b3QpIHtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVBpdm90ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZS50b2dnbGVQaXZvdChjb2x1bW4uaWQpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb2x1bW4uQWdncmVnYXRlZCA9IGNvbHVtbi5BZ2dyZWdhdGVkIHx8IGNvbHVtbi5DZWxsO1xuICAgIH0pO1xuXG4gICAgdmFyIHRvZ2dsZVBpdm90ID0gZnVuY3Rpb24gdG9nZ2xlUGl2b3QoY29sdW1uSWQsIHZhbHVlKSB7XG4gICAgICBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMudG9nZ2xlUGl2b3QsXG4gICAgICAgIGNvbHVtbklkOiBjb2x1bW5JZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZmxhdEhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICBoZWFkZXIuZ2V0UGl2b3RUb2dnbGVQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0UGl2b3RUb2dnbGVQcm9wcywge1xuICAgICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKSxcbiAgICAgICAgaGVhZGVyOiBoZWFkZXJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBnZXRBdXRvUmVzZXRQaXZvdCA9IHVzZUdldExhdGVzdChhdXRvUmVzZXRQaXZvdCk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0UGl2b3QoKSkge1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5yZXNldFBpdm90XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIFtkaXNwYXRjaCwgbWFuYXVsUGl2b3QgPyBudWxsIDogY29sdW1uc10pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIHRvZ2dsZVBpdm90OiB0b2dnbGVQaXZvdFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVJvdyQyKHJvdykge1xuICAgIHJvdy5hbGxDZWxscy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAvLyBHcm91cGVkIGNlbGxzIGFyZSBpbiB0aGUgcGl2b3RDb2x1bW5zIGFuZCB0aGUgcGl2b3QgY2VsbCBmb3IgdGhlIHJvd1xuICAgICAgY2VsbC5pc1Bpdm90ZWQgPSBjZWxsLmNvbHVtbi5pc1Bpdm90ZWQ7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcGx1Z2luTmFtZSQxID0gJ3VzZVJvd1NlbGVjdCc7IC8vIEFjdGlvbnNcblxuICBhY3Rpb25zLnJlc2V0U2VsZWN0ZWRSb3dzID0gJ3Jlc2V0U2VsZWN0ZWRSb3dzJztcbiAgYWN0aW9ucy50b2dnbGVBbGxSb3dzU2VsZWN0ZWQgPSAndG9nZ2xlQWxsUm93c1NlbGVjdGVkJztcbiAgYWN0aW9ucy50b2dnbGVSb3dTZWxlY3RlZCA9ICd0b2dnbGVSb3dTZWxlY3RlZCc7XG4gIGFjdGlvbnMudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCA9ICd0b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkJztcbiAgdmFyIHVzZVJvd1NlbGVjdCA9IGZ1bmN0aW9uIHVzZVJvd1NlbGVjdChob29rcykge1xuICAgIGhvb2tzLmdldFRvZ2dsZVJvd1NlbGVjdGVkUHJvcHMgPSBbZGVmYXVsdEdldFRvZ2dsZVJvd1NlbGVjdGVkUHJvcHNdO1xuICAgIGhvb2tzLmdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzID0gW2RlZmF1bHRHZXRUb2dnbGVBbGxSb3dzU2VsZWN0ZWRQcm9wc107XG4gICAgaG9va3MuZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZFByb3BzID0gW2RlZmF1bHRHZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkUHJvcHNdO1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyJDgpO1xuICAgIGhvb2tzLnVzZUluc3RhbmNlLnB1c2godXNlSW5zdGFuY2UkOCk7XG4gICAgaG9va3MucHJlcGFyZVJvdy5wdXNoKHByZXBhcmVSb3ckMyk7XG4gIH07XG4gIHVzZVJvd1NlbGVjdC5wbHVnaW5OYW1lID0gcGx1Z2luTmFtZSQxO1xuXG4gIHZhciBkZWZhdWx0R2V0VG9nZ2xlUm93U2VsZWN0ZWRQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRUb2dnbGVSb3dTZWxlY3RlZFByb3BzKHByb3BzLCBfcmVmKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgICAgcm93ID0gX3JlZi5yb3c7XG4gICAgdmFyIF9pbnN0YW5jZSRtYW51YWxSb3dTZSA9IGluc3RhbmNlLm1hbnVhbFJvd1NlbGVjdGVkS2V5LFxuICAgICAgICBtYW51YWxSb3dTZWxlY3RlZEtleSA9IF9pbnN0YW5jZSRtYW51YWxSb3dTZSA9PT0gdm9pZCAwID8gJ2lzU2VsZWN0ZWQnIDogX2luc3RhbmNlJG1hbnVhbFJvd1NlO1xuICAgIHZhciBjaGVja2VkID0gZmFsc2U7XG5cbiAgICBpZiAocm93Lm9yaWdpbmFsICYmIHJvdy5vcmlnaW5hbFttYW51YWxSb3dTZWxlY3RlZEtleV0pIHtcbiAgICAgIGNoZWNrZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja2VkID0gcm93LmlzU2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICAgICAgcm93LnRvZ2dsZVJvd1NlbGVjdGVkKGUudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LFxuICAgICAgY2hlY2tlZDogY2hlY2tlZCxcbiAgICAgIHRpdGxlOiAnVG9nZ2xlIFJvdyBTZWxlY3RlZCcsXG4gICAgICBpbmRldGVybWluYXRlOiByb3cuaXNTb21lU2VsZWN0ZWRcbiAgICB9XTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzID0gZnVuY3Rpb24gZGVmYXVsdEdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzKHByb3BzLCBfcmVmMikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYyLmluc3RhbmNlO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShlKSB7XG4gICAgICAgIGluc3RhbmNlLnRvZ2dsZUFsbFJvd3NTZWxlY3RlZChlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgfSxcbiAgICAgIGNoZWNrZWQ6IGluc3RhbmNlLmlzQWxsUm93c1NlbGVjdGVkLFxuICAgICAgdGl0bGU6ICdUb2dnbGUgQWxsIFJvd3MgU2VsZWN0ZWQnLFxuICAgICAgaW5kZXRlcm1pbmF0ZTogQm9vbGVhbighaW5zdGFuY2UuaXNBbGxSb3dzU2VsZWN0ZWQgJiYgT2JqZWN0LmtleXMoaW5zdGFuY2Uuc3RhdGUuc2VsZWN0ZWRSb3dJZHMpLmxlbmd0aClcbiAgICB9XTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRQcm9wcyA9IGZ1bmN0aW9uIGRlZmF1bHRHZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkUHJvcHMocHJvcHMsIF9yZWYzKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZjMuaW5zdGFuY2U7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGUpIHtcbiAgICAgICAgaW5zdGFuY2UudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZChlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgfSxcbiAgICAgIGNoZWNrZWQ6IGluc3RhbmNlLmlzQWxsUGFnZVJvd3NTZWxlY3RlZCxcbiAgICAgIHRpdGxlOiAnVG9nZ2xlIEFsbCBDdXJyZW50IFBhZ2UgUm93cyBTZWxlY3RlZCcsXG4gICAgICBpbmRldGVybWluYXRlOiBCb29sZWFuKCFpbnN0YW5jZS5pc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgJiYgaW5zdGFuY2UucGFnZS5zb21lKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICB2YXIgaWQgPSBfcmVmNC5pZDtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnN0YXRlLnNlbGVjdGVkUm93SWRzW2lkXTtcbiAgICAgIH0pKVxuICAgIH1dO1xuICB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuXG5cbiAgZnVuY3Rpb24gcmVkdWNlciQ4KHN0YXRlLCBhY3Rpb24sIHByZXZpb3VzU3RhdGUsIGluc3RhbmNlKSB7XG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmluaXQpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIHNlbGVjdGVkUm93SWRzOiB7fVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldFNlbGVjdGVkUm93cykge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBzZWxlY3RlZFJvd0lkczogaW5zdGFuY2UuaW5pdGlhbFN0YXRlLnNlbGVjdGVkUm93SWRzIHx8IHt9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMudG9nZ2xlQWxsUm93c1NlbGVjdGVkKSB7XG4gICAgICB2YXIgc2V0U2VsZWN0ZWQgPSBhY3Rpb24udmFsdWU7XG4gICAgICB2YXIgaXNBbGxSb3dzU2VsZWN0ZWQgPSBpbnN0YW5jZS5pc0FsbFJvd3NTZWxlY3RlZCxcbiAgICAgICAgICByb3dzQnlJZCA9IGluc3RhbmNlLnJvd3NCeUlkLFxuICAgICAgICAgIF9pbnN0YW5jZSRub25Hcm91cGVkUiA9IGluc3RhbmNlLm5vbkdyb3VwZWRSb3dzQnlJZCxcbiAgICAgICAgICBub25Hcm91cGVkUm93c0J5SWQgPSBfaW5zdGFuY2Ukbm9uR3JvdXBlZFIgPT09IHZvaWQgMCA/IHJvd3NCeUlkIDogX2luc3RhbmNlJG5vbkdyb3VwZWRSO1xuICAgICAgdmFyIHNlbGVjdEFsbCA9IHR5cGVvZiBzZXRTZWxlY3RlZCAhPT0gJ3VuZGVmaW5lZCcgPyBzZXRTZWxlY3RlZCA6ICFpc0FsbFJvd3NTZWxlY3RlZDsgLy8gT25seSByZW1vdmUvYWRkIHRoZSByb3dzIHRoYXQgYXJlIHZpc2libGUgb24gdGhlIHNjcmVlblxuICAgICAgLy8gIExlYXZlIGFsbCB0aGUgb3RoZXIgcm93cyB0aGF0IGFyZSBzZWxlY3RlZCBhbG9uZS5cblxuICAgICAgdmFyIHNlbGVjdGVkUm93SWRzID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc2VsZWN0ZWRSb3dJZHMpO1xuXG4gICAgICBpZiAoc2VsZWN0QWxsKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG5vbkdyb3VwZWRSb3dzQnlJZCkuZm9yRWFjaChmdW5jdGlvbiAocm93SWQpIHtcbiAgICAgICAgICBzZWxlY3RlZFJvd0lkc1tyb3dJZF0gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC5rZXlzKG5vbkdyb3VwZWRSb3dzQnlJZCkuZm9yRWFjaChmdW5jdGlvbiAocm93SWQpIHtcbiAgICAgICAgICBkZWxldGUgc2VsZWN0ZWRSb3dJZHNbcm93SWRdO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBzZWxlY3RlZFJvd0lkczogc2VsZWN0ZWRSb3dJZHNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy50b2dnbGVSb3dTZWxlY3RlZCkge1xuICAgICAgdmFyIGlkID0gYWN0aW9uLmlkLFxuICAgICAgICAgIF9zZXRTZWxlY3RlZCA9IGFjdGlvbi52YWx1ZTtcbiAgICAgIHZhciBfcm93c0J5SWQgPSBpbnN0YW5jZS5yb3dzQnlJZCxcbiAgICAgICAgICBfaW5zdGFuY2Ukc2VsZWN0U3ViUm8gPSBpbnN0YW5jZS5zZWxlY3RTdWJSb3dzLFxuICAgICAgICAgIHNlbGVjdFN1YlJvd3MgPSBfaW5zdGFuY2Ukc2VsZWN0U3ViUm8gPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2Ukc2VsZWN0U3ViUm8sXG4gICAgICAgICAgZ2V0U3ViUm93cyA9IGluc3RhbmNlLmdldFN1YlJvd3M7XG4gICAgICB2YXIgaXNTZWxlY3RlZCA9IHN0YXRlLnNlbGVjdGVkUm93SWRzW2lkXTtcbiAgICAgIHZhciBzaG91bGRFeGlzdCA9IHR5cGVvZiBfc2V0U2VsZWN0ZWQgIT09ICd1bmRlZmluZWQnID8gX3NldFNlbGVjdGVkIDogIWlzU2VsZWN0ZWQ7XG5cbiAgICAgIGlmIChpc1NlbGVjdGVkID09PSBzaG91bGRFeGlzdCkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdTZWxlY3RlZFJvd0lkcyA9IF9leHRlbmRzKHt9LCBzdGF0ZS5zZWxlY3RlZFJvd0lkcyk7XG5cbiAgICAgIHZhciBoYW5kbGVSb3dCeUlkID0gZnVuY3Rpb24gaGFuZGxlUm93QnlJZChpZCkge1xuICAgICAgICB2YXIgcm93ID0gX3Jvd3NCeUlkW2lkXTtcblxuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgaWYgKCFyb3cuaXNHcm91cGVkKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkRXhpc3QpIHtcbiAgICAgICAgICAgICAgbmV3U2VsZWN0ZWRSb3dJZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBuZXdTZWxlY3RlZFJvd0lkc1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlbGVjdFN1YlJvd3MgJiYgZ2V0U3ViUm93cyhyb3cpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3ViUm93cyhyb3cpLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUm93QnlJZChyb3cuaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBoYW5kbGVSb3dCeUlkKGlkKTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgc2VsZWN0ZWRSb3dJZHM6IG5ld1NlbGVjdGVkUm93SWRzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCkge1xuICAgICAgdmFyIF9zZXRTZWxlY3RlZDIgPSBhY3Rpb24udmFsdWU7XG5cbiAgICAgIHZhciBwYWdlID0gaW5zdGFuY2UucGFnZSxcbiAgICAgICAgICBfcm93c0J5SWQyID0gaW5zdGFuY2Uucm93c0J5SWQsXG4gICAgICAgICAgX2luc3RhbmNlJHNlbGVjdFN1YlJvMiA9IGluc3RhbmNlLnNlbGVjdFN1YlJvd3MsXG4gICAgICAgICAgX3NlbGVjdFN1YlJvd3MgPSBfaW5zdGFuY2Ukc2VsZWN0U3ViUm8yID09PSB2b2lkIDAgPyB0cnVlIDogX2luc3RhbmNlJHNlbGVjdFN1YlJvMixcbiAgICAgICAgICBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSBpbnN0YW5jZS5pc0FsbFBhZ2VSb3dzU2VsZWN0ZWQsXG4gICAgICAgICAgX2dldFN1YlJvd3MgPSBpbnN0YW5jZS5nZXRTdWJSb3dzO1xuXG4gICAgICB2YXIgX3NlbGVjdEFsbCA9IHR5cGVvZiBfc2V0U2VsZWN0ZWQyICE9PSAndW5kZWZpbmVkJyA/IF9zZXRTZWxlY3RlZDIgOiAhaXNBbGxQYWdlUm93c1NlbGVjdGVkO1xuXG4gICAgICB2YXIgX25ld1NlbGVjdGVkUm93SWRzID0gX2V4dGVuZHMoe30sIHN0YXRlLnNlbGVjdGVkUm93SWRzKTtcblxuICAgICAgdmFyIF9oYW5kbGVSb3dCeUlkID0gZnVuY3Rpb24gX2hhbmRsZVJvd0J5SWQoaWQpIHtcbiAgICAgICAgdmFyIHJvdyA9IF9yb3dzQnlJZDJbaWRdO1xuXG4gICAgICAgIGlmICghcm93LmlzR3JvdXBlZCkge1xuICAgICAgICAgIGlmIChfc2VsZWN0QWxsKSB7XG4gICAgICAgICAgICBfbmV3U2VsZWN0ZWRSb3dJZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIF9uZXdTZWxlY3RlZFJvd0lkc1tpZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9zZWxlY3RTdWJSb3dzICYmIF9nZXRTdWJSb3dzKHJvdykpIHtcbiAgICAgICAgICByZXR1cm4gX2dldFN1YlJvd3Mocm93KS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBfaGFuZGxlUm93QnlJZChyb3cuaWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBwYWdlLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByZXR1cm4gX2hhbmRsZVJvd0J5SWQocm93LmlkKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBzZWxlY3RlZFJvd0lkczogX25ld1NlbGVjdGVkUm93SWRzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiB1c2VJbnN0YW5jZSQ4KGluc3RhbmNlKSB7XG4gICAgdmFyIGRhdGEgPSBpbnN0YW5jZS5kYXRhLFxuICAgICAgICByb3dzID0gaW5zdGFuY2Uucm93cyxcbiAgICAgICAgZ2V0SG9va3MgPSBpbnN0YW5jZS5nZXRIb29rcyxcbiAgICAgICAgcGx1Z2lucyA9IGluc3RhbmNlLnBsdWdpbnMsXG4gICAgICAgIHJvd3NCeUlkID0gaW5zdGFuY2Uucm93c0J5SWQsXG4gICAgICAgIF9pbnN0YW5jZSRub25Hcm91cGVkUjIgPSBpbnN0YW5jZS5ub25Hcm91cGVkUm93c0J5SWQsXG4gICAgICAgIG5vbkdyb3VwZWRSb3dzQnlJZCA9IF9pbnN0YW5jZSRub25Hcm91cGVkUjIgPT09IHZvaWQgMCA/IHJvd3NCeUlkIDogX2luc3RhbmNlJG5vbkdyb3VwZWRSMixcbiAgICAgICAgX2luc3RhbmNlJGF1dG9SZXNldFNlID0gaW5zdGFuY2UuYXV0b1Jlc2V0U2VsZWN0ZWRSb3dzLFxuICAgICAgICBhdXRvUmVzZXRTZWxlY3RlZFJvd3MgPSBfaW5zdGFuY2UkYXV0b1Jlc2V0U2UgPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkYXV0b1Jlc2V0U2UsXG4gICAgICAgIHNlbGVjdGVkUm93SWRzID0gaW5zdGFuY2Uuc3RhdGUuc2VsZWN0ZWRSb3dJZHMsXG4gICAgICAgIF9pbnN0YW5jZSRzZWxlY3RTdWJSbzMgPSBpbnN0YW5jZS5zZWxlY3RTdWJSb3dzLFxuICAgICAgICBzZWxlY3RTdWJSb3dzID0gX2luc3RhbmNlJHNlbGVjdFN1YlJvMyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9pbnN0YW5jZSRzZWxlY3RTdWJSbzMsXG4gICAgICAgIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2gsXG4gICAgICAgIHBhZ2UgPSBpbnN0YW5jZS5wYWdlLFxuICAgICAgICBnZXRTdWJSb3dzID0gaW5zdGFuY2UuZ2V0U3ViUm93cztcbiAgICBlbnN1cmVQbHVnaW5PcmRlcihwbHVnaW5zLCBbJ3VzZUZpbHRlcnMnLCAndXNlR3JvdXBCeScsICd1c2VTb3J0QnknLCAndXNlRXhwYW5kZWQnLCAndXNlUGFnaW5hdGlvbiddLCAndXNlUm93U2VsZWN0Jyk7XG4gICAgdmFyIHNlbGVjdGVkRmxhdFJvd3MgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWxlY3RlZEZsYXRSb3dzID0gW107XG4gICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IHNlbGVjdFN1YlJvd3MgPyBnZXRSb3dJc1NlbGVjdGVkKHJvdywgc2VsZWN0ZWRSb3dJZHMsIGdldFN1YlJvd3MpIDogISFzZWxlY3RlZFJvd0lkc1tyb3cuaWRdO1xuICAgICAgICByb3cuaXNTZWxlY3RlZCA9ICEhaXNTZWxlY3RlZDtcbiAgICAgICAgcm93LmlzU29tZVNlbGVjdGVkID0gaXNTZWxlY3RlZCA9PT0gbnVsbDtcblxuICAgICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICAgIHNlbGVjdGVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzZWxlY3RlZEZsYXRSb3dzO1xuICAgIH0sIFtyb3dzLCBzZWxlY3RTdWJSb3dzLCBzZWxlY3RlZFJvd0lkcywgZ2V0U3ViUm93c10pO1xuICAgIHZhciBpc0FsbFJvd3NTZWxlY3RlZCA9IEJvb2xlYW4oT2JqZWN0LmtleXMobm9uR3JvdXBlZFJvd3NCeUlkKS5sZW5ndGggJiYgT2JqZWN0LmtleXMoc2VsZWN0ZWRSb3dJZHMpLmxlbmd0aCk7XG4gICAgdmFyIGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9IGlzQWxsUm93c1NlbGVjdGVkO1xuXG4gICAgaWYgKGlzQWxsUm93c1NlbGVjdGVkKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMobm9uR3JvdXBlZFJvd3NCeUlkKS5zb21lKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gIXNlbGVjdGVkUm93SWRzW2lkXTtcbiAgICAgIH0pKSB7XG4gICAgICAgIGlzQWxsUm93c1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc0FsbFJvd3NTZWxlY3RlZCkge1xuICAgICAgaWYgKHBhZ2UgJiYgcGFnZS5sZW5ndGggJiYgcGFnZS5zb21lKGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICB2YXIgaWQgPSBfcmVmNS5pZDtcbiAgICAgICAgcmV0dXJuICFzZWxlY3RlZFJvd0lkc1tpZF07XG4gICAgICB9KSkge1xuICAgICAgICBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ2V0QXV0b1Jlc2V0U2VsZWN0ZWRSb3dzID0gdXNlR2V0TGF0ZXN0KGF1dG9SZXNldFNlbGVjdGVkUm93cyk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0U2VsZWN0ZWRSb3dzKCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRTZWxlY3RlZFJvd3NcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2Rpc3BhdGNoLCBkYXRhXSk7XG4gICAgdmFyIHRvZ2dsZUFsbFJvd3NTZWxlY3RlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogYWN0aW9ucy50b2dnbGVBbGxSb3dzU2VsZWN0ZWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIHRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgdG9nZ2xlUm93U2VsZWN0ZWQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoaWQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnRvZ2dsZVJvd1NlbGVjdGVkLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfSwgW2Rpc3BhdGNoXSk7XG4gICAgdmFyIGdldEluc3RhbmNlID0gdXNlR2V0TGF0ZXN0KGluc3RhbmNlKTtcbiAgICB2YXIgZ2V0VG9nZ2xlQWxsUm93c1NlbGVjdGVkUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzLCB7XG4gICAgICBpbnN0YW5jZTogZ2V0SW5zdGFuY2UoKVxuICAgIH0pO1xuICAgIHZhciBnZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkUHJvcHMgPSBtYWtlUHJvcEdldHRlcihnZXRIb29rcygpLmdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRQcm9wcywge1xuICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKClcbiAgICB9KTtcbiAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgICBzZWxlY3RlZEZsYXRSb3dzOiBzZWxlY3RlZEZsYXRSb3dzLFxuICAgICAgaXNBbGxSb3dzU2VsZWN0ZWQ6IGlzQWxsUm93c1NlbGVjdGVkLFxuICAgICAgaXNBbGxQYWdlUm93c1NlbGVjdGVkOiBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQsXG4gICAgICB0b2dnbGVSb3dTZWxlY3RlZDogdG9nZ2xlUm93U2VsZWN0ZWQsXG4gICAgICB0b2dnbGVBbGxSb3dzU2VsZWN0ZWQ6IHRvZ2dsZUFsbFJvd3NTZWxlY3RlZCxcbiAgICAgIGdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZFByb3BzOiBnZXRUb2dnbGVBbGxSb3dzU2VsZWN0ZWRQcm9wcyxcbiAgICAgIGdldFRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWRQcm9wczogZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZFByb3BzLFxuICAgICAgdG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZDogdG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVJvdyQzKHJvdywgX3JlZjYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmNi5pbnN0YW5jZTtcblxuICAgIHJvdy50b2dnbGVSb3dTZWxlY3RlZCA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS50b2dnbGVSb3dTZWxlY3RlZChyb3cuaWQsIHNldCk7XG4gICAgfTtcblxuICAgIHJvdy5nZXRUb2dnbGVSb3dTZWxlY3RlZFByb3BzID0gbWFrZVByb3BHZXR0ZXIoaW5zdGFuY2UuZ2V0SG9va3MoKS5nZXRUb2dnbGVSb3dTZWxlY3RlZFByb3BzLCB7XG4gICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICByb3c6IHJvd1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Um93SXNTZWxlY3RlZChyb3csIHNlbGVjdGVkUm93SWRzLCBnZXRTdWJSb3dzKSB7XG4gICAgaWYgKHNlbGVjdGVkUm93SWRzW3Jvdy5pZF0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdWJSb3dzID0gZ2V0U3ViUm93cyhyb3cpO1xuXG4gICAgaWYgKHN1YlJvd3MgJiYgc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgIHZhciBhbGxDaGlsZHJlblNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIHZhciBzb21lU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHN1YlJvd3MuZm9yRWFjaChmdW5jdGlvbiAoc3ViUm93KSB7XG4gICAgICAgIC8vIEJhaWwgb3V0IGVhcmx5IGlmIHdlIGtub3cgYm90aCBvZiB0aGVzZVxuICAgICAgICBpZiAoc29tZVNlbGVjdGVkICYmICFhbGxDaGlsZHJlblNlbGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdldFJvd0lzU2VsZWN0ZWQoc3ViUm93LCBzZWxlY3RlZFJvd0lkcywgZ2V0U3ViUm93cykpIHtcbiAgICAgICAgICBzb21lU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWxsQ2hpbGRyZW5TZWxlY3RlZCA/IHRydWUgOiBzb21lU2VsZWN0ZWQgPyBudWxsIDogZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRJbml0aWFsUm93U3RhdGVBY2Nlc3NvciA9IGZ1bmN0aW9uIGRlZmF1bHRJbml0aWFsUm93U3RhdGVBY2Nlc3Nvcihyb3cpIHtcbiAgICByZXR1cm4ge307XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRJbml0aWFsQ2VsbFN0YXRlQWNjZXNzb3IgPSBmdW5jdGlvbiBkZWZhdWx0SW5pdGlhbENlbGxTdGF0ZUFjY2Vzc29yKGNlbGwpIHtcbiAgICByZXR1cm4ge307XG4gIH07IC8vIEFjdGlvbnNcblxuXG4gIGFjdGlvbnMuc2V0Um93U3RhdGUgPSAnc2V0Um93U3RhdGUnO1xuICBhY3Rpb25zLnNldENlbGxTdGF0ZSA9ICdzZXRDZWxsU3RhdGUnO1xuICBhY3Rpb25zLnJlc2V0Um93U3RhdGUgPSAncmVzZXRSb3dTdGF0ZSc7XG4gIHZhciB1c2VSb3dTdGF0ZSA9IGZ1bmN0aW9uIHVzZVJvd1N0YXRlKGhvb2tzKSB7XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkOSk7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSQ5KTtcbiAgICBob29rcy5wcmVwYXJlUm93LnB1c2gocHJlcGFyZVJvdyQ0KTtcbiAgfTtcbiAgdXNlUm93U3RhdGUucGx1Z2luTmFtZSA9ICd1c2VSb3dTdGF0ZSc7XG5cbiAgZnVuY3Rpb24gcmVkdWNlciQ5KHN0YXRlLCBhY3Rpb24sIHByZXZpb3VzU3RhdGUsIGluc3RhbmNlKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRpbml0aWFsUm93UyA9IGluc3RhbmNlLmluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yLFxuICAgICAgICBpbml0aWFsUm93U3RhdGVBY2Nlc3NvciA9IF9pbnN0YW5jZSRpbml0aWFsUm93UyA9PT0gdm9pZCAwID8gZGVmYXVsdEluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yIDogX2luc3RhbmNlJGluaXRpYWxSb3dTLFxuICAgICAgICBfaW5zdGFuY2UkaW5pdGlhbENlbGwgPSBpbnN0YW5jZS5pbml0aWFsQ2VsbFN0YXRlQWNjZXNzb3IsXG4gICAgICAgIGluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvciA9IF9pbnN0YW5jZSRpbml0aWFsQ2VsbCA9PT0gdm9pZCAwID8gZGVmYXVsdEluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvciA6IF9pbnN0YW5jZSRpbml0aWFsQ2VsbCxcbiAgICAgICAgcm93c0J5SWQgPSBpbnN0YW5jZS5yb3dzQnlJZDtcblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5pbml0KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICByb3dTdGF0ZToge31cbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRSb3dTdGF0ZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICByb3dTdGF0ZTogaW5zdGFuY2UuaW5pdGlhbFN0YXRlLnJvd1N0YXRlIHx8IHt9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuc2V0Um93U3RhdGUpIHtcbiAgICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICAgIHZhciByb3dJZCA9IGFjdGlvbi5yb3dJZCxcbiAgICAgICAgICB2YWx1ZSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgIHZhciBvbGRSb3dTdGF0ZSA9IHR5cGVvZiBzdGF0ZS5yb3dTdGF0ZVtyb3dJZF0gIT09ICd1bmRlZmluZWQnID8gc3RhdGUucm93U3RhdGVbcm93SWRdIDogaW5pdGlhbFJvd1N0YXRlQWNjZXNzb3Iocm93c0J5SWRbcm93SWRdKTtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgcm93U3RhdGU6IF9leHRlbmRzKHt9LCBzdGF0ZS5yb3dTdGF0ZSwgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbcm93SWRdID0gZnVuY3Rpb25hbFVwZGF0ZSh2YWx1ZSwgb2xkUm93U3RhdGUpLCBfZXh0ZW5kczIpKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnNldENlbGxTdGF0ZSkge1xuICAgICAgdmFyIF9vbGRSb3dTdGF0ZSRjZWxsU3RhdCwgX3Jvd3NCeUlkJF9yb3dJZCwgX3Jvd3NCeUlkJF9yb3dJZCRjZWxsLCBfZXh0ZW5kczMsIF9leHRlbmRzNDtcblxuICAgICAgdmFyIF9yb3dJZCA9IGFjdGlvbi5yb3dJZCxcbiAgICAgICAgICBjb2x1bW5JZCA9IGFjdGlvbi5jb2x1bW5JZCxcbiAgICAgICAgICBfdmFsdWUgPSBhY3Rpb24udmFsdWU7XG5cbiAgICAgIHZhciBfb2xkUm93U3RhdGUgPSB0eXBlb2Ygc3RhdGUucm93U3RhdGVbX3Jvd0lkXSAhPT0gJ3VuZGVmaW5lZCcgPyBzdGF0ZS5yb3dTdGF0ZVtfcm93SWRdIDogaW5pdGlhbFJvd1N0YXRlQWNjZXNzb3Iocm93c0J5SWRbX3Jvd0lkXSk7XG5cbiAgICAgIHZhciBvbGRDZWxsU3RhdGUgPSB0eXBlb2YgKF9vbGRSb3dTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogKF9vbGRSb3dTdGF0ZSRjZWxsU3RhdCA9IF9vbGRSb3dTdGF0ZS5jZWxsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfb2xkUm93U3RhdGUkY2VsbFN0YXRbY29sdW1uSWRdKSAhPT0gJ3VuZGVmaW5lZCcgPyBfb2xkUm93U3RhdGUuY2VsbFN0YXRlW2NvbHVtbklkXSA6IGluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvcigoX3Jvd3NCeUlkJF9yb3dJZCA9IHJvd3NCeUlkW19yb3dJZF0pID09IG51bGwgPyB2b2lkIDAgOiAoX3Jvd3NCeUlkJF9yb3dJZCRjZWxsID0gX3Jvd3NCeUlkJF9yb3dJZC5jZWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3dzQnlJZCRfcm93SWQkY2VsbC5maW5kKGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgIHJldHVybiBjZWxsLmNvbHVtbi5pZCA9PT0gY29sdW1uSWQ7XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIHJvd1N0YXRlOiBfZXh0ZW5kcyh7fSwgc3RhdGUucm93U3RhdGUsIChfZXh0ZW5kczQgPSB7fSwgX2V4dGVuZHM0W19yb3dJZF0gPSBfZXh0ZW5kcyh7fSwgX29sZFJvd1N0YXRlLCB7XG4gICAgICAgICAgY2VsbFN0YXRlOiBfZXh0ZW5kcyh7fSwgX29sZFJvd1N0YXRlLmNlbGxTdGF0ZSB8fCB7fSwgKF9leHRlbmRzMyA9IHt9LCBfZXh0ZW5kczNbY29sdW1uSWRdID0gZnVuY3Rpb25hbFVwZGF0ZShfdmFsdWUsIG9sZENlbGxTdGF0ZSksIF9leHRlbmRzMykpXG4gICAgICAgIH0pLCBfZXh0ZW5kczQpKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkOShpbnN0YW5jZSkge1xuICAgIHZhciBfaW5zdGFuY2UkYXV0b1Jlc2V0Um8gPSBpbnN0YW5jZS5hdXRvUmVzZXRSb3dTdGF0ZSxcbiAgICAgICAgYXV0b1Jlc2V0Um93U3RhdGUgPSBfaW5zdGFuY2UkYXV0b1Jlc2V0Um8gPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkYXV0b1Jlc2V0Um8sXG4gICAgICAgIGRhdGEgPSBpbnN0YW5jZS5kYXRhLFxuICAgICAgICBkaXNwYXRjaCA9IGluc3RhbmNlLmRpc3BhdGNoO1xuICAgIHZhciBzZXRSb3dTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChyb3dJZCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0Um93U3RhdGUsXG4gICAgICAgIHJvd0lkOiByb3dJZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgc2V0Q2VsbFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHJvd0lkLCBjb2x1bW5JZCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMuc2V0Q2VsbFN0YXRlLFxuICAgICAgICByb3dJZDogcm93SWQsXG4gICAgICAgIGNvbHVtbklkOiBjb2x1bW5JZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgZ2V0QXV0b1Jlc2V0Um93U3RhdGUgPSB1c2VHZXRMYXRlc3QoYXV0b1Jlc2V0Um93U3RhdGUpO1xuICAgIHVzZU1vdW50ZWRMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGdldEF1dG9SZXNldFJvd1N0YXRlKCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRSb3dTdGF0ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBbZGF0YV0pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIHNldFJvd1N0YXRlOiBzZXRSb3dTdGF0ZSxcbiAgICAgIHNldENlbGxTdGF0ZTogc2V0Q2VsbFN0YXRlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlUm93JDQocm93LCBfcmVmKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICB2YXIgX2luc3RhbmNlJGluaXRpYWxSb3dTMiA9IGluc3RhbmNlLmluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yLFxuICAgICAgICBpbml0aWFsUm93U3RhdGVBY2Nlc3NvciA9IF9pbnN0YW5jZSRpbml0aWFsUm93UzIgPT09IHZvaWQgMCA/IGRlZmF1bHRJbml0aWFsUm93U3RhdGVBY2Nlc3NvciA6IF9pbnN0YW5jZSRpbml0aWFsUm93UzIsXG4gICAgICAgIF9pbnN0YW5jZSRpbml0aWFsQ2VsbDIgPSBpbnN0YW5jZS5pbml0aWFsQ2VsbFN0YXRlQWNjZXNzb3IsXG4gICAgICAgIGluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvciA9IF9pbnN0YW5jZSRpbml0aWFsQ2VsbDIgPT09IHZvaWQgMCA/IGRlZmF1bHRJbml0aWFsQ2VsbFN0YXRlQWNjZXNzb3IgOiBfaW5zdGFuY2UkaW5pdGlhbENlbGwyLFxuICAgICAgICByb3dTdGF0ZSA9IGluc3RhbmNlLnN0YXRlLnJvd1N0YXRlO1xuXG4gICAgaWYgKHJvdykge1xuICAgICAgcm93LnN0YXRlID0gdHlwZW9mIHJvd1N0YXRlW3Jvdy5pZF0gIT09ICd1bmRlZmluZWQnID8gcm93U3RhdGVbcm93LmlkXSA6IGluaXRpYWxSb3dTdGF0ZUFjY2Vzc29yKHJvdyk7XG5cbiAgICAgIHJvdy5zZXRTdGF0ZSA9IGZ1bmN0aW9uICh1cGRhdGVyKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5zZXRSb3dTdGF0ZShyb3cuaWQsIHVwZGF0ZXIpO1xuICAgICAgfTtcblxuICAgICAgcm93LmNlbGxzLmZvckVhY2goZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgaWYgKCFyb3cuc3RhdGUuY2VsbFN0YXRlKSB7XG4gICAgICAgICAgcm93LnN0YXRlLmNlbGxTdGF0ZSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgY2VsbC5zdGF0ZSA9IHR5cGVvZiByb3cuc3RhdGUuY2VsbFN0YXRlW2NlbGwuY29sdW1uLmlkXSAhPT0gJ3VuZGVmaW5lZCcgPyByb3cuc3RhdGUuY2VsbFN0YXRlW2NlbGwuY29sdW1uLmlkXSA6IGluaXRpYWxDZWxsU3RhdGVBY2Nlc3NvcihjZWxsKTtcblxuICAgICAgICBjZWxsLnNldFN0YXRlID0gZnVuY3Rpb24gKHVwZGF0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc2V0Q2VsbFN0YXRlKHJvdy5pZCwgY2VsbC5jb2x1bW4uaWQsIHVwZGF0ZXIpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgYWN0aW9ucy5yZXNldENvbHVtbk9yZGVyID0gJ3Jlc2V0Q29sdW1uT3JkZXInO1xuICBhY3Rpb25zLnNldENvbHVtbk9yZGVyID0gJ3NldENvbHVtbk9yZGVyJztcbiAgdmFyIHVzZUNvbHVtbk9yZGVyID0gZnVuY3Rpb24gdXNlQ29sdW1uT3JkZXIoaG9va3MpIHtcbiAgICBob29rcy5zdGF0ZVJlZHVjZXJzLnB1c2gocmVkdWNlciRhKTtcbiAgICBob29rcy52aXNpYmxlQ29sdW1uc0RlcHMucHVzaChmdW5jdGlvbiAoZGVwcywgX3JlZikge1xuICAgICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoZGVwcywgW2luc3RhbmNlLnN0YXRlLmNvbHVtbk9yZGVyXSk7XG4gICAgfSk7XG4gICAgaG9va3MudmlzaWJsZUNvbHVtbnMucHVzaCh2aXNpYmxlQ29sdW1ucyQyKTtcbiAgICBob29rcy51c2VJbnN0YW5jZS5wdXNoKHVzZUluc3RhbmNlJGEpO1xuICB9O1xuICB1c2VDb2x1bW5PcmRlci5wbHVnaW5OYW1lID0gJ3VzZUNvbHVtbk9yZGVyJztcblxuICBmdW5jdGlvbiByZWR1Y2VyJGEoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgY29sdW1uT3JkZXI6IFtdXG4gICAgICB9LCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnJlc2V0Q29sdW1uT3JkZXIpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgY29sdW1uT3JkZXI6IGluc3RhbmNlLmluaXRpYWxTdGF0ZS5jb2x1bW5PcmRlciB8fCBbXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLnNldENvbHVtbk9yZGVyKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgIGNvbHVtbk9yZGVyOiBmdW5jdGlvbmFsVXBkYXRlKGFjdGlvbi5jb2x1bW5PcmRlciwgc3RhdGUuY29sdW1uT3JkZXIpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2aXNpYmxlQ29sdW1ucyQyKGNvbHVtbnMsIF9yZWYyKSB7XG4gICAgdmFyIGNvbHVtbk9yZGVyID0gX3JlZjIuaW5zdGFuY2Uuc3RhdGUuY29sdW1uT3JkZXI7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBvcmRlciwgcmV0dXJuIHRoZSBub3JtYWwgY29sdW1uc1xuICAgIGlmICghY29sdW1uT3JkZXIgfHwgIWNvbHVtbk9yZGVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNvbHVtbnM7XG4gICAgfVxuXG4gICAgdmFyIGNvbHVtbk9yZGVyQ29weSA9IFtdLmNvbmNhdChjb2x1bW5PcmRlcik7IC8vIElmIHRoZXJlIGlzIGFuIG9yZGVyLCBtYWtlIGEgY29weSBvZiB0aGUgY29sdW1uc1xuXG4gICAgdmFyIGNvbHVtbnNDb3B5ID0gW10uY29uY2F0KGNvbHVtbnMpOyAvLyBBbmQgbWFrZSBhIG5ldyBvcmRlcmVkIGFycmF5IG9mIHRoZSBjb2x1bW5zXG5cbiAgICB2YXIgY29sdW1uc0luT3JkZXIgPSBbXTsgLy8gTG9vcCBvdmVyIHRoZSBjb2x1bW5zIGFuZCBwbGFjZSB0aGVtIGluIG9yZGVyIGludG8gdGhlIG5ldyBhcnJheVxuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgdGFyZ2V0Q29sdW1uSWQgPSBjb2x1bW5PcmRlckNvcHkuc2hpZnQoKTtcbiAgICAgIHZhciBmb3VuZEluZGV4ID0gY29sdW1uc0NvcHkuZmluZEluZGV4KGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkID09PSB0YXJnZXRDb2x1bW5JZDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZm91bmRJbmRleCA+IC0xKSB7XG4gICAgICAgIGNvbHVtbnNJbk9yZGVyLnB1c2goY29sdW1uc0NvcHkuc3BsaWNlKGZvdW5kSW5kZXgsIDEpWzBdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2hpbGUgKGNvbHVtbnNDb3B5Lmxlbmd0aCAmJiBjb2x1bW5PcmRlckNvcHkubGVuZ3RoKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH0gLy8gSWYgdGhlcmUgYXJlIGFueSBjb2x1bW5zIGxlZnQsIGFkZCB0aGVtIHRvIHRoZSBlbmRcblxuXG4gICAgcmV0dXJuIFtdLmNvbmNhdChjb2x1bW5zSW5PcmRlciwgY29sdW1uc0NvcHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkYShpbnN0YW5jZSkge1xuICAgIHZhciBkaXNwYXRjaCA9IGluc3RhbmNlLmRpc3BhdGNoO1xuICAgIGluc3RhbmNlLnNldENvbHVtbk9yZGVyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbHVtbk9yZGVyKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLnNldENvbHVtbk9yZGVyLFxuICAgICAgICBjb2x1bW5PcmRlcjogY29sdW1uT3JkZXJcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICB9XG5cbiAgZGVmYXVsdENvbHVtbi5jYW5SZXNpemUgPSB0cnVlOyAvLyBBY3Rpb25zXG5cbiAgYWN0aW9ucy5jb2x1bW5TdGFydFJlc2l6aW5nID0gJ2NvbHVtblN0YXJ0UmVzaXppbmcnO1xuICBhY3Rpb25zLmNvbHVtblJlc2l6aW5nID0gJ2NvbHVtblJlc2l6aW5nJztcbiAgYWN0aW9ucy5jb2x1bW5Eb25lUmVzaXppbmcgPSAnY29sdW1uRG9uZVJlc2l6aW5nJztcbiAgYWN0aW9ucy5yZXNldFJlc2l6ZSA9ICdyZXNldFJlc2l6ZSc7XG4gIHZhciB1c2VSZXNpemVDb2x1bW5zID0gZnVuY3Rpb24gdXNlUmVzaXplQ29sdW1ucyhob29rcykge1xuICAgIGhvb2tzLmdldFJlc2l6ZXJQcm9wcyA9IFtkZWZhdWx0R2V0UmVzaXplclByb3BzXTtcbiAgICBob29rcy5nZXRIZWFkZXJQcm9wcy5wdXNoKHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICB9XG4gICAgfSk7XG4gICAgaG9va3Muc3RhdGVSZWR1Y2Vycy5wdXNoKHJlZHVjZXIkYik7XG4gICAgaG9va3MudXNlSW5zdGFuY2UucHVzaCh1c2VJbnN0YW5jZSRiKTtcbiAgICBob29rcy51c2VJbnN0YW5jZUJlZm9yZURpbWVuc2lvbnMucHVzaCh1c2VJbnN0YW5jZUJlZm9yZURpbWVuc2lvbnMkMSk7XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRHZXRSZXNpemVyUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0R2V0UmVzaXplclByb3BzKHByb3BzLCBfcmVmKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgICAgaGVhZGVyID0gX3JlZi5oZWFkZXI7XG4gICAgdmFyIGRpc3BhdGNoID0gaW5zdGFuY2UuZGlzcGF0Y2g7XG5cbiAgICB2YXIgb25SZXNpemVTdGFydCA9IGZ1bmN0aW9uIG9uUmVzaXplU3RhcnQoZSwgaGVhZGVyKSB7XG4gICAgICB2YXIgaXNUb3VjaEV2ZW50ID0gZmFsc2U7XG5cbiAgICAgIGlmIChlLnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICAvLyBsZXRzIG5vdCByZXNwb25kIHRvIG11bHRpcGxlIHRvdWNoZXMgKGUuZy4gMiBvciAzIGZpbmdlcnMpXG4gICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpc1RvdWNoRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGVhZGVyc1RvUmVzaXplID0gZ2V0TGVhZkhlYWRlcnMoaGVhZGVyKTtcbiAgICAgIHZhciBoZWFkZXJJZFdpZHRocyA9IGhlYWRlcnNUb1Jlc2l6ZS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIFtkLmlkLCBkLnRvdGFsV2lkdGhdO1xuICAgICAgfSk7XG4gICAgICB2YXIgY2xpZW50WCA9IGlzVG91Y2hFdmVudCA/IE1hdGgucm91bmQoZS50b3VjaGVzWzBdLmNsaWVudFgpIDogZS5jbGllbnRYO1xuICAgICAgdmFyIHJhZjtcbiAgICAgIHZhciBtb3N0UmVjZW50Q2xpZW50WDtcblxuICAgICAgdmFyIGRpc3BhdGNoRW5kID0gZnVuY3Rpb24gZGlzcGF0Y2hFbmQoKSB7XG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuICAgICAgICByYWYgPSBudWxsO1xuICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogYWN0aW9ucy5jb2x1bW5Eb25lUmVzaXppbmdcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZGlzcGF0Y2hNb3ZlID0gZnVuY3Rpb24gZGlzcGF0Y2hNb3ZlKCkge1xuICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcbiAgICAgICAgcmFmID0gbnVsbDtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMuY29sdW1uUmVzaXppbmcsXG4gICAgICAgICAgY2xpZW50WDogbW9zdFJlY2VudENsaWVudFhcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgc2NoZWR1bGVEaXNwYXRjaE1vdmVPbk5leHRBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIHNjaGVkdWxlRGlzcGF0Y2hNb3ZlT25OZXh0QW5pbWF0aW9uRnJhbWUoY2xpZW50WFBvcykge1xuICAgICAgICBtb3N0UmVjZW50Q2xpZW50WCA9IGNsaWVudFhQb3M7XG5cbiAgICAgICAgaWYgKCFyYWYpIHtcbiAgICAgICAgICByYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRpc3BhdGNoTW92ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBoYW5kbGVyc0FuZEV2ZW50cyA9IHtcbiAgICAgICAgbW91c2U6IHtcbiAgICAgICAgICBtb3ZlRXZlbnQ6ICdtb3VzZW1vdmUnLFxuICAgICAgICAgIG1vdmVIYW5kbGVyOiBmdW5jdGlvbiBtb3ZlSGFuZGxlcihlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVEaXNwYXRjaE1vdmVPbk5leHRBbmltYXRpb25GcmFtZShlLmNsaWVudFgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBFdmVudDogJ21vdXNldXAnLFxuICAgICAgICAgIHVwSGFuZGxlcjogZnVuY3Rpb24gdXBIYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZXJzQW5kRXZlbnRzLm1vdXNlLm1vdmVIYW5kbGVyKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVyc0FuZEV2ZW50cy5tb3VzZS51cEhhbmRsZXIpO1xuICAgICAgICAgICAgZGlzcGF0Y2hFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoOiB7XG4gICAgICAgICAgbW92ZUV2ZW50OiAndG91Y2htb3ZlJyxcbiAgICAgICAgICBtb3ZlSGFuZGxlcjogZnVuY3Rpb24gbW92ZUhhbmRsZXIoZSkge1xuICAgICAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjaGVkdWxlRGlzcGF0Y2hNb3ZlT25OZXh0QW5pbWF0aW9uRnJhbWUoZS50b3VjaGVzWzBdLmNsaWVudFgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBFdmVudDogJ3RvdWNoZW5kJyxcbiAgICAgICAgICB1cEhhbmRsZXI6IGZ1bmN0aW9uIHVwSGFuZGxlcihlKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGhhbmRsZXJzQW5kRXZlbnRzLnRvdWNoLm1vdmVFdmVudCwgaGFuZGxlcnNBbmRFdmVudHMudG91Y2gubW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihoYW5kbGVyc0FuZEV2ZW50cy50b3VjaC51cEV2ZW50LCBoYW5kbGVyc0FuZEV2ZW50cy50b3VjaC5tb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICBkaXNwYXRjaEVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBldmVudHMgPSBpc1RvdWNoRXZlbnQgPyBoYW5kbGVyc0FuZEV2ZW50cy50b3VjaCA6IGhhbmRsZXJzQW5kRXZlbnRzLm1vdXNlO1xuICAgICAgdmFyIHBhc3NpdmVJZlN1cHBvcnRlZCA9IHBhc3NpdmVFdmVudFN1cHBvcnRlZCgpID8ge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSA6IGZhbHNlO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudHMubW92ZUV2ZW50LCBldmVudHMubW92ZUhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50cy51cEV2ZW50LCBldmVudHMudXBIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBhY3Rpb25zLmNvbHVtblN0YXJ0UmVzaXppbmcsXG4gICAgICAgIGNvbHVtbklkOiBoZWFkZXIuaWQsXG4gICAgICAgIGNvbHVtbldpZHRoOiBoZWFkZXIudG90YWxXaWR0aCxcbiAgICAgICAgaGVhZGVySWRXaWR0aHM6IGhlYWRlcklkV2lkdGhzLFxuICAgICAgICBjbGllbnRYOiBjbGllbnRYXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgb25Nb3VzZURvd246IGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICAgICAgcmV0dXJuIGUucGVyc2lzdCgpIHx8IG9uUmVzaXplU3RhcnQoZSwgaGVhZGVyKTtcbiAgICAgIH0sXG4gICAgICBvblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgICAgIHJldHVybiBlLnBlcnNpc3QoKSB8fCBvblJlc2l6ZVN0YXJ0KGUsIGhlYWRlcik7XG4gICAgICB9LFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY3Vyc29yOiAnY29sLXJlc2l6ZSdcbiAgICAgIH0sXG4gICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgcm9sZTogJ3NlcGFyYXRvcidcbiAgICB9XTtcbiAgfTtcblxuICB1c2VSZXNpemVDb2x1bW5zLnBsdWdpbk5hbWUgPSAndXNlUmVzaXplQ29sdW1ucyc7XG5cbiAgZnVuY3Rpb24gcmVkdWNlciRiKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgY29sdW1uUmVzaXppbmc6IHtcbiAgICAgICAgICBjb2x1bW5XaWR0aHM6IHt9XG4gICAgICAgIH1cbiAgICAgIH0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMucmVzZXRSZXNpemUpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgc3RhdGUsIHtcbiAgICAgICAgY29sdW1uUmVzaXppbmc6IHtcbiAgICAgICAgICBjb2x1bW5XaWR0aHM6IHt9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5jb2x1bW5TdGFydFJlc2l6aW5nKSB7XG4gICAgICB2YXIgY2xpZW50WCA9IGFjdGlvbi5jbGllbnRYLFxuICAgICAgICAgIGNvbHVtbklkID0gYWN0aW9uLmNvbHVtbklkLFxuICAgICAgICAgIGNvbHVtbldpZHRoID0gYWN0aW9uLmNvbHVtbldpZHRoLFxuICAgICAgICAgIGhlYWRlcklkV2lkdGhzID0gYWN0aW9uLmhlYWRlcklkV2lkdGhzO1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBjb2x1bW5SZXNpemluZzogX2V4dGVuZHMoe30sIHN0YXRlLmNvbHVtblJlc2l6aW5nLCB7XG4gICAgICAgICAgc3RhcnRYOiBjbGllbnRYLFxuICAgICAgICAgIGhlYWRlcklkV2lkdGhzOiBoZWFkZXJJZFdpZHRocyxcbiAgICAgICAgICBjb2x1bW5XaWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogY29sdW1uSWRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5jb2x1bW5SZXNpemluZykge1xuICAgICAgdmFyIF9jbGllbnRYID0gYWN0aW9uLmNsaWVudFg7XG5cbiAgICAgIHZhciBfc3RhdGUkY29sdW1uUmVzaXppbmcgPSBzdGF0ZS5jb2x1bW5SZXNpemluZyxcbiAgICAgICAgICBzdGFydFggPSBfc3RhdGUkY29sdW1uUmVzaXppbmcuc3RhcnRYLFxuICAgICAgICAgIF9jb2x1bW5XaWR0aCA9IF9zdGF0ZSRjb2x1bW5SZXNpemluZy5jb2x1bW5XaWR0aCxcbiAgICAgICAgICBfc3RhdGUkY29sdW1uUmVzaXppbmcyID0gX3N0YXRlJGNvbHVtblJlc2l6aW5nLmhlYWRlcklkV2lkdGhzLFxuICAgICAgICAgIF9oZWFkZXJJZFdpZHRocyA9IF9zdGF0ZSRjb2x1bW5SZXNpemluZzIgPT09IHZvaWQgMCA/IFtdIDogX3N0YXRlJGNvbHVtblJlc2l6aW5nMjtcblxuICAgICAgdmFyIGRlbHRhWCA9IF9jbGllbnRYIC0gc3RhcnRYO1xuICAgICAgdmFyIHBlcmNlbnRhZ2VEZWx0YVggPSBkZWx0YVggLyBfY29sdW1uV2lkdGg7XG4gICAgICB2YXIgbmV3Q29sdW1uV2lkdGhzID0ge307XG5cbiAgICAgIF9oZWFkZXJJZFdpZHRocy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgaGVhZGVySWQgPSBfcmVmMlswXSxcbiAgICAgICAgICAgIGhlYWRlcldpZHRoID0gX3JlZjJbMV07XG4gICAgICAgIG5ld0NvbHVtbldpZHRoc1toZWFkZXJJZF0gPSBNYXRoLm1heChoZWFkZXJXaWR0aCArIGhlYWRlcldpZHRoICogcGVyY2VudGFnZURlbHRhWCwgMCk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBjb2x1bW5SZXNpemluZzogX2V4dGVuZHMoe30sIHN0YXRlLmNvbHVtblJlc2l6aW5nLCB7XG4gICAgICAgICAgY29sdW1uV2lkdGhzOiBfZXh0ZW5kcyh7fSwgc3RhdGUuY29sdW1uUmVzaXppbmcuY29sdW1uV2lkdGhzLCB7fSwgbmV3Q29sdW1uV2lkdGhzKVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmNvbHVtbkRvbmVSZXNpemluZykge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBjb2x1bW5SZXNpemluZzogX2V4dGVuZHMoe30sIHN0YXRlLmNvbHVtblJlc2l6aW5nLCB7XG4gICAgICAgICAgc3RhcnRYOiBudWxsLFxuICAgICAgICAgIGlzUmVzaXppbmdDb2x1bW46IG51bGxcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1c2VJbnN0YW5jZUJlZm9yZURpbWVuc2lvbnMkMSA9IGZ1bmN0aW9uIHVzZUluc3RhbmNlQmVmb3JlRGltZW5zaW9ucyhpbnN0YW5jZSkge1xuICAgIHZhciBmbGF0SGVhZGVycyA9IGluc3RhbmNlLmZsYXRIZWFkZXJzLFxuICAgICAgICBkaXNhYmxlUmVzaXppbmcgPSBpbnN0YW5jZS5kaXNhYmxlUmVzaXppbmcsXG4gICAgICAgIGdldEhvb2tzID0gaW5zdGFuY2UuZ2V0SG9va3MsXG4gICAgICAgIGNvbHVtblJlc2l6aW5nID0gaW5zdGFuY2Uuc3RhdGUuY29sdW1uUmVzaXppbmc7XG4gICAgdmFyIGdldEluc3RhbmNlID0gdXNlR2V0TGF0ZXN0KGluc3RhbmNlKTtcbiAgICBmbGF0SGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgIHZhciBjYW5SZXNpemUgPSBnZXRGaXJzdERlZmluZWQoaGVhZGVyLmRpc2FibGVSZXNpemluZyA9PT0gdHJ1ZSA/IGZhbHNlIDogdW5kZWZpbmVkLCBkaXNhYmxlUmVzaXppbmcgPT09IHRydWUgPyBmYWxzZSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICBoZWFkZXIuY2FuUmVzaXplID0gY2FuUmVzaXplO1xuICAgICAgaGVhZGVyLndpZHRoID0gY29sdW1uUmVzaXppbmcuY29sdW1uV2lkdGhzW2hlYWRlci5pZF0gfHwgaGVhZGVyLm9yaWdpbmFsV2lkdGggfHwgaGVhZGVyLndpZHRoO1xuICAgICAgaGVhZGVyLmlzUmVzaXppbmcgPSBjb2x1bW5SZXNpemluZy5pc1Jlc2l6aW5nQ29sdW1uID09PSBoZWFkZXIuaWQ7XG5cbiAgICAgIGlmIChjYW5SZXNpemUpIHtcbiAgICAgICAgaGVhZGVyLmdldFJlc2l6ZXJQcm9wcyA9IG1ha2VQcm9wR2V0dGVyKGdldEhvb2tzKCkuZ2V0UmVzaXplclByb3BzLCB7XG4gICAgICAgICAgaW5zdGFuY2U6IGdldEluc3RhbmNlKCksXG4gICAgICAgICAgaGVhZGVyOiBoZWFkZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdXNlSW5zdGFuY2UkYihpbnN0YW5jZSkge1xuICAgIHZhciBwbHVnaW5zID0gaW5zdGFuY2UucGx1Z2lucyxcbiAgICAgICAgZGlzcGF0Y2ggPSBpbnN0YW5jZS5kaXNwYXRjaCxcbiAgICAgICAgX2luc3RhbmNlJGF1dG9SZXNldFJlID0gaW5zdGFuY2UuYXV0b1Jlc2V0UmVzaXplLFxuICAgICAgICBhdXRvUmVzZXRSZXNpemUgPSBfaW5zdGFuY2UkYXV0b1Jlc2V0UmUgPT09IHZvaWQgMCA/IHRydWUgOiBfaW5zdGFuY2UkYXV0b1Jlc2V0UmUsXG4gICAgICAgIGNvbHVtbnMgPSBpbnN0YW5jZS5jb2x1bW5zO1xuICAgIGVuc3VyZVBsdWdpbk9yZGVyKHBsdWdpbnMsIFsndXNlQWJzb2x1dGVMYXlvdXQnXSwgJ3VzZVJlc2l6ZUNvbHVtbnMnKTtcbiAgICB2YXIgZ2V0QXV0b1Jlc2V0UmVzaXplID0gdXNlR2V0TGF0ZXN0KGF1dG9SZXNldFJlc2l6ZSk7XG4gICAgdXNlTW91bnRlZExheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QXV0b1Jlc2V0UmVzaXplKCkpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRSZXNpemVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2NvbHVtbnNdKTtcbiAgICB2YXIgcmVzZXRSZXNpemluZyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IGFjdGlvbnMucmVzZXRSZXNpemVcbiAgICAgIH0pO1xuICAgIH0sIFtkaXNwYXRjaF0pO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIHtcbiAgICAgIHJlc2V0UmVzaXppbmc6IHJlc2V0UmVzaXppbmdcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExlYWZIZWFkZXJzKGhlYWRlcikge1xuICAgIHZhciBsZWFmSGVhZGVycyA9IFtdO1xuXG4gICAgdmFyIHJlY3Vyc2VIZWFkZXIgPSBmdW5jdGlvbiByZWN1cnNlSGVhZGVyKGhlYWRlcikge1xuICAgICAgaWYgKGhlYWRlci5jb2x1bW5zICYmIGhlYWRlci5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICBoZWFkZXIuY29sdW1ucy5tYXAocmVjdXJzZUhlYWRlcik7XG4gICAgICB9XG5cbiAgICAgIGxlYWZIZWFkZXJzLnB1c2goaGVhZGVyKTtcbiAgICB9O1xuXG4gICAgcmVjdXJzZUhlYWRlcihoZWFkZXIpO1xuICAgIHJldHVybiBsZWFmSGVhZGVycztcbiAgfVxuXG4gIHZhciBjZWxsU3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogMFxuICB9O1xuICB2YXIgdXNlQWJzb2x1dGVMYXlvdXQgPSBmdW5jdGlvbiB1c2VBYnNvbHV0ZUxheW91dChob29rcykge1xuICAgIGhvb2tzLmdldFRhYmxlQm9keVByb3BzLnB1c2goZ2V0Um93U3R5bGVzKTtcbiAgICBob29rcy5nZXRSb3dQcm9wcy5wdXNoKGdldFJvd1N0eWxlcyk7XG4gICAgaG9va3MuZ2V0SGVhZGVyR3JvdXBQcm9wcy5wdXNoKGdldFJvd1N0eWxlcyk7XG4gICAgaG9va3MuZ2V0Rm9vdGVyR3JvdXBQcm9wcy5wdXNoKGdldFJvd1N0eWxlcyk7XG4gICAgaG9va3MuZ2V0SGVhZGVyUHJvcHMucHVzaChmdW5jdGlvbiAocHJvcHMsIF9yZWYpIHtcbiAgICAgIHZhciBjb2x1bW4gPSBfcmVmLmNvbHVtbjtcbiAgICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBjZWxsU3R5bGVzLCB7XG4gICAgICAgICAgbGVmdDogY29sdW1uLnRvdGFsTGVmdCArIFwicHhcIixcbiAgICAgICAgICB3aWR0aDogY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgICAgfSlcbiAgICAgIH1dO1xuICAgIH0pO1xuICAgIGhvb2tzLmdldENlbGxQcm9wcy5wdXNoKGZ1bmN0aW9uIChwcm9wcywgX3JlZjIpIHtcbiAgICAgIHZhciBjZWxsID0gX3JlZjIuY2VsbDtcbiAgICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBjZWxsU3R5bGVzLCB7XG4gICAgICAgICAgbGVmdDogY2VsbC5jb2x1bW4udG90YWxMZWZ0ICsgXCJweFwiLFxuICAgICAgICAgIHdpZHRoOiBjZWxsLmNvbHVtbi50b3RhbFdpZHRoICsgXCJweFwiXG4gICAgICAgIH0pXG4gICAgICB9XTtcbiAgICB9KTtcbiAgICBob29rcy5nZXRGb290ZXJQcm9wcy5wdXNoKGZ1bmN0aW9uIChwcm9wcywgX3JlZjMpIHtcbiAgICAgIHZhciBjb2x1bW4gPSBfcmVmMy5jb2x1bW47XG4gICAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgY2VsbFN0eWxlcywge1xuICAgICAgICAgIGxlZnQ6IGNvbHVtbi50b3RhbExlZnQgKyBcInB4XCIsXG4gICAgICAgICAgd2lkdGg6IGNvbHVtbi50b3RhbFdpZHRoICsgXCJweFwiXG4gICAgICAgIH0pXG4gICAgICB9XTtcbiAgICB9KTtcbiAgfTtcbiAgdXNlQWJzb2x1dGVMYXlvdXQucGx1Z2luTmFtZSA9ICd1c2VBYnNvbHV0ZUxheW91dCc7XG5cbiAgdmFyIGdldFJvd1N0eWxlcyA9IGZ1bmN0aW9uIGdldFJvd1N0eWxlcyhwcm9wcywgX3JlZjQpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmNC5pbnN0YW5jZTtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgd2lkdGg6IGluc3RhbmNlLnRvdGFsQ29sdW1uc1dpZHRoICsgXCJweFwiXG4gICAgICB9XG4gICAgfV07XG4gIH07XG5cbiAgdmFyIGNlbGxTdHlsZXMkMSA9IHtcbiAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94J1xuICB9O1xuXG4gIHZhciBnZXRSb3dTdHlsZXMkMSA9IGZ1bmN0aW9uIGdldFJvd1N0eWxlcyhwcm9wcywgX3JlZikge1xuICAgIHZhciBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2U7XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICB3aWR0aDogaW5zdGFuY2UudG90YWxDb2x1bW5zV2lkdGggKyBcInB4XCJcbiAgICAgIH1cbiAgICB9XTtcbiAgfTtcblxuICB2YXIgdXNlQmxvY2tMYXlvdXQgPSBmdW5jdGlvbiB1c2VCbG9ja0xheW91dChob29rcykge1xuICAgIGhvb2tzLmdldFJvd1Byb3BzLnB1c2goZ2V0Um93U3R5bGVzJDEpO1xuICAgIGhvb2tzLmdldEhlYWRlckdyb3VwUHJvcHMucHVzaChnZXRSb3dTdHlsZXMkMSk7XG4gICAgaG9va3MuZ2V0Rm9vdGVyR3JvdXBQcm9wcy5wdXNoKGdldFJvd1N0eWxlcyQxKTtcbiAgICBob29rcy5nZXRIZWFkZXJQcm9wcy5wdXNoKGZ1bmN0aW9uIChwcm9wcywgX3JlZjIpIHtcbiAgICAgIHZhciBjb2x1bW4gPSBfcmVmMi5jb2x1bW47XG4gICAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgY2VsbFN0eWxlcyQxLCB7XG4gICAgICAgICAgd2lkdGg6IGNvbHVtbi50b3RhbFdpZHRoICsgXCJweFwiXG4gICAgICAgIH0pXG4gICAgICB9XTtcbiAgICB9KTtcbiAgICBob29rcy5nZXRDZWxsUHJvcHMucHVzaChmdW5jdGlvbiAocHJvcHMsIF9yZWYzKSB7XG4gICAgICB2YXIgY2VsbCA9IF9yZWYzLmNlbGw7XG4gICAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgY2VsbFN0eWxlcyQxLCB7XG4gICAgICAgICAgd2lkdGg6IGNlbGwuY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgICAgfSlcbiAgICAgIH1dO1xuICAgIH0pO1xuICAgIGhvb2tzLmdldEZvb3RlclByb3BzLnB1c2goZnVuY3Rpb24gKHByb3BzLCBfcmVmNCkge1xuICAgICAgdmFyIGNvbHVtbiA9IF9yZWY0LmNvbHVtbjtcbiAgICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBjZWxsU3R5bGVzJDEsIHtcbiAgICAgICAgICB3aWR0aDogY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgICAgfSlcbiAgICAgIH1dO1xuICAgIH0pO1xuICB9O1xuICB1c2VCbG9ja0xheW91dC5wbHVnaW5OYW1lID0gJ3VzZUJsb2NrTGF5b3V0JztcblxuICBmdW5jdGlvbiB1c2VGbGV4TGF5b3V0KGhvb2tzKSB7XG4gICAgaG9va3MuZ2V0VGFibGVQcm9wcy5wdXNoKGdldFRhYmxlUHJvcHMpO1xuICAgIGhvb2tzLmdldFJvd1Byb3BzLnB1c2goZ2V0Um93U3R5bGVzJDIpO1xuICAgIGhvb2tzLmdldEhlYWRlckdyb3VwUHJvcHMucHVzaChnZXRSb3dTdHlsZXMkMik7XG4gICAgaG9va3MuZ2V0Rm9vdGVyR3JvdXBQcm9wcy5wdXNoKGdldFJvd1N0eWxlcyQyKTtcbiAgICBob29rcy5nZXRIZWFkZXJQcm9wcy5wdXNoKGdldEhlYWRlclByb3BzKTtcbiAgICBob29rcy5nZXRDZWxsUHJvcHMucHVzaChnZXRDZWxsUHJvcHMpO1xuICAgIGhvb2tzLmdldEZvb3RlclByb3BzLnB1c2goZ2V0Rm9vdGVyUHJvcHMpO1xuICB9XG4gIHVzZUZsZXhMYXlvdXQucGx1Z2luTmFtZSA9ICd1c2VGbGV4TGF5b3V0JztcblxuICB2YXIgZ2V0VGFibGVQcm9wcyA9IGZ1bmN0aW9uIGdldFRhYmxlUHJvcHMocHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIG1pbldpZHRoOiBpbnN0YW5jZS50b3RhbENvbHVtbnNNaW5XaWR0aCArIFwicHhcIlxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBnZXRSb3dTdHlsZXMkMiA9IGZ1bmN0aW9uIGdldFJvd1N0eWxlcyhwcm9wcywgX3JlZjIpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfcmVmMi5pbnN0YW5jZTtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGZsZXg6ICcxIDAgYXV0bycsXG4gICAgICAgIG1pbldpZHRoOiBpbnN0YW5jZS50b3RhbENvbHVtbnNNaW5XaWR0aCArIFwicHhcIlxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBnZXRIZWFkZXJQcm9wcyA9IGZ1bmN0aW9uIGdldEhlYWRlclByb3BzKHByb3BzLCBfcmVmMykge1xuICAgIHZhciBjb2x1bW4gPSBfcmVmMy5jb2x1bW47XG4gICAgcmV0dXJuIFtwcm9wcywge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIGZsZXg6IGNvbHVtbi50b3RhbEZsZXhXaWR0aCA/IGNvbHVtbi50b3RhbEZsZXhXaWR0aCArIFwiIDAgYXV0b1wiIDogdW5kZWZpbmVkLFxuICAgICAgICBtaW5XaWR0aDogY29sdW1uLnRvdGFsTWluV2lkdGggKyBcInB4XCIsXG4gICAgICAgIHdpZHRoOiBjb2x1bW4udG90YWxXaWR0aCArIFwicHhcIlxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBnZXRDZWxsUHJvcHMgPSBmdW5jdGlvbiBnZXRDZWxsUHJvcHMocHJvcHMsIF9yZWY0KSB7XG4gICAgdmFyIGNlbGwgPSBfcmVmNC5jZWxsO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBmbGV4OiBjZWxsLmNvbHVtbi50b3RhbEZsZXhXaWR0aCArIFwiIDAgYXV0b1wiLFxuICAgICAgICBtaW5XaWR0aDogY2VsbC5jb2x1bW4udG90YWxNaW5XaWR0aCArIFwicHhcIixcbiAgICAgICAgd2lkdGg6IGNlbGwuY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgIH1cbiAgICB9XTtcbiAgfTtcblxuICB2YXIgZ2V0Rm9vdGVyUHJvcHMgPSBmdW5jdGlvbiBnZXRGb290ZXJQcm9wcyhwcm9wcywgX3JlZjUpIHtcbiAgICB2YXIgY29sdW1uID0gX3JlZjUuY29sdW1uO1xuICAgIHJldHVybiBbcHJvcHMsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBmbGV4OiBjb2x1bW4udG90YWxGbGV4V2lkdGggPyBjb2x1bW4udG90YWxGbGV4V2lkdGggKyBcIiAwIGF1dG9cIiA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWluV2lkdGg6IGNvbHVtbi50b3RhbE1pbldpZHRoICsgXCJweFwiLFxuICAgICAgICB3aWR0aDogY29sdW1uLnRvdGFsV2lkdGggKyBcInB4XCJcbiAgICAgIH1cbiAgICB9XTtcbiAgfTtcblxuICBhY3Rpb25zLmNvbHVtblN0YXJ0UmVzaXppbmcgPSAnY29sdW1uU3RhcnRSZXNpemluZyc7XG4gIGFjdGlvbnMuY29sdW1uUmVzaXppbmcgPSAnY29sdW1uUmVzaXppbmcnO1xuICBhY3Rpb25zLmNvbHVtbkRvbmVSZXNpemluZyA9ICdjb2x1bW5Eb25lUmVzaXppbmcnO1xuICBhY3Rpb25zLnJlc2V0UmVzaXplID0gJ3Jlc2V0UmVzaXplJztcbiAgZnVuY3Rpb24gdXNlR3JpZExheW91dChob29rcykge1xuICAgIGhvb2tzLnN0YXRlUmVkdWNlcnMucHVzaChyZWR1Y2VyJGMpO1xuICAgIGhvb2tzLmdldFRhYmxlUHJvcHMucHVzaChnZXRUYWJsZVByb3BzJDEpO1xuICAgIGhvb2tzLmdldEhlYWRlclByb3BzLnB1c2goZ2V0SGVhZGVyUHJvcHMkMSk7XG4gICAgaG9va3MuZ2V0Um93UHJvcHMucHVzaChnZXRSb3dQcm9wcyk7XG4gIH1cbiAgdXNlR3JpZExheW91dC5wbHVnaW5OYW1lID0gJ3VzZUdyaWRMYXlvdXQnO1xuXG4gIHZhciBnZXRUYWJsZVByb3BzJDEgPSBmdW5jdGlvbiBnZXRUYWJsZVByb3BzKHByb3BzLCBfcmVmKSB7XG4gICAgdmFyIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZTtcbiAgICB2YXIgZ3JpZFRlbXBsYXRlQ29sdW1ucyA9IGluc3RhbmNlLnZpc2libGVDb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJHN0YXRlJGNvbHVtO1xuXG4gICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuZ3JpZExheW91dC5jb2x1bW5XaWR0aHNbY29sdW1uLmlkXSkgcmV0dXJuIGluc3RhbmNlLnN0YXRlLmdyaWRMYXlvdXQuY29sdW1uV2lkdGhzW2NvbHVtbi5pZF0gKyBcInB4XCI7IC8vIFdoZW4gcmVzaXppbmcsIGxvY2sgdGhlIHdpZHRoIG9mIGFsbCB1bnNldCBjb2x1bW5zXG4gICAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIHVzZXItcHJvdmlkZWQgd2lkdGggb3IgZGVmYXVsdENvbHVtbiB3aWR0aCxcbiAgICAgIC8vIHdoaWNoIGNvdWxkIHBvdGVudGlhbGx5IGJlICdhdXRvJyBvciAnZnInIHVuaXRzIHRoYXQgZG9uJ3Qgc2NhbGUgbGluZWFybHlcblxuICAgICAgaWYgKChfaW5zdGFuY2Ukc3RhdGUkY29sdW0gPSBpbnN0YW5jZS5zdGF0ZS5jb2x1bW5SZXNpemluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRzdGF0ZSRjb2x1bS5pc1Jlc2l6aW5nQ29sdW1uKSByZXR1cm4gaW5zdGFuY2Uuc3RhdGUuZ3JpZExheW91dC5zdGFydFdpZHRoc1tjb2x1bW4uaWRdICsgXCJweFwiO1xuICAgICAgaWYgKHR5cGVvZiBjb2x1bW4ud2lkdGggPT09ICdudW1iZXInKSByZXR1cm4gY29sdW1uLndpZHRoICsgXCJweFwiO1xuICAgICAgcmV0dXJuIGNvbHVtbi53aWR0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiBcImdyaWRcIixcbiAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogZ3JpZFRlbXBsYXRlQ29sdW1ucy5qb2luKFwiIFwiKVxuICAgICAgfVxuICAgIH1dO1xuICB9O1xuXG4gIHZhciBnZXRIZWFkZXJQcm9wcyQxID0gZnVuY3Rpb24gZ2V0SGVhZGVyUHJvcHMocHJvcHMsIF9yZWYyKSB7XG4gICAgdmFyIGNvbHVtbiA9IF9yZWYyLmNvbHVtbjtcbiAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICBpZDogXCJoZWFkZXItY2VsbC1cIiArIGNvbHVtbi5pZCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcInN0aWNreVwiLFxuICAgICAgICAvL2VuYWJsZXMgYSBzY3JvbGwgd3JhcHBlciB0byBiZSBwbGFjZWQgYXJvdW5kIHRoZSB0YWJsZSBhbmQgaGF2ZSBzdGlja3kgaGVhZGVyc1xuICAgICAgICBncmlkQ29sdW1uOiBcInNwYW4gXCIgKyBjb2x1bW4udG90YWxWaXNpYmxlSGVhZGVyQ291bnRcbiAgICAgIH1cbiAgICB9XTtcbiAgfTtcblxuICB2YXIgZ2V0Um93UHJvcHMgPSBmdW5jdGlvbiBnZXRSb3dQcm9wcyhwcm9wcywgX3JlZjMpIHtcbiAgICB2YXIgcm93ID0gX3JlZjMucm93O1xuXG4gICAgaWYgKHJvdy5pc0V4cGFuZGVkKSB7XG4gICAgICByZXR1cm4gW3Byb3BzLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZ3JpZENvbHVtbjogXCIxIC8gXCIgKyAocm93LmNlbGxzLmxlbmd0aCArIDEpXG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH1cblxuICAgIHJldHVybiBbcHJvcHMsIHt9XTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWR1Y2VyJGMoc3RhdGUsIGFjdGlvbiwgcHJldmlvdXNTdGF0ZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuaW5pdCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgZ3JpZExheW91dDoge1xuICAgICAgICAgIGNvbHVtbldpZHRoczoge31cbiAgICAgICAgfVxuICAgICAgfSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5yZXNldFJlc2l6ZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBncmlkTGF5b3V0OiB7XG4gICAgICAgICAgY29sdW1uV2lkdGhzOiB7fVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuY29sdW1uU3RhcnRSZXNpemluZykge1xuICAgICAgdmFyIGNvbHVtbklkID0gYWN0aW9uLmNvbHVtbklkLFxuICAgICAgICAgIGhlYWRlcklkV2lkdGhzID0gYWN0aW9uLmhlYWRlcklkV2lkdGhzO1xuICAgICAgdmFyIGNvbHVtbldpZHRoID0gZ2V0RWxlbWVudFdpZHRoKGNvbHVtbklkKTtcblxuICAgICAgaWYgKGNvbHVtbldpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHN0YXJ0V2lkdGhzID0gaW5zdGFuY2UudmlzaWJsZUNvbHVtbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNvbHVtbikge1xuICAgICAgICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFjYywgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbY29sdW1uLmlkXSA9IGdldEVsZW1lbnRXaWR0aChjb2x1bW4uaWQpLCBfZXh0ZW5kczIpKTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIgbWluV2lkdGhzID0gaW5zdGFuY2UudmlzaWJsZUNvbHVtbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNvbHVtbikge1xuICAgICAgICAgIHZhciBfZXh0ZW5kczM7XG5cbiAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFjYywgKF9leHRlbmRzMyA9IHt9LCBfZXh0ZW5kczNbY29sdW1uLmlkXSA9IGNvbHVtbi5taW5XaWR0aCwgX2V4dGVuZHMzKSk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgdmFyIG1heFdpZHRocyA9IGluc3RhbmNlLnZpc2libGVDb2x1bW5zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjb2x1bW4pIHtcbiAgICAgICAgICB2YXIgX2V4dGVuZHM0O1xuXG4gICAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBhY2MsIChfZXh0ZW5kczQgPSB7fSwgX2V4dGVuZHM0W2NvbHVtbi5pZF0gPSBjb2x1bW4ubWF4V2lkdGgsIF9leHRlbmRzNCkpO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHZhciBoZWFkZXJJZEdyaWRXaWR0aHMgPSBoZWFkZXJJZFdpZHRocy5tYXAoZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICAgICAgdmFyIGhlYWRlcklkID0gX3JlZjRbMF07XG4gICAgICAgICAgcmV0dXJuIFtoZWFkZXJJZCwgZ2V0RWxlbWVudFdpZHRoKGhlYWRlcklkKV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCB7XG4gICAgICAgICAgZ3JpZExheW91dDogX2V4dGVuZHMoe30sIHN0YXRlLmdyaWRMYXlvdXQsIHtcbiAgICAgICAgICAgIHN0YXJ0V2lkdGhzOiBzdGFydFdpZHRocyxcbiAgICAgICAgICAgIG1pbldpZHRoczogbWluV2lkdGhzLFxuICAgICAgICAgICAgbWF4V2lkdGhzOiBtYXhXaWR0aHMsXG4gICAgICAgICAgICBoZWFkZXJJZEdyaWRXaWR0aHM6IGhlYWRlcklkR3JpZFdpZHRocyxcbiAgICAgICAgICAgIGNvbHVtbldpZHRoOiBjb2x1bW5XaWR0aFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5jb2x1bW5SZXNpemluZykge1xuICAgICAgdmFyIGNsaWVudFggPSBhY3Rpb24uY2xpZW50WDtcbiAgICAgIHZhciBzdGFydFggPSBzdGF0ZS5jb2x1bW5SZXNpemluZy5zdGFydFg7XG5cbiAgICAgIHZhciBfc3RhdGUkZ3JpZExheW91dCA9IHN0YXRlLmdyaWRMYXlvdXQsXG4gICAgICAgICAgX2NvbHVtbldpZHRoID0gX3N0YXRlJGdyaWRMYXlvdXQuY29sdW1uV2lkdGgsXG4gICAgICAgICAgX21pbldpZHRocyA9IF9zdGF0ZSRncmlkTGF5b3V0Lm1pbldpZHRocyxcbiAgICAgICAgICBfbWF4V2lkdGhzID0gX3N0YXRlJGdyaWRMYXlvdXQubWF4V2lkdGhzLFxuICAgICAgICAgIF9zdGF0ZSRncmlkTGF5b3V0JGhlYSA9IF9zdGF0ZSRncmlkTGF5b3V0LmhlYWRlcklkR3JpZFdpZHRocyxcbiAgICAgICAgICBfaGVhZGVySWRHcmlkV2lkdGhzID0gX3N0YXRlJGdyaWRMYXlvdXQkaGVhID09PSB2b2lkIDAgPyBbXSA6IF9zdGF0ZSRncmlkTGF5b3V0JGhlYTtcblxuICAgICAgdmFyIGRlbHRhWCA9IGNsaWVudFggLSBzdGFydFg7XG4gICAgICB2YXIgcGVyY2VudGFnZURlbHRhWCA9IGRlbHRhWCAvIF9jb2x1bW5XaWR0aDtcbiAgICAgIHZhciBuZXdDb2x1bW5XaWR0aHMgPSB7fTtcblxuICAgICAgX2hlYWRlcklkR3JpZFdpZHRocy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICB2YXIgaGVhZGVySWQgPSBfcmVmNVswXSxcbiAgICAgICAgICAgIGhlYWRlcldpZHRoID0gX3JlZjVbMV07XG4gICAgICAgIG5ld0NvbHVtbldpZHRoc1toZWFkZXJJZF0gPSBNYXRoLm1pbihNYXRoLm1heChfbWluV2lkdGhzW2hlYWRlcklkXSwgaGVhZGVyV2lkdGggKyBoZWFkZXJXaWR0aCAqIHBlcmNlbnRhZ2VEZWx0YVgpLCBfbWF4V2lkdGhzW2hlYWRlcklkXSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBncmlkTGF5b3V0OiBfZXh0ZW5kcyh7fSwgc3RhdGUuZ3JpZExheW91dCwge1xuICAgICAgICAgIGNvbHVtbldpZHRoczogX2V4dGVuZHMoe30sIHN0YXRlLmdyaWRMYXlvdXQuY29sdW1uV2lkdGhzLCB7fSwgbmV3Q29sdW1uV2lkdGhzKVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvbi50eXBlID09PSBhY3Rpb25zLmNvbHVtbkRvbmVSZXNpemluZykge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgICBncmlkTGF5b3V0OiBfZXh0ZW5kcyh7fSwgc3RhdGUuZ3JpZExheW91dCwge1xuICAgICAgICAgIHN0YXJ0V2lkdGhzOiB7fSxcbiAgICAgICAgICBtaW5XaWR0aHM6IHt9LFxuICAgICAgICAgIG1heFdpZHRoczoge31cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRXaWR0aChjb2x1bW5JZCkge1xuICAgIHZhciBfZG9jdW1lbnQkZ2V0RWxlbWVudEI7XG5cbiAgICB2YXIgd2lkdGggPSAoX2RvY3VtZW50JGdldEVsZW1lbnRCID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJoZWFkZXItY2VsbC1cIiArIGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kb2N1bWVudCRnZXRFbGVtZW50Qi5vZmZzZXRXaWR0aDtcblxuICAgIGlmICh3aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy5fVU5TVEFCTEVfdXNlUGl2b3RDb2x1bW5zID0gX1VOU1RBQkxFX3VzZVBpdm90Q29sdW1ucztcbiAgZXhwb3J0cy5hY3Rpb25zID0gYWN0aW9ucztcbiAgZXhwb3J0cy5kZWZhdWx0Q29sdW1uID0gZGVmYXVsdENvbHVtbjtcbiAgZXhwb3J0cy5kZWZhdWx0R3JvdXBCeUZuID0gZGVmYXVsdEdyb3VwQnlGbjtcbiAgZXhwb3J0cy5kZWZhdWx0T3JkZXJCeUZuID0gZGVmYXVsdE9yZGVyQnlGbjtcbiAgZXhwb3J0cy5kZWZhdWx0UmVuZGVyZXIgPSBkZWZhdWx0UmVuZGVyZXI7XG4gIGV4cG9ydHMuZW1wdHlSZW5kZXJlciA9IGVtcHR5UmVuZGVyZXI7XG4gIGV4cG9ydHMuZW5zdXJlUGx1Z2luT3JkZXIgPSBlbnN1cmVQbHVnaW5PcmRlcjtcbiAgZXhwb3J0cy5mbGV4UmVuZGVyID0gZmxleFJlbmRlcjtcbiAgZXhwb3J0cy5mdW5jdGlvbmFsVXBkYXRlID0gZnVuY3Rpb25hbFVwZGF0ZTtcbiAgZXhwb3J0cy5sb29wSG9va3MgPSBsb29wSG9va3M7XG4gIGV4cG9ydHMubWFrZVByb3BHZXR0ZXIgPSBtYWtlUHJvcEdldHRlcjtcbiAgZXhwb3J0cy5tYWtlUmVuZGVyZXIgPSBtYWtlUmVuZGVyZXI7XG4gIGV4cG9ydHMucmVkdWNlSG9va3MgPSByZWR1Y2VIb29rcztcbiAgZXhwb3J0cy5zYWZlVXNlTGF5b3V0RWZmZWN0ID0gc2FmZVVzZUxheW91dEVmZmVjdDtcbiAgZXhwb3J0cy51c2VBYnNvbHV0ZUxheW91dCA9IHVzZUFic29sdXRlTGF5b3V0O1xuICBleHBvcnRzLnVzZUFzeW5jRGVib3VuY2UgPSB1c2VBc3luY0RlYm91bmNlO1xuICBleHBvcnRzLnVzZUJsb2NrTGF5b3V0ID0gdXNlQmxvY2tMYXlvdXQ7XG4gIGV4cG9ydHMudXNlQ29sdW1uT3JkZXIgPSB1c2VDb2x1bW5PcmRlcjtcbiAgZXhwb3J0cy51c2VFeHBhbmRlZCA9IHVzZUV4cGFuZGVkO1xuICBleHBvcnRzLnVzZUZpbHRlcnMgPSB1c2VGaWx0ZXJzO1xuICBleHBvcnRzLnVzZUZsZXhMYXlvdXQgPSB1c2VGbGV4TGF5b3V0O1xuICBleHBvcnRzLnVzZUdldExhdGVzdCA9IHVzZUdldExhdGVzdDtcbiAgZXhwb3J0cy51c2VHbG9iYWxGaWx0ZXIgPSB1c2VHbG9iYWxGaWx0ZXI7XG4gIGV4cG9ydHMudXNlR3JpZExheW91dCA9IHVzZUdyaWRMYXlvdXQ7XG4gIGV4cG9ydHMudXNlR3JvdXBCeSA9IHVzZUdyb3VwQnk7XG4gIGV4cG9ydHMudXNlTW91bnRlZExheW91dEVmZmVjdCA9IHVzZU1vdW50ZWRMYXlvdXRFZmZlY3Q7XG4gIGV4cG9ydHMudXNlUGFnaW5hdGlvbiA9IHVzZVBhZ2luYXRpb247XG4gIGV4cG9ydHMudXNlUmVzaXplQ29sdW1ucyA9IHVzZVJlc2l6ZUNvbHVtbnM7XG4gIGV4cG9ydHMudXNlUm93U2VsZWN0ID0gdXNlUm93U2VsZWN0O1xuICBleHBvcnRzLnVzZVJvd1N0YXRlID0gdXNlUm93U3RhdGU7XG4gIGV4cG9ydHMudXNlU29ydEJ5ID0gdXNlU29ydEJ5O1xuICBleHBvcnRzLnVzZVRhYmxlID0gdXNlVGFibGU7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXRhYmxlLmRldmVsb3BtZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-table/dist/react-table.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-table/index.js":
/*!*******************************************!*\
  !*** ./node_modules/react-table/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("if (false) {} else {\n  module.exports = __webpack_require__(/*! ./dist/react-table.development.js */ \"(ssr)/./node_modules/react-table/dist/react-table.development.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdGFibGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGlKQUE2RDtBQUMvRCIsInNvdXJjZXMiOlsid2VicGFjazovL3NlYXJjaC8uL25vZGVfbW9kdWxlcy9yZWFjdC10YWJsZS9pbmRleC5qcz9mZDQxIl0sInNvdXJjZXNDb250ZW50IjpbImlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L3JlYWN0LXRhYmxlLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L3JlYWN0LXRhYmxlLmRldmVsb3BtZW50LmpzJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-table/index.js\n");

/***/ })

};
;