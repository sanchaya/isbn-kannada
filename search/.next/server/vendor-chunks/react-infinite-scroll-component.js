"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-infinite-scroll-component";
exports.ids = ["vendor-chunks/react-infinite-scroll-component"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-infinite-scroll-component/dist/index.es.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-infinite-scroll-component/dist/index.es.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n/* eslint-disable no-undefined,no-param-reassign,no-shadow */ /**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset)\n * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @return {Function}  A new, throttled, function.\n */ function throttle(delay, noTrailing, callback, debounceMode) {\n    /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */ var timeoutID;\n    var cancelled = false; // Keep track of the last time `callback` was executed.\n    var lastExec = 0; // Function to clear existing timeout\n    function clearExistingTimeout() {\n        if (timeoutID) {\n            clearTimeout(timeoutID);\n        }\n    } // Function to cancel next exec\n    function cancel() {\n        clearExistingTimeout();\n        cancelled = true;\n    } // `noTrailing` defaults to falsy.\n    if (typeof noTrailing !== \"boolean\") {\n        debounceMode = callback;\n        callback = noTrailing;\n        noTrailing = undefined;\n    }\n    /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */ function wrapper() {\n        var self = this;\n        var elapsed = Date.now() - lastExec;\n        var args = arguments;\n        if (cancelled) {\n            return;\n        } // Execute `callback` and update the `lastExec` timestamp.\n        function exec() {\n            lastExec = Date.now();\n            callback.apply(self, args);\n        }\n        /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */ function clear() {\n            timeoutID = undefined;\n        }\n        if (debounceMode && !timeoutID) {\n            /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`.\n       */ exec();\n        }\n        clearExistingTimeout();\n        if (debounceMode === undefined && elapsed > delay) {\n            /*\n       * In throttle mode, if `delay` time has been exceeded, execute\n       * `callback`.\n       */ exec();\n        } else if (noTrailing !== true) {\n            /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */ timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n        }\n    }\n    wrapper.cancel = cancel; // Return the wrapper function.\n    return wrapper;\n}\nvar ThresholdUnits = {\n    Pixel: \"Pixel\",\n    Percent: \"Percent\"\n};\nvar defaultThreshold = {\n    unit: ThresholdUnits.Percent,\n    value: 0.8\n};\nfunction parseThreshold(scrollThreshold) {\n    if (typeof scrollThreshold === \"number\") {\n        return {\n            unit: ThresholdUnits.Percent,\n            value: scrollThreshold * 100\n        };\n    }\n    if (typeof scrollThreshold === \"string\") {\n        if (scrollThreshold.match(/^(\\d*(\\.\\d+)?)px$/)) {\n            return {\n                unit: ThresholdUnits.Pixel,\n                value: parseFloat(scrollThreshold)\n            };\n        }\n        if (scrollThreshold.match(/^(\\d*(\\.\\d+)?)%$/)) {\n            return {\n                unit: ThresholdUnits.Percent,\n                value: parseFloat(scrollThreshold)\n            };\n        }\n        console.warn('scrollThreshold format is invalid. Valid formats: \"120px\", \"50%\"...');\n        return defaultThreshold;\n    }\n    console.warn(\"scrollThreshold should be string or number\");\n    return defaultThreshold;\n}\nvar InfiniteScroll = /** @class */ function(_super) {\n    __extends(InfiniteScroll, _super);\n    function InfiniteScroll(props) {\n        var _this = _super.call(this, props) || this;\n        _this.lastScrollTop = 0;\n        _this.actionTriggered = false;\n        // variables to keep track of pull down behaviour\n        _this.startY = 0;\n        _this.currentY = 0;\n        _this.dragging = false;\n        // will be populated in componentDidMount\n        // based on the height of the pull down element\n        _this.maxPullDownDistance = 0;\n        _this.getScrollableTarget = function() {\n            if (_this.props.scrollableTarget instanceof HTMLElement) return _this.props.scrollableTarget;\n            if (typeof _this.props.scrollableTarget === \"string\") {\n                return document.getElementById(_this.props.scrollableTarget);\n            }\n            if (_this.props.scrollableTarget === null) {\n                console.warn(\"You are trying to pass scrollableTarget but it is null. This might\\n        happen because the element may not have been added to DOM yet.\\n        See https://github.com/ankeetmaini/react-infinite-scroll-component/issues/59 for more info.\\n      \");\n            }\n            return null;\n        };\n        _this.onStart = function(evt) {\n            if (_this.lastScrollTop) return;\n            _this.dragging = true;\n            if (evt instanceof MouseEvent) {\n                _this.startY = evt.pageY;\n            } else if (evt instanceof TouchEvent) {\n                _this.startY = evt.touches[0].pageY;\n            }\n            _this.currentY = _this.startY;\n            if (_this._infScroll) {\n                _this._infScroll.style.willChange = \"transform\";\n                _this._infScroll.style.transition = \"transform 0.2s cubic-bezier(0,0,0.31,1)\";\n            }\n        };\n        _this.onMove = function(evt) {\n            if (!_this.dragging) return;\n            if (evt instanceof MouseEvent) {\n                _this.currentY = evt.pageY;\n            } else if (evt instanceof TouchEvent) {\n                _this.currentY = evt.touches[0].pageY;\n            }\n            // user is scrolling down to up\n            if (_this.currentY < _this.startY) return;\n            if (_this.currentY - _this.startY >= Number(_this.props.pullDownToRefreshThreshold)) {\n                _this.setState({\n                    pullToRefreshThresholdBreached: true\n                });\n            }\n            // so you can drag upto 1.5 times of the maxPullDownDistance\n            if (_this.currentY - _this.startY > _this.maxPullDownDistance * 1.5) return;\n            if (_this._infScroll) {\n                _this._infScroll.style.overflow = \"visible\";\n                _this._infScroll.style.transform = \"translate3d(0px, \" + (_this.currentY - _this.startY) + \"px, 0px)\";\n            }\n        };\n        _this.onEnd = function() {\n            _this.startY = 0;\n            _this.currentY = 0;\n            _this.dragging = false;\n            if (_this.state.pullToRefreshThresholdBreached) {\n                _this.props.refreshFunction && _this.props.refreshFunction();\n                _this.setState({\n                    pullToRefreshThresholdBreached: false\n                });\n            }\n            requestAnimationFrame(function() {\n                // this._infScroll\n                if (_this._infScroll) {\n                    _this._infScroll.style.overflow = \"auto\";\n                    _this._infScroll.style.transform = \"none\";\n                    _this._infScroll.style.willChange = \"unset\";\n                }\n            });\n        };\n        _this.onScrollListener = function(event) {\n            if (typeof _this.props.onScroll === \"function\") {\n                // Execute this callback in next tick so that it does not affect the\n                // functionality of the library.\n                setTimeout(function() {\n                    return _this.props.onScroll && _this.props.onScroll(event);\n                }, 0);\n            }\n            var target = _this.props.height || _this._scrollableNode ? event.target : document.documentElement.scrollTop ? document.documentElement : document.body;\n            // return immediately if the action has already been triggered,\n            // prevents multiple triggers.\n            if (_this.actionTriggered) return;\n            var atBottom = _this.props.inverse ? _this.isElementAtTop(target, _this.props.scrollThreshold) : _this.isElementAtBottom(target, _this.props.scrollThreshold);\n            // call the `next` function in the props to trigger the next data fetch\n            if (atBottom && _this.props.hasMore) {\n                _this.actionTriggered = true;\n                _this.setState({\n                    showLoader: true\n                });\n                _this.props.next && _this.props.next();\n            }\n            _this.lastScrollTop = target.scrollTop;\n        };\n        _this.state = {\n            showLoader: false,\n            pullToRefreshThresholdBreached: false,\n            prevDataLength: props.dataLength\n        };\n        _this.throttledOnScrollListener = throttle(150, _this.onScrollListener).bind(_this);\n        _this.onStart = _this.onStart.bind(_this);\n        _this.onMove = _this.onMove.bind(_this);\n        _this.onEnd = _this.onEnd.bind(_this);\n        return _this;\n    }\n    InfiniteScroll.prototype.componentDidMount = function() {\n        if (typeof this.props.dataLength === \"undefined\") {\n            throw new Error('mandatory prop \"dataLength\" is missing. The prop is needed' + \" when loading more content. Check README.md for usage\");\n        }\n        this._scrollableNode = this.getScrollableTarget();\n        this.el = this.props.height ? this._infScroll : this._scrollableNode || window;\n        if (this.el) {\n            this.el.addEventListener(\"scroll\", this.throttledOnScrollListener);\n        }\n        if (typeof this.props.initialScrollY === \"number\" && this.el && this.el instanceof HTMLElement && this.el.scrollHeight > this.props.initialScrollY) {\n            this.el.scrollTo(0, this.props.initialScrollY);\n        }\n        if (this.props.pullDownToRefresh && this.el) {\n            this.el.addEventListener(\"touchstart\", this.onStart);\n            this.el.addEventListener(\"touchmove\", this.onMove);\n            this.el.addEventListener(\"touchend\", this.onEnd);\n            this.el.addEventListener(\"mousedown\", this.onStart);\n            this.el.addEventListener(\"mousemove\", this.onMove);\n            this.el.addEventListener(\"mouseup\", this.onEnd);\n            // get BCR of pullDown element to position it above\n            this.maxPullDownDistance = this._pullDown && this._pullDown.firstChild && this._pullDown.firstChild.getBoundingClientRect().height || 0;\n            this.forceUpdate();\n            if (typeof this.props.refreshFunction !== \"function\") {\n                throw new Error('Mandatory prop \"refreshFunction\" missing.\\n          Pull Down To Refresh functionality will not work\\n          as expected. Check README.md for usage\\'');\n            }\n        }\n    };\n    InfiniteScroll.prototype.componentWillUnmount = function() {\n        if (this.el) {\n            this.el.removeEventListener(\"scroll\", this.throttledOnScrollListener);\n            if (this.props.pullDownToRefresh) {\n                this.el.removeEventListener(\"touchstart\", this.onStart);\n                this.el.removeEventListener(\"touchmove\", this.onMove);\n                this.el.removeEventListener(\"touchend\", this.onEnd);\n                this.el.removeEventListener(\"mousedown\", this.onStart);\n                this.el.removeEventListener(\"mousemove\", this.onMove);\n                this.el.removeEventListener(\"mouseup\", this.onEnd);\n            }\n        }\n    };\n    InfiniteScroll.prototype.componentDidUpdate = function(prevProps) {\n        // do nothing when dataLength is unchanged\n        if (this.props.dataLength === prevProps.dataLength) return;\n        this.actionTriggered = false;\n        // update state when new data was sent in\n        this.setState({\n            showLoader: false\n        });\n    };\n    InfiniteScroll.getDerivedStateFromProps = function(nextProps, prevState) {\n        var dataLengthChanged = nextProps.dataLength !== prevState.prevDataLength;\n        // reset when data changes\n        if (dataLengthChanged) {\n            return __assign(__assign({}, prevState), {\n                prevDataLength: nextProps.dataLength\n            });\n        }\n        return null;\n    };\n    InfiniteScroll.prototype.isElementAtTop = function(target, scrollThreshold) {\n        if (scrollThreshold === void 0) {\n            scrollThreshold = 0.8;\n        }\n        var clientHeight = target === document.body || target === document.documentElement ? window.screen.availHeight : target.clientHeight;\n        var threshold = parseThreshold(scrollThreshold);\n        if (threshold.unit === ThresholdUnits.Pixel) {\n            return target.scrollTop <= threshold.value + clientHeight - target.scrollHeight + 1;\n        }\n        return target.scrollTop <= threshold.value / 100 + clientHeight - target.scrollHeight + 1;\n    };\n    InfiniteScroll.prototype.isElementAtBottom = function(target, scrollThreshold) {\n        if (scrollThreshold === void 0) {\n            scrollThreshold = 0.8;\n        }\n        var clientHeight = target === document.body || target === document.documentElement ? window.screen.availHeight : target.clientHeight;\n        var threshold = parseThreshold(scrollThreshold);\n        if (threshold.unit === ThresholdUnits.Pixel) {\n            return target.scrollTop + clientHeight >= target.scrollHeight - threshold.value;\n        }\n        return target.scrollTop + clientHeight >= threshold.value / 100 * target.scrollHeight;\n    };\n    InfiniteScroll.prototype.render = function() {\n        var _this = this;\n        var style = __assign({\n            height: this.props.height || \"auto\",\n            overflow: \"auto\",\n            WebkitOverflowScrolling: \"touch\"\n        }, this.props.style);\n        var hasChildren = this.props.hasChildren || !!(this.props.children && this.props.children instanceof Array && this.props.children.length);\n        // because heighted infiniteScroll visualy breaks\n        // on drag down as overflow becomes visible\n        var outerDivStyle = this.props.pullDownToRefresh && this.props.height ? {\n            overflow: \"auto\"\n        } : {};\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            style: outerDivStyle,\n            className: \"infinite-scroll-component__outerdiv\"\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            className: \"infinite-scroll-component \" + (this.props.className || \"\"),\n            ref: function(infScroll) {\n                return _this._infScroll = infScroll;\n            },\n            style: style\n        }, this.props.pullDownToRefresh && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            style: {\n                position: \"relative\"\n            },\n            ref: function(pullDown) {\n                return _this._pullDown = pullDown;\n            }\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n            style: {\n                position: \"absolute\",\n                left: 0,\n                right: 0,\n                top: -1 * this.maxPullDownDistance\n            }\n        }, this.state.pullToRefreshThresholdBreached ? this.props.releaseToRefreshContent : this.props.pullDownToRefreshContent)), this.props.children, !this.state.showLoader && !hasChildren && this.props.hasMore && this.props.loader, this.state.showLoader && this.props.hasMore && this.props.loader, !this.props.hasMore && this.props.endMessage));\n    };\n    return InfiniteScroll;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InfiniteScroll); //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5maW5pdGUtc2Nyb2xsLWNvbXBvbmVudC9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QztBQUV6Qzs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FDOUUsMkJBQTJCLEdBRTNCLElBQUlFLGdCQUFnQixTQUFTQyxDQUFDLEVBQUVDLENBQUM7SUFDN0JGLGdCQUFnQkcsT0FBT0MsY0FBYyxJQUNoQztRQUFFQyxXQUFXLEVBQUU7SUFBQyxjQUFhQyxTQUFTLFNBQVVMLENBQUMsRUFBRUMsQ0FBQztRQUFJRCxFQUFFSSxTQUFTLEdBQUdIO0lBQUcsS0FDMUUsU0FBVUQsQ0FBQyxFQUFFQyxDQUFDO1FBQUksSUFBSyxJQUFJSyxLQUFLTCxFQUFHLElBQUlBLEVBQUVNLGNBQWMsQ0FBQ0QsSUFBSU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtJQUFFO0lBQzdFLE9BQU9QLGNBQWNDLEdBQUdDO0FBQzVCO0FBRUEsU0FBU08sVUFBVVIsQ0FBQyxFQUFFQyxDQUFDO0lBQ25CRixjQUFjQyxHQUFHQztJQUNqQixTQUFTUTtRQUFPLElBQUksQ0FBQ0MsV0FBVyxHQUFHVjtJQUFHO0lBQ3RDQSxFQUFFVyxTQUFTLEdBQUdWLE1BQU0sT0FBT0MsT0FBT1UsTUFBTSxDQUFDWCxLQUFNUSxDQUFBQSxHQUFHRSxTQUFTLEdBQUdWLEVBQUVVLFNBQVMsRUFBRSxJQUFJRixJQUFHO0FBQ3RGO0FBRUEsSUFBSUksV0FBVztJQUNYQSxXQUFXWCxPQUFPWSxNQUFNLElBQUksU0FBU0QsU0FBU0UsQ0FBQztRQUMzQyxJQUFLLElBQUlDLEdBQUdDLElBQUksR0FBR0MsSUFBSUMsVUFBVUMsTUFBTSxFQUFFSCxJQUFJQyxHQUFHRCxJQUFLO1lBQ2pERCxJQUFJRyxTQUFTLENBQUNGLEVBQUU7WUFDaEIsSUFBSyxJQUFJWCxLQUFLVSxFQUFHLElBQUlkLE9BQU9TLFNBQVMsQ0FBQ0osY0FBYyxDQUFD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RixLQUFLLFNBQVVHLFFBQVE7Z0JBQUksT0FBUXhGLE1BQU04RCxTQUFTLEdBQUcwQjtZQUFXO1FBQUUsaUJBQzdKdEosMERBQW1CLENBQUMsT0FBTztZQUFFaUYsT0FBTztnQkFDNUJvRSxVQUFVO2dCQUNWRSxNQUFNO2dCQUNOQyxPQUFPO2dCQUNQQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUNyRixtQkFBbUI7WUFDdEM7UUFBRSxHQUFHLElBQUksQ0FBQ3dCLEtBQUssQ0FBQ0osOEJBQThCLEdBQzVDLElBQUksQ0FBQzNCLEtBQUssQ0FBQzZGLHVCQUF1QixHQUNsQyxJQUFJLENBQUM3RixLQUFLLENBQUM4Rix3QkFBd0IsSUFDN0MsSUFBSSxDQUFDOUYsS0FBSyxDQUFDa0YsUUFBUSxFQUNuQixDQUFDLElBQUksQ0FBQ25ELEtBQUssQ0FBQ2lCLFVBQVUsSUFDbEIsQ0FBQ2lDLGVBQ0QsSUFBSSxDQUFDakYsS0FBSyxDQUFDK0MsT0FBTyxJQUNsQixJQUFJLENBQUMvQyxLQUFLLENBQUMrRixNQUFNLEVBQ3JCLElBQUksQ0FBQ2hFLEtBQUssQ0FBQ2lCLFVBQVUsSUFBSSxJQUFJLENBQUNoRCxLQUFLLENBQUMrQyxPQUFPLElBQUksSUFBSSxDQUFDL0MsS0FBSyxDQUFDK0YsTUFBTSxFQUNoRSxDQUFDLElBQUksQ0FBQy9GLEtBQUssQ0FBQytDLE9BQU8sSUFBSSxJQUFJLENBQUMvQyxLQUFLLENBQUNnRyxVQUFVO0lBQ3hEO0lBQ0EsT0FBT2xHO0FBQ1gsRUFBRTFELDRDQUFTQTtBQUVYLGlFQUFlMEQsY0FBY0EsRUFBQyxDQUM5QixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zZWFyY2gvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5maW5pdGUtc2Nyb2xsLWNvbXBvbmVudC9kaXN0L2luZGV4LmVzLmpzP2FiYjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkLG5vLXBhcmFtLXJlYXNzaWduLG5vLXNoYWRvdyAqL1xuXG4vKipcbiAqIFRocm90dGxlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBFc3BlY2lhbGx5IHVzZWZ1bCBmb3IgcmF0ZSBsaW1pdGluZ1xuICogZXhlY3V0aW9uIG9mIGhhbmRsZXJzIG9uIGV2ZW50cyBsaWtlIHJlc2l6ZSBhbmQgc2Nyb2xsLlxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gICAgZGVsYXkgICAgICAgICAgQSB6ZXJvLW9yLWdyZWF0ZXIgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLiBGb3IgZXZlbnQgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKSBhcmUgbW9zdCB1c2VmdWwuXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgIFtub1RyYWlsaW5nXSAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgbm9UcmFpbGluZyBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIG9ubHkgZXhlY3V0ZSBldmVyeSBgZGVsYXlgIG1pbGxpc2Vjb25kcyB3aGlsZSB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGVkLWZ1bmN0aW9uIGlzIGJlaW5nIGNhbGxlZC4gSWYgbm9UcmFpbGluZyBpcyBmYWxzZSBvciB1bnNwZWNpZmllZCwgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbmUgZmluYWwgdGltZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciB0aGUgbGFzdCB0aHJvdHRsZWQtZnVuY3Rpb24gY2FsbC4gKEFmdGVyIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgYGRlbGF5YCBtaWxsaXNlY29uZHMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KVxuICogQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayAgICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCwgYXMtaXMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGBjYWxsYmFja2Agd2hlbiB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGlzIGV4ZWN1dGVkLlxuICogQHBhcmFtICB7Qm9vbGVhbn0gICBbZGVib3VuY2VNb2RlXSBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLiBJZiBgZGVib3VuY2VNb2RlYCBpcyBmYWxzZSAoYXQgZW5kKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGUgYGNhbGxiYWNrYCB0byBleGVjdXRlIGFmdGVyIGBkZWxheWAgbXMuXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259ICBBIG5ldywgdGhyb3R0bGVkLCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUgKGRlbGF5LCBub1RyYWlsaW5nLCBjYWxsYmFjaywgZGVib3VuY2VNb2RlKSB7XG4gIC8qXG4gICAqIEFmdGVyIHdyYXBwZXIgaGFzIHN0b3BwZWQgYmVpbmcgY2FsbGVkLCB0aGlzIHRpbWVvdXQgZW5zdXJlcyB0aGF0XG4gICAqIGBjYWxsYmFja2AgaXMgZXhlY3V0ZWQgYXQgdGhlIHByb3BlciB0aW1lcyBpbiBgdGhyb3R0bGVgIGFuZCBgZW5kYFxuICAgKiBkZWJvdW5jZSBtb2Rlcy5cbiAgICovXG4gIHZhciB0aW1lb3V0SUQ7XG4gIHZhciBjYW5jZWxsZWQgPSBmYWxzZTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGFzdCB0aW1lIGBjYWxsYmFja2Agd2FzIGV4ZWN1dGVkLlxuXG4gIHZhciBsYXN0RXhlYyA9IDA7IC8vIEZ1bmN0aW9uIHRvIGNsZWFyIGV4aXN0aW5nIHRpbWVvdXRcblxuICBmdW5jdGlvbiBjbGVhckV4aXN0aW5nVGltZW91dCgpIHtcbiAgICBpZiAodGltZW91dElEKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgICB9XG4gIH0gLy8gRnVuY3Rpb24gdG8gY2FuY2VsIG5leHQgZXhlY1xuXG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGNsZWFyRXhpc3RpbmdUaW1lb3V0KCk7XG4gICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgfSAvLyBgbm9UcmFpbGluZ2AgZGVmYXVsdHMgdG8gZmFsc3kuXG5cblxuICBpZiAodHlwZW9mIG5vVHJhaWxpbmcgIT09ICdib29sZWFuJykge1xuICAgIGRlYm91bmNlTW9kZSA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gbm9UcmFpbGluZztcbiAgICBub1RyYWlsaW5nID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qXG4gICAqIFRoZSBgd3JhcHBlcmAgZnVuY3Rpb24gZW5jYXBzdWxhdGVzIGFsbCBvZiB0aGUgdGhyb3R0bGluZyAvIGRlYm91bmNpbmdcbiAgICogZnVuY3Rpb25hbGl0eSBhbmQgd2hlbiBleGVjdXRlZCB3aWxsIGxpbWl0IHRoZSByYXRlIGF0IHdoaWNoIGBjYWxsYmFja2BcbiAgICogaXMgZXhlY3V0ZWQuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gbGFzdEV4ZWM7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBFeGVjdXRlIGBjYWxsYmFja2AgYW5kIHVwZGF0ZSB0aGUgYGxhc3RFeGVjYCB0aW1lc3RhbXAuXG5cblxuICAgIGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICBsYXN0RXhlYyA9IERhdGUubm93KCk7XG4gICAgICBjYWxsYmFjay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbikgdGhpcyBpcyB1c2VkIHRvIGNsZWFyIHRoZSBmbGFnXG4gICAgICogdG8gYWxsb3cgZnV0dXJlIGBjYWxsYmFja2AgZXhlY3V0aW9ucy5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aW1lb3V0SUQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGRlYm91bmNlTW9kZSAmJiAhdGltZW91dElEKSB7XG4gICAgICAvKlxuICAgICAgICogU2luY2UgYHdyYXBwZXJgIGlzIGJlaW5nIGNhbGxlZCBmb3IgdGhlIGZpcnN0IHRpbWUgYW5kXG4gICAgICAgKiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIGV4ZWN1dGUgYGNhbGxiYWNrYC5cbiAgICAgICAqL1xuICAgICAgZXhlYygpO1xuICAgIH1cblxuICAgIGNsZWFyRXhpc3RpbmdUaW1lb3V0KCk7XG5cbiAgICBpZiAoZGVib3VuY2VNb2RlID09PSB1bmRlZmluZWQgJiYgZWxhcHNlZCA+IGRlbGF5KSB7XG4gICAgICAvKlxuICAgICAgICogSW4gdGhyb3R0bGUgbW9kZSwgaWYgYGRlbGF5YCB0aW1lIGhhcyBiZWVuIGV4Y2VlZGVkLCBleGVjdXRlXG4gICAgICAgKiBgY2FsbGJhY2tgLlxuICAgICAgICovXG4gICAgICBleGVjKCk7XG4gICAgfSBlbHNlIGlmIChub1RyYWlsaW5nICE9PSB0cnVlKSB7XG4gICAgICAvKlxuICAgICAgICogSW4gdHJhaWxpbmcgdGhyb3R0bGUgbW9kZSwgc2luY2UgYGRlbGF5YCB0aW1lIGhhcyBub3QgYmVlblxuICAgICAgICogZXhjZWVkZWQsIHNjaGVkdWxlIGBjYWxsYmFja2AgdG8gZXhlY3V0ZSBgZGVsYXlgIG1zIGFmdGVyIG1vc3RcbiAgICAgICAqIHJlY2VudCBleGVjdXRpb24uXG4gICAgICAgKlxuICAgICAgICogSWYgYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pLCBzY2hlZHVsZSBgY2xlYXJgIHRvIGV4ZWN1dGVcbiAgICAgICAqIGFmdGVyIGBkZWxheWAgbXMuXG4gICAgICAgKlxuICAgICAgICogSWYgYGRlYm91bmNlTW9kZWAgaXMgZmFsc2UgKGF0IGVuZCksIHNjaGVkdWxlIGBjYWxsYmFja2AgdG9cbiAgICAgICAqIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cbiAgICAgICAqL1xuICAgICAgdGltZW91dElEID0gc2V0VGltZW91dChkZWJvdW5jZU1vZGUgPyBjbGVhciA6IGV4ZWMsIGRlYm91bmNlTW9kZSA9PT0gdW5kZWZpbmVkID8gZGVsYXkgLSBlbGFwc2VkIDogZGVsYXkpO1xuICAgIH1cbiAgfVxuXG4gIHdyYXBwZXIuY2FuY2VsID0gY2FuY2VsOyAvLyBSZXR1cm4gdGhlIHdyYXBwZXIgZnVuY3Rpb24uXG5cbiAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbnZhciBUaHJlc2hvbGRVbml0cyA9IHtcclxuICAgIFBpeGVsOiAnUGl4ZWwnLFxyXG4gICAgUGVyY2VudDogJ1BlcmNlbnQnLFxyXG59O1xyXG52YXIgZGVmYXVsdFRocmVzaG9sZCA9IHtcclxuICAgIHVuaXQ6IFRocmVzaG9sZFVuaXRzLlBlcmNlbnQsXHJcbiAgICB2YWx1ZTogMC44LFxyXG59O1xyXG5mdW5jdGlvbiBwYXJzZVRocmVzaG9sZChzY3JvbGxUaHJlc2hvbGQpIHtcclxuICAgIGlmICh0eXBlb2Ygc2Nyb2xsVGhyZXNob2xkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVuaXQ6IFRocmVzaG9sZFVuaXRzLlBlcmNlbnQsXHJcbiAgICAgICAgICAgIHZhbHVlOiBzY3JvbGxUaHJlc2hvbGQgKiAxMDAsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygc2Nyb2xsVGhyZXNob2xkID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmIChzY3JvbGxUaHJlc2hvbGQubWF0Y2goL14oXFxkKihcXC5cXGQrKT8pcHgkLykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVuaXQ6IFRocmVzaG9sZFVuaXRzLlBpeGVsLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQoc2Nyb2xsVGhyZXNob2xkKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNjcm9sbFRocmVzaG9sZC5tYXRjaCgvXihcXGQqKFxcLlxcZCspPyklJC8pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB1bml0OiBUaHJlc2hvbGRVbml0cy5QZXJjZW50LFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQoc2Nyb2xsVGhyZXNob2xkKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdzY3JvbGxUaHJlc2hvbGQgZm9ybWF0IGlzIGludmFsaWQuIFZhbGlkIGZvcm1hdHM6IFwiMTIwcHhcIiwgXCI1MCVcIi4uLicpO1xyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VGhyZXNob2xkO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS53YXJuKCdzY3JvbGxUaHJlc2hvbGQgc2hvdWxkIGJlIHN0cmluZyBvciBudW1iZXInKTtcclxuICAgIHJldHVybiBkZWZhdWx0VGhyZXNob2xkO1xyXG59XG5cbnZhciBJbmZpbml0ZVNjcm9sbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhJbmZpbml0ZVNjcm9sbCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEluZmluaXRlU2Nyb2xsKHByb3BzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubGFzdFNjcm9sbFRvcCA9IDA7XHJcbiAgICAgICAgX3RoaXMuYWN0aW9uVHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgLy8gdmFyaWFibGVzIHRvIGtlZXAgdHJhY2sgb2YgcHVsbCBkb3duIGJlaGF2aW91clxyXG4gICAgICAgIF90aGlzLnN0YXJ0WSA9IDA7XHJcbiAgICAgICAgX3RoaXMuY3VycmVudFkgPSAwO1xyXG4gICAgICAgIF90aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgLy8gd2lsbCBiZSBwb3B1bGF0ZWQgaW4gY29tcG9uZW50RGlkTW91bnRcclxuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgaGVpZ2h0IG9mIHRoZSBwdWxsIGRvd24gZWxlbWVudFxyXG4gICAgICAgIF90aGlzLm1heFB1bGxEb3duRGlzdGFuY2UgPSAwO1xyXG4gICAgICAgIF90aGlzLmdldFNjcm9sbGFibGVUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zY3JvbGxhYmxlVGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMuc2Nyb2xsYWJsZVRhcmdldDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy5wcm9wcy5zY3JvbGxhYmxlVGFyZ2V0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKF90aGlzLnByb3BzLnNjcm9sbGFibGVUYXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zY3JvbGxhYmxlVGFyZ2V0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJZb3UgYXJlIHRyeWluZyB0byBwYXNzIHNjcm9sbGFibGVUYXJnZXQgYnV0IGl0IGlzIG51bGwuIFRoaXMgbWlnaHRcXG4gICAgICAgIGhhcHBlbiBiZWNhdXNlIHRoZSBlbGVtZW50IG1heSBub3QgaGF2ZSBiZWVuIGFkZGVkIHRvIERPTSB5ZXQuXFxuICAgICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Fua2VldG1haW5pL3JlYWN0LWluZmluaXRlLXNjcm9sbC1jb21wb25lbnQvaXNzdWVzLzU5IGZvciBtb3JlIGluZm8uXFxuICAgICAgXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMub25TdGFydCA9IGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmxhc3RTY3JvbGxUb3ApXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGV2dCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0WSA9IGV2dC5wYWdlWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChldnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydFkgPSBldnQudG91Y2hlc1swXS5wYWdlWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50WSA9IF90aGlzLnN0YXJ0WTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLl9pbmZTY3JvbGwpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9pbmZTY3JvbGwuc3R5bGUud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2luZlNjcm9sbC5zdHlsZS50cmFuc2l0aW9uID0gXCJ0cmFuc2Zvcm0gMC4ycyBjdWJpYy1iZXppZXIoMCwwLDAuMzEsMSlcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMub25Nb3ZlID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgICAgICBpZiAoIV90aGlzLmRyYWdnaW5nKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAoZXZ0IGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFkgPSBldnQucGFnZVk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZ0IGluc3RhbmNlb2YgVG91Y2hFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFkgPSBldnQudG91Y2hlc1swXS5wYWdlWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB1c2VyIGlzIHNjcm9sbGluZyBkb3duIHRvIHVwXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50WSA8IF90aGlzLnN0YXJ0WSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmN1cnJlbnRZIC0gX3RoaXMuc3RhcnRZID49XHJcbiAgICAgICAgICAgICAgICBOdW1iZXIoX3RoaXMucHJvcHMucHVsbERvd25Ub1JlZnJlc2hUaHJlc2hvbGQpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVsbFRvUmVmcmVzaFRocmVzaG9sZEJyZWFjaGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc28geW91IGNhbiBkcmFnIHVwdG8gMS41IHRpbWVzIG9mIHRoZSBtYXhQdWxsRG93bkRpc3RhbmNlXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5jdXJyZW50WSAtIF90aGlzLnN0YXJ0WSA+IF90aGlzLm1heFB1bGxEb3duRGlzdGFuY2UgKiAxLjUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5faW5mU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5mU2Nyb2xsLnN0eWxlLm92ZXJmbG93ID0gJ3Zpc2libGUnO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2luZlNjcm9sbC5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZTNkKDBweCwgXCIgKyAoX3RoaXMuY3VycmVudFkgLVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0WSkgKyBcInB4LCAwcHgpXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLm9uRW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5zdGFydFkgPSAwO1xyXG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50WSA9IDA7XHJcbiAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5wdWxsVG9SZWZyZXNoVGhyZXNob2xkQnJlYWNoZWQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLnJlZnJlc2hGdW5jdGlvbiAmJiBfdGhpcy5wcm9wcy5yZWZyZXNoRnVuY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBwdWxsVG9SZWZyZXNoVGhyZXNob2xkQnJlYWNoZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2luZlNjcm9sbFxyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pbmZTY3JvbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW5mU2Nyb2xsLnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbmZTY3JvbGwuc3R5bGUudHJhbnNmb3JtID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbmZTY3JvbGwuc3R5bGUud2lsbENoYW5nZSA9ICd1bnNldCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMub25TY3JvbGxMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLnByb3BzLm9uU2Nyb2xsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIHRoaXMgY2FsbGJhY2sgaW4gbmV4dCB0aWNrIHNvIHRoYXQgaXQgZG9lcyBub3QgYWZmZWN0IHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb25hbGl0eSBvZiB0aGUgbGlicmFyeS5cclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucHJvcHMub25TY3JvbGwgJiYgX3RoaXMucHJvcHMub25TY3JvbGwoZXZlbnQpOyB9LCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX3RoaXMucHJvcHMuaGVpZ2h0IHx8IF90aGlzLl9zY3JvbGxhYmxlTm9kZVxyXG4gICAgICAgICAgICAgICAgPyBldmVudC50YXJnZXRcclxuICAgICAgICAgICAgICAgIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxyXG4gICAgICAgICAgICAgICAgICAgID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgOiBkb2N1bWVudC5ib2R5O1xyXG4gICAgICAgICAgICAvLyByZXR1cm4gaW1tZWRpYXRlbHkgaWYgdGhlIGFjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHRyaWdnZXJlZCxcclxuICAgICAgICAgICAgLy8gcHJldmVudHMgbXVsdGlwbGUgdHJpZ2dlcnMuXHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5hY3Rpb25UcmlnZ2VyZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHZhciBhdEJvdHRvbSA9IF90aGlzLnByb3BzLmludmVyc2VcclxuICAgICAgICAgICAgICAgID8gX3RoaXMuaXNFbGVtZW50QXRUb3AodGFyZ2V0LCBfdGhpcy5wcm9wcy5zY3JvbGxUaHJlc2hvbGQpXHJcbiAgICAgICAgICAgICAgICA6IF90aGlzLmlzRWxlbWVudEF0Qm90dG9tKHRhcmdldCwgX3RoaXMucHJvcHMuc2Nyb2xsVGhyZXNob2xkKTtcclxuICAgICAgICAgICAgLy8gY2FsbCB0aGUgYG5leHRgIGZ1bmN0aW9uIGluIHRoZSBwcm9wcyB0byB0cmlnZ2VyIHRoZSBuZXh0IGRhdGEgZmV0Y2hcclxuICAgICAgICAgICAgaWYgKGF0Qm90dG9tICYmIF90aGlzLnByb3BzLmhhc01vcmUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFjdGlvblRyaWdnZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHNob3dMb2FkZXI6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5uZXh0ICYmIF90aGlzLnByb3BzLm5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5sYXN0U2Nyb2xsVG9wID0gdGFyZ2V0LnNjcm9sbFRvcDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBzaG93TG9hZGVyOiBmYWxzZSxcclxuICAgICAgICAgICAgcHVsbFRvUmVmcmVzaFRocmVzaG9sZEJyZWFjaGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcHJldkRhdGFMZW5ndGg6IHByb3BzLmRhdGFMZW5ndGgsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBfdGhpcy50aHJvdHRsZWRPblNjcm9sbExpc3RlbmVyID0gdGhyb3R0bGUoMTUwLCBfdGhpcy5vblNjcm9sbExpc3RlbmVyKS5iaW5kKF90aGlzKTtcclxuICAgICAgICBfdGhpcy5vblN0YXJ0ID0gX3RoaXMub25TdGFydC5iaW5kKF90aGlzKTtcclxuICAgICAgICBfdGhpcy5vbk1vdmUgPSBfdGhpcy5vbk1vdmUuYmluZChfdGhpcyk7XHJcbiAgICAgICAgX3RoaXMub25FbmQgPSBfdGhpcy5vbkVuZC5iaW5kKF90aGlzKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBJbmZpbml0ZVNjcm9sbC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLmRhdGFMZW5ndGggPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1hbmRhdG9yeSBwcm9wIFxcXCJkYXRhTGVuZ3RoXFxcIiBpcyBtaXNzaW5nLiBUaGUgcHJvcCBpcyBuZWVkZWRcIiArXHJcbiAgICAgICAgICAgICAgICBcIiB3aGVuIGxvYWRpbmcgbW9yZSBjb250ZW50LiBDaGVjayBSRUFETUUubWQgZm9yIHVzYWdlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zY3JvbGxhYmxlTm9kZSA9IHRoaXMuZ2V0U2Nyb2xsYWJsZVRhcmdldCgpO1xyXG4gICAgICAgIHRoaXMuZWwgPSB0aGlzLnByb3BzLmhlaWdodFxyXG4gICAgICAgICAgICA/IHRoaXMuX2luZlNjcm9sbFxyXG4gICAgICAgICAgICA6IHRoaXMuX3Njcm9sbGFibGVOb2RlIHx8IHdpbmRvdztcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXNcclxuICAgICAgICAgICAgICAgIC50aHJvdHRsZWRPblNjcm9sbExpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLmluaXRpYWxTY3JvbGxZID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgICB0aGlzLmVsICYmXHJcbiAgICAgICAgICAgIHRoaXMuZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJlxyXG4gICAgICAgICAgICB0aGlzLmVsLnNjcm9sbEhlaWdodCA+IHRoaXMucHJvcHMuaW5pdGlhbFNjcm9sbFkpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5zY3JvbGxUbygwLCB0aGlzLnByb3BzLmluaXRpYWxTY3JvbGxZKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMucHVsbERvd25Ub1JlZnJlc2ggJiYgdGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uU3RhcnQpO1xyXG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Nb3ZlKTtcclxuICAgICAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25FbmQpO1xyXG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25TdGFydCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vbk1vdmUpO1xyXG4gICAgICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uRW5kKTtcclxuICAgICAgICAgICAgLy8gZ2V0IEJDUiBvZiBwdWxsRG93biBlbGVtZW50IHRvIHBvc2l0aW9uIGl0IGFib3ZlXHJcbiAgICAgICAgICAgIHRoaXMubWF4UHVsbERvd25EaXN0YW5jZSA9XHJcbiAgICAgICAgICAgICAgICAodGhpcy5fcHVsbERvd24gJiZcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdWxsRG93bi5maXJzdENoaWxkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVsbERvd24uZmlyc3RDaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIDA7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLnJlZnJlc2hGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFuZGF0b3J5IHByb3AgXFxcInJlZnJlc2hGdW5jdGlvblxcXCIgbWlzc2luZy5cXG4gICAgICAgICAgUHVsbCBEb3duIFRvIFJlZnJlc2ggZnVuY3Rpb25hbGl0eSB3aWxsIG5vdCB3b3JrXFxuICAgICAgICAgIGFzIGV4cGVjdGVkLiBDaGVjayBSRUFETUUubWQgZm9yIHVzYWdlJ1wiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbmZpbml0ZVNjcm9sbC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzXHJcbiAgICAgICAgICAgICAgICAudGhyb3R0bGVkT25TY3JvbGxMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnB1bGxEb3duVG9SZWZyZXNoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uTW92ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vbkVuZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25TdGFydCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3ZlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25FbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XHJcbiAgICAgICAgLy8gZG8gbm90aGluZyB3aGVuIGRhdGFMZW5ndGggaXMgdW5jaGFuZ2VkXHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZGF0YUxlbmd0aCA9PT0gcHJldlByb3BzLmRhdGFMZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLmFjdGlvblRyaWdnZXJlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIHVwZGF0ZSBzdGF0ZSB3aGVuIG5ldyBkYXRhIHdhcyBzZW50IGluXHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgIHNob3dMb2FkZXI6IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEluZmluaXRlU2Nyb2xsLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIChuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xyXG4gICAgICAgIHZhciBkYXRhTGVuZ3RoQ2hhbmdlZCA9IG5leHRQcm9wcy5kYXRhTGVuZ3RoICE9PSBwcmV2U3RhdGUucHJldkRhdGFMZW5ndGg7XHJcbiAgICAgICAgLy8gcmVzZXQgd2hlbiBkYXRhIGNoYW5nZXNcclxuICAgICAgICBpZiAoZGF0YUxlbmd0aENoYW5nZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2U3RhdGUpLCB7IHByZXZEYXRhTGVuZ3RoOiBuZXh0UHJvcHMuZGF0YUxlbmd0aCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgSW5maW5pdGVTY3JvbGwucHJvdG90eXBlLmlzRWxlbWVudEF0VG9wID0gZnVuY3Rpb24gKHRhcmdldCwgc2Nyb2xsVGhyZXNob2xkKSB7XHJcbiAgICAgICAgaWYgKHNjcm9sbFRocmVzaG9sZCA9PT0gdm9pZCAwKSB7IHNjcm9sbFRocmVzaG9sZCA9IDAuODsgfVxyXG4gICAgICAgIHZhciBjbGllbnRIZWlnaHQgPSB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkgfHwgdGFyZ2V0ID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcclxuICAgICAgICAgICAgPyB3aW5kb3cuc2NyZWVuLmF2YWlsSGVpZ2h0XHJcbiAgICAgICAgICAgIDogdGFyZ2V0LmNsaWVudEhlaWdodDtcclxuICAgICAgICB2YXIgdGhyZXNob2xkID0gcGFyc2VUaHJlc2hvbGQoc2Nyb2xsVGhyZXNob2xkKTtcclxuICAgICAgICBpZiAodGhyZXNob2xkLnVuaXQgPT09IFRocmVzaG9sZFVuaXRzLlBpeGVsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGFyZ2V0LnNjcm9sbFRvcCA8PVxyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkLnZhbHVlICsgY2xpZW50SGVpZ2h0IC0gdGFyZ2V0LnNjcm9sbEhlaWdodCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHRhcmdldC5zY3JvbGxUb3AgPD1cclxuICAgICAgICAgICAgdGhyZXNob2xkLnZhbHVlIC8gMTAwICsgY2xpZW50SGVpZ2h0IC0gdGFyZ2V0LnNjcm9sbEhlaWdodCArIDEpO1xyXG4gICAgfTtcclxuICAgIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5pc0VsZW1lbnRBdEJvdHRvbSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNjcm9sbFRocmVzaG9sZCkge1xyXG4gICAgICAgIGlmIChzY3JvbGxUaHJlc2hvbGQgPT09IHZvaWQgMCkgeyBzY3JvbGxUaHJlc2hvbGQgPSAwLjg7IH1cclxuICAgICAgICB2YXIgY2xpZW50SGVpZ2h0ID0gdGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5IHx8IHRhcmdldCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XHJcbiAgICAgICAgICAgID8gd2luZG93LnNjcmVlbi5hdmFpbEhlaWdodFxyXG4gICAgICAgICAgICA6IHRhcmdldC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgdmFyIHRocmVzaG9sZCA9IHBhcnNlVGhyZXNob2xkKHNjcm9sbFRocmVzaG9sZCk7XHJcbiAgICAgICAgaWYgKHRocmVzaG9sZC51bml0ID09PSBUaHJlc2hvbGRVbml0cy5QaXhlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRhcmdldC5zY3JvbGxUb3AgKyBjbGllbnRIZWlnaHQgPj0gdGFyZ2V0LnNjcm9sbEhlaWdodCAtIHRocmVzaG9sZC52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGFyZ2V0LnNjcm9sbFRvcCArIGNsaWVudEhlaWdodCA+PVxyXG4gICAgICAgICAgICAodGhyZXNob2xkLnZhbHVlIC8gMTAwKSAqIHRhcmdldC5zY3JvbGxIZWlnaHQpO1xyXG4gICAgfTtcclxuICAgIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgc3R5bGUgPSBfX2Fzc2lnbih7IGhlaWdodDogdGhpcy5wcm9wcy5oZWlnaHQgfHwgJ2F1dG8nLCBvdmVyZmxvdzogJ2F1dG8nLCBXZWJraXRPdmVyZmxvd1Njcm9sbGluZzogJ3RvdWNoJyB9LCB0aGlzLnByb3BzLnN0eWxlKTtcclxuICAgICAgICB2YXIgaGFzQ2hpbGRyZW4gPSB0aGlzLnByb3BzLmhhc0NoaWxkcmVuIHx8XHJcbiAgICAgICAgICAgICEhKHRoaXMucHJvcHMuY2hpbGRyZW4gJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW4gaW5zdGFuY2VvZiBBcnJheSAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlbi5sZW5ndGgpO1xyXG4gICAgICAgIC8vIGJlY2F1c2UgaGVpZ2h0ZWQgaW5maW5pdGVTY3JvbGwgdmlzdWFseSBicmVha3NcclxuICAgICAgICAvLyBvbiBkcmFnIGRvd24gYXMgb3ZlcmZsb3cgYmVjb21lcyB2aXNpYmxlXHJcbiAgICAgICAgdmFyIG91dGVyRGl2U3R5bGUgPSB0aGlzLnByb3BzLnB1bGxEb3duVG9SZWZyZXNoICYmIHRoaXMucHJvcHMuaGVpZ2h0XHJcbiAgICAgICAgICAgID8geyBvdmVyZmxvdzogJ2F1dG8nIH1cclxuICAgICAgICAgICAgOiB7fTtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogb3V0ZXJEaXZTdHlsZSwgY2xhc3NOYW1lOiBcImluZmluaXRlLXNjcm9sbC1jb21wb25lbnRfX291dGVyZGl2XCIgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJpbmZpbml0ZS1zY3JvbGwtY29tcG9uZW50IFwiICsgKHRoaXMucHJvcHMuY2xhc3NOYW1lIHx8ICcnKSwgcmVmOiBmdW5jdGlvbiAoaW5mU2Nyb2xsKSB7IHJldHVybiAoX3RoaXMuX2luZlNjcm9sbCA9IGluZlNjcm9sbCk7IH0sIHN0eWxlOiBzdHlsZSB9LFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5wdWxsRG93blRvUmVmcmVzaCAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IHBvc2l0aW9uOiAncmVsYXRpdmUnIH0sIHJlZjogZnVuY3Rpb24gKHB1bGxEb3duKSB7IHJldHVybiAoX3RoaXMuX3B1bGxEb3duID0gcHVsbERvd24pOyB9IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogLTEgKiB0aGlzLm1heFB1bGxEb3duRGlzdGFuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gfSwgdGhpcy5zdGF0ZS5wdWxsVG9SZWZyZXNoVGhyZXNob2xkQnJlYWNoZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnByb3BzLnJlbGVhc2VUb1JlZnJlc2hDb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5wcm9wcy5wdWxsRG93blRvUmVmcmVzaENvbnRlbnQpKSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuLFxyXG4gICAgICAgICAgICAgICAgIXRoaXMuc3RhdGUuc2hvd0xvYWRlciAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFoYXNDaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMuaGFzTW9yZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMubG9hZGVyLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zaG93TG9hZGVyICYmIHRoaXMucHJvcHMuaGFzTW9yZSAmJiB0aGlzLnByb3BzLmxvYWRlcixcclxuICAgICAgICAgICAgICAgICF0aGlzLnByb3BzLmhhc01vcmUgJiYgdGhpcy5wcm9wcy5lbmRNZXNzYWdlKSkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJbmZpbml0ZVNjcm9sbDtcclxufShDb21wb25lbnQpKTtcblxuZXhwb3J0IGRlZmF1bHQgSW5maW5pdGVTY3JvbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIkNvbXBvbmVudCIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwiaGFzT3duUHJvcGVydHkiLCJfX2V4dGVuZHMiLCJfXyIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiY3JlYXRlIiwiX19hc3NpZ24iLCJhc3NpZ24iLCJ0IiwicyIsImkiLCJuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY2FsbCIsImFwcGx5IiwidGhyb3R0bGUiLCJkZWxheSIsIm5vVHJhaWxpbmciLCJjYWxsYmFjayIsImRlYm91bmNlTW9kZSIsInRpbWVvdXRJRCIsImNhbmNlbGxlZCIsImxhc3RFeGVjIiwiY2xlYXJFeGlzdGluZ1RpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJjYW5jZWwiLCJ1bmRlZmluZWQiLCJ3cmFwcGVyIiwic2VsZiIsImVsYXBzZWQiLCJEYXRlIiwibm93IiwiYXJncyIsImV4ZWMiLCJjbGVhciIsInNldFRpbWVvdXQiLCJUaHJlc2hvbGRVbml0cyIsIlBpeGVsIiwiUGVyY2VudCIsImRlZmF1bHRUaHJlc2hvbGQiLCJ1bml0IiwidmFsdWUiLCJwYXJzZVRocmVzaG9sZCIsInNjcm9sbFRocmVzaG9sZCIsIm1hdGNoIiwicGFyc2VGbG9hdCIsImNvbnNvbGUiLCJ3YXJuIiwiSW5maW5pdGVTY3JvbGwiLCJfc3VwZXIiLCJwcm9wcyIsIl90aGlzIiwibGFzdFNjcm9sbFRvcCIsImFjdGlvblRyaWdnZXJlZCIsInN0YXJ0WSIsImN1cnJlbnRZIiwiZHJhZ2dpbmciLCJtYXhQdWxsRG93bkRpc3RhbmNlIiwiZ2V0U2Nyb2xsYWJsZVRhcmdldCIsInNjcm9sbGFibGVUYXJnZXQiLCJIVE1MRWxlbWVudCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJvblN0YXJ0IiwiZXZ0IiwiTW91c2VFdmVudCIsInBhZ2VZIiwiVG91Y2hFdmVudCIsInRvdWNoZXMiLCJfaW5mU2Nyb2xsIiwic3R5bGUiLCJ3aWxsQ2hhbmdlIiwidHJhbnNpdGlvbiIsIm9uTW92ZSIsIk51bWJlciIsInB1bGxEb3duVG9SZWZyZXNoVGhyZXNob2xkIiwic2V0U3RhdGUiLCJwdWxsVG9SZWZyZXNoVGhyZXNob2xkQnJlYWNoZWQiLCJvdmVyZmxvdyIsInRyYW5zZm9ybSIsIm9uRW5kIiwic3RhdGUiLCJyZWZyZXNoRnVuY3Rpb24iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvblNjcm9sbExpc3RlbmVyIiwiZXZlbnQiLCJvblNjcm9sbCIsInRhcmdldCIsImhlaWdodCIsIl9zY3JvbGxhYmxlTm9kZSIsImRvY3VtZW50RWxlbWVudCIsInNjcm9sbFRvcCIsImJvZHkiLCJhdEJvdHRvbSIsImludmVyc2UiLCJpc0VsZW1lbnRBdFRvcCIsImlzRWxlbWVudEF0Qm90dG9tIiwiaGFzTW9yZSIsInNob3dMb2FkZXIiLCJuZXh0IiwicHJldkRhdGFMZW5ndGgiLCJkYXRhTGVuZ3RoIiwidGhyb3R0bGVkT25TY3JvbGxMaXN0ZW5lciIsImJpbmQiLCJjb21wb25lbnREaWRNb3VudCIsIkVycm9yIiwiZWwiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiaW5pdGlhbFNjcm9sbFkiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxUbyIsInB1bGxEb3duVG9SZWZyZXNoIiwiX3B1bGxEb3duIiwiZmlyc3RDaGlsZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImZvcmNlVXBkYXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibmV4dFByb3BzIiwicHJldlN0YXRlIiwiZGF0YUxlbmd0aENoYW5nZWQiLCJjbGllbnRIZWlnaHQiLCJzY3JlZW4iLCJhdmFpbEhlaWdodCIsInRocmVzaG9sZCIsInJlbmRlciIsIldlYmtpdE92ZXJmbG93U2Nyb2xsaW5nIiwiaGFzQ2hpbGRyZW4iLCJjaGlsZHJlbiIsIm91dGVyRGl2U3R5bGUiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwicmVmIiwiaW5mU2Nyb2xsIiwicG9zaXRpb24iLCJwdWxsRG93biIsImxlZnQiLCJyaWdodCIsInRvcCIsInJlbGVhc2VUb1JlZnJlc2hDb250ZW50IiwicHVsbERvd25Ub1JlZnJlc2hDb250ZW50IiwibG9hZGVyIiwiZW5kTWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-infinite-scroll-component/dist/index.es.js\n");

/***/ })

};
;